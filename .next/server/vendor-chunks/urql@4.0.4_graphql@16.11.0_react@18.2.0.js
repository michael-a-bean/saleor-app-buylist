/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/urql@4.0.4_graphql@16.11.0_react@18.2.0";
exports.ids = ["vendor-chunks/urql@4.0.4_graphql@16.11.0_react@18.2.0"];
exports.modules = {

/***/ "(pages-dir-node)/../../node_modules/.pnpm/urql@4.0.4_graphql@16.11.0_react@18.2.0/node_modules/urql/dist/urql.js":
/*!*******************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/urql@4.0.4_graphql@16.11.0_react@18.2.0/node_modules/urql/dist/urql.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("Object.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar core = __webpack_require__(/*! @urql/core */ \"(pages-dir-node)/../../node_modules/.pnpm/@urql+core@4.0.10_graphql@16.11.0/node_modules/@urql/core/dist/urql-core.js\");\nvar React = __webpack_require__(/*! react */ \"react\");\nvar wonka = __webpack_require__(/*! wonka */ \"(pages-dir-node)/../../node_modules/.pnpm/wonka@6.3.2/node_modules/wonka/dist/wonka.js\");\n\nvar OBJ = {};\n\n/** `urql`'s React Context.\n *\n * @remarks\n * The React Context that `urql`’s {@link Client} will be provided with.\n * You may use the reexported {@link Provider} to provide a `Client` as well.\n */\nvar Context = React.createContext(OBJ);\n\n/** Provider for `urql`'s {@link Client} to GraphQL hooks.\n *\n * @remarks\n * `Provider` accepts a {@link Client} and provides it to all GraphQL hooks,\n * and {@link useClient}.\n *\n * You should make sure to create a {@link Client} and provide it with the\n * `Provider` to parts of your component tree that use GraphQL hooks.\n *\n * @example\n * ```tsx\n * import { Provider } from 'urql';\n * // All of `@urql/core` is also re-exported by `urql`:\n * import { Client, cacheExchange, fetchExchange } from '@urql/core';\n *\n * const client = new Client({\n *   url: 'https://API',\n *   exchanges: [cacheExchange, fetchExchange],\n * });\n *\n * const App = () => (\n *   <Provider value={client}>\n *     <Component />\n *   </Provider>\n * );\n * ```\n */\nvar Provider = Context.Provider;\n\n/** React Consumer component, providing the {@link Client} provided on a parent component.\n * @remarks\n * This is an alias for {@link Context.Consumer}.\n */\nvar Consumer = Context.Consumer;\nContext.displayName = 'UrqlContext';\n\n/** Hook returning a {@link Client} from {@link Context}.\n *\n * @remarks\n * `useClient` is a convenience hook, which accesses `urql`'s {@link Context}\n * and returns the {@link Client} defined on it.\n *\n * This will be the {@link Client} you passed to a {@link Provider}\n * you wrapped your elements containing this hook with.\n *\n * @throws\n * In development, if the component you call `useClient()` in is\n * not wrapped in a {@link Provider}, an error is thrown.\n */\nvar useClient = () => {\n  var client = React.useContext(Context);\n  if (client === OBJ && \"development\" !== 'production') {\n    var error = \"No client has been specified using urql's Provider. please create a client and add a Provider.\";\n    console.error(error);\n    throw new Error(error);\n  }\n  return client;\n};\n\nvar initialState = {\n  fetching: false,\n  stale: false,\n  error: undefined,\n  data: undefined,\n  extensions: undefined,\n  operation: undefined\n};\n\n// Two operations are considered equal if they have the same key\nvar areOperationsEqual = (a, b) => {\n  return a === b || !!(a && b && a.key === b.key);\n};\n\n/**\n * Checks if two objects are shallowly different with a special case for\n * 'operation' where it compares the key if they are not the otherwise equal\n */\nvar isShallowDifferent = (a, b) => {\n  for (var key in a) if (!(key in b)) return true;\n  for (var _key in b) {\n    if (_key === 'operation' ? !areOperationsEqual(a[_key], b[_key]) : a[_key] !== b[_key]) {\n      return true;\n    }\n  }\n  return false;\n};\nvar computeNextState = (prevState, result) => {\n  var newState = {\n    ...prevState,\n    ...result,\n    data: result.data !== undefined || result.error ? result.data : prevState.data,\n    fetching: !!result.fetching,\n    stale: !!result.stale\n  };\n  return isShallowDifferent(prevState, newState) ? newState : prevState;\n};\nvar hasDepsChanged = (a, b) => {\n  for (var i = 0, l = b.length; i < l; i++) if (a[i] !== b[i]) return true;\n  return false;\n};\nvar reactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\nfunction deferDispatch(setState, value) {\n  if ( true && !!reactSharedInternals && !!reactSharedInternals.ReactCurrentOwner && !!reactSharedInternals.ReactCurrentOwner.current) {\n    Promise.resolve(value).then(setState);\n  } else {\n    setState(value);\n  }\n}\n\n/** State of the last mutation executed by your {@link useMutation} hook.\n *\n * @remarks\n * `UseMutationState` is returned (in a tuple) by {@link useMutation} and\n * gives you the {@link OperationResult} of the last mutation executed\n * with {@link UseMutationExecute}.\n *\n * Even if the mutation document passed to {@link useMutation} changes,\n * the state isn’t reset, so you can keep displaying the previous result.\n */\n\n/** Triggers {@link useMutation} to execute its GraphQL mutation operation.\n *\n * @param variables - variables using which the mutation will be executed.\n * @param context - optionally, context options that will be merged with the hook's\n * {@link UseQueryArgs.context} options and the `Client`’s options.\n * @returns the {@link OperationResult} of the mutation.\n *\n * @remarks\n * When called, {@link useMutation} will start the GraphQL mutation\n * it currently holds and use the `variables` passed to it.\n *\n * Once the mutation response comes back from the API, its\n * returned promise will resolve to the mutation’s {@link OperationResult}\n * and the {@link UseMutationState} will be updated with the result.\n *\n * @example\n * ```ts\n * const [result, executeMutation] = useMutation(UpdateTodo);\n * const start = async ({ id, title }) => {\n *   const result = await executeMutation({ id, title });\n * };\n */\n\n/** Result tuple returned by the {@link useMutation} hook.\n *\n * @remarks\n * Similarly to a `useState` hook’s return value,\n * the first element is the {@link useMutation}’s state, updated\n * as mutations are executed with the second value, which is\n * used to start mutations and is a {@link UseMutationExecute}\n * function.\n */\n\n/** Hook to create a GraphQL mutation, run by passing variables to the returned execute function.\n *\n * @param query - a GraphQL mutation document which `useMutation` will execute.\n * @returns a {@link UseMutationResponse} tuple of a {@link UseMutationState} result,\n * and an execute function to start the mutation.\n *\n * @remarks\n * `useMutation` allows GraphQL mutations to be defined and keeps its state\n * after the mutation is started with the returned execute function.\n *\n * Given a GraphQL mutation document it returns state to keep track of the\n * mutation state and a {@link UseMutationExecute} function, which accepts\n * variables for the mutation to be executed.\n * Once called, the mutation executes and the state will be updated with\n * the mutation’s result.\n *\n * @see {@link https://urql.dev/goto/urql/docs/basics/react-preact/#mutations} for `useMutation` docs.\n *\n * @example\n * ```ts\n * import { gql, useMutation } from 'urql';\n *\n * const UpdateTodo = gql`\n *   mutation ($id: ID!, $title: String!) {\n *     updateTodo(id: $id, title: $title) {\n *       id, title\n *     }\n *   }\n * `;\n *\n * const UpdateTodo = () => {\n *   const [result, executeMutation] = useMutation(UpdateTodo);\n *   const start = async ({ id, title }) => {\n *     const result = await executeMutation({ id, title });\n *   };\n *   // ...\n * };\n * ```\n */\nfunction useMutation(query) {\n  var isMounted = React.useRef(true);\n  var client = useClient();\n  var [state, setState] = React.useState(initialState);\n  var executeMutation = React.useCallback((variables, context) => {\n    deferDispatch(setState, {\n      ...initialState,\n      fetching: true\n    });\n    return wonka.toPromise(wonka.take(1)(wonka.filter(result => !result.hasNext)(wonka.onPush(result => {\n      if (isMounted.current) {\n        deferDispatch(setState, {\n          fetching: false,\n          stale: result.stale,\n          data: result.data,\n          error: result.error,\n          extensions: result.extensions,\n          operation: result.operation\n        });\n      }\n    })(client.executeMutation(core.createRequest(query, variables), context || {})))));\n  },\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [client, query, setState]);\n  React.useEffect(() => {\n    isMounted.current = true;\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n  return [state, executeMutation];\n}\n\n/** Creates a request from a query and variables but preserves reference equality if the key isn't changing\n * @internal\n */\nfunction useRequest(query, variables) {\n  var prev = React.useRef(undefined);\n  return React.useMemo(() => {\n    var request = core.createRequest(query, variables);\n    // We manually ensure reference equality if the key hasn't changed\n    if (prev.current !== undefined && prev.current.key === request.key) {\n      return prev.current;\n    } else {\n      prev.current = request;\n      return request;\n    }\n  }, [query, variables]);\n}\n\nvar getCacheForClient = client => {\n  if (!client._react) {\n    var reclaim = new Set();\n    var map = new Map();\n    if (client.operations$ /* not available in mocks */) {\n      wonka.subscribe(operation => {\n        if (operation.kind === 'teardown' && reclaim.has(operation.key)) {\n          reclaim.delete(operation.key);\n          map.delete(operation.key);\n        }\n      })(client.operations$);\n    }\n    client._react = {\n      get(key) {\n        return map.get(key);\n      },\n      set(key, value) {\n        reclaim.delete(key);\n        map.set(key, value);\n      },\n      dispose(key) {\n        reclaim.add(key);\n      }\n    };\n  }\n  return client._react;\n};\n\n/* eslint-disable react-hooks/exhaustive-deps */\n\n/** Input arguments for the {@link useQuery} hook.\n *\n * @param query - The GraphQL query that `useQuery` executes.\n * @param variables - The variables for the GraphQL query that `useQuery` executes.\n */\n\n/** State of the current query, your {@link useQuery} hook is executing.\n *\n * @remarks\n * `UseQueryState` is returned (in a tuple) by {@link useQuery} and\n * gives you the updating {@link OperationResult} of GraphQL queries.\n *\n * Even when the query and variables passed to {@link useQuery} change,\n * this state preserves the prior state and sets the `fetching` flag to\n * `true`.\n * This allows you to display the previous state, while implementing\n * a separate loading indicator separately.\n */\n\n/** Triggers {@link useQuery} to execute a new GraphQL query operation.\n *\n * @param opts - optionally, context options that will be merged with the hook's\n * {@link UseQueryArgs.context} options and the `Client`’s options.\n *\n * @remarks\n * When called, {@link useQuery} will re-execute the GraphQL query operation\n * it currently holds, even if {@link UseQueryArgs.pause} is set to `true`.\n *\n * This is useful for executing a paused query or re-executing a query\n * and get a new network result, by passing a new request policy.\n *\n * ```ts\n * const [result, reexecuteQuery] = useQuery({ query });\n *\n * const refresh = () => {\n *   // Re-execute the query with a network-only policy, skipping the cache\n *   reexecuteQuery({ requestPolicy: 'network-only' });\n * };\n * ```\n */\n\n/** Result tuple returned by the {@link useQuery} hook.\n *\n * @remarks\n * Similarly to a `useState` hook’s return value,\n * the first element is the {@link useQuery}’s result and state,\n * a {@link UseQueryState} object,\n * and the second is used to imperatively re-execute the query\n * via a {@link UseQueryExecute} function.\n */\n\nvar isSuspense = (client, context) => client.suspense && (!context || context.suspense !== false);\n\n/** Hook to run a GraphQL query and get updated GraphQL results.\n *\n * @param args - a {@link UseQueryArgs} object, to pass a `query`, `variables`, and options.\n * @returns a {@link UseQueryResponse} tuple of a {@link UseQueryState} result, and re-execute function.\n *\n * @remarks\n * `useQuery` allows GraphQL queries to be defined and executed.\n * Given {@link UseQueryArgs.query}, it executes the GraphQL query with the\n * context’s {@link Client}.\n *\n * The returned result updates when the `Client` has new results\n * for the query, and changes when your input `args` change.\n *\n * Additionally, if the `suspense` option is enabled on the `Client`,\n * the `useQuery` hook will suspend instead of indicating that it’s\n * waiting for a result via {@link UseQueryState.fetching}.\n *\n * @see {@link https://urql.dev/goto/urql/docs/basics/react-preact/#queries} for `useQuery` docs.\n *\n * @example\n * ```ts\n * import { gql, useQuery } from 'urql';\n *\n * const TodosQuery = gql`\n *   query { todos { id, title } }\n * `;\n *\n * const Todos = () => {\n *   const [result, reexecuteQuery] = useQuery({\n *     query: TodosQuery,\n *     variables: {},\n *   });\n *   // ...\n * };\n * ```\n */\nfunction useQuery(args) {\n  var client = useClient();\n  var cache = getCacheForClient(client);\n  var suspense = isSuspense(client, args.context);\n  var request = useRequest(args.query, args.variables);\n  var source = React.useMemo(() => {\n    if (args.pause) return null;\n    var source = client.executeQuery(request, {\n      requestPolicy: args.requestPolicy,\n      ...args.context\n    });\n    return suspense ? wonka.onPush(result => {\n      cache.set(request.key, result);\n    })(source) : source;\n  }, [cache, client, request, suspense, args.pause, args.requestPolicy, args.context]);\n  var getSnapshot = React.useCallback((source, suspense) => {\n    if (!source) return {\n      fetching: false\n    };\n    var result = cache.get(request.key);\n    if (!result) {\n      var resolve;\n      var subscription = wonka.subscribe(_result => {\n        result = _result;\n        if (resolve) resolve(result);\n      })(wonka.takeWhile(() => suspense && !resolve || !result)(source));\n      if (result == null && suspense) {\n        var promise = new Promise(_resolve => {\n          resolve = _resolve;\n        });\n        cache.set(request.key, promise);\n        throw promise;\n      } else {\n        subscription.unsubscribe();\n      }\n    } else if (suspense && result != null && 'then' in result) {\n      throw result;\n    }\n    return result || {\n      fetching: true\n    };\n  }, [cache, request]);\n  var deps = [client, request, args.requestPolicy, args.context, args.pause];\n  var [state, setState] = React.useState(() => [source, computeNextState(initialState, getSnapshot(source, suspense)), deps]);\n  var currentResult = state[1];\n  if (source !== state[0] && hasDepsChanged(state[2], deps)) {\n    setState([source, currentResult = computeNextState(state[1], getSnapshot(source, suspense)), deps]);\n  }\n  React.useEffect(() => {\n    var source = state[0];\n    var request = state[2][1];\n    var hasResult = false;\n    var updateResult = result => {\n      hasResult = true;\n      deferDispatch(setState, state => {\n        var nextResult = computeNextState(state[1], result);\n        return state[1] !== nextResult ? [state[0], nextResult, state[2]] : state;\n      });\n    };\n    if (source) {\n      var subscription = wonka.subscribe(updateResult)(wonka.onEnd(() => {\n        updateResult({\n          fetching: false\n        });\n      })(source));\n      if (!hasResult) updateResult({\n        fetching: true\n      });\n      return () => {\n        cache.dispose(request.key);\n        subscription.unsubscribe();\n      };\n    } else {\n      updateResult({\n        fetching: false\n      });\n    }\n  }, [cache, state[0], state[2][1]]);\n  var executeQuery = React.useCallback(opts => {\n    var context = {\n      requestPolicy: args.requestPolicy,\n      ...args.context,\n      ...opts\n    };\n    deferDispatch(setState, state => {\n      var source = suspense ? wonka.onPush(result => {\n        cache.set(request.key, result);\n      })(client.executeQuery(request, context)) : client.executeQuery(request, context);\n      return [source, state[1], deps];\n    });\n  }, [client, cache, request, suspense, getSnapshot, args.requestPolicy, args.context]);\n  return [currentResult, executeQuery];\n}\n\n/* eslint-disable react-hooks/exhaustive-deps */\n\n/** Input arguments for the {@link useSubscription} hook.\n *\n * @param query - The GraphQL subscription document that `useSubscription` executes.\n * @param variables - The variables for the GraphQL subscription that `useSubscription` executes.\n */\n\n/** Combines previous data with an incoming subscription result’s data.\n *\n * @remarks\n * A `SubscriptionHandler` may be passed to {@link useSubscription} to\n * aggregate subscription results into a combined {@link UseSubscriptionState.data}\n * value.\n *\n * This is useful when a subscription event delivers a single item, while\n * you’d like to display a list of events.\n *\n * @example\n * ```ts\n * const NotificationsSubscription = gql`\n *   subscription { newNotification { id, text } }\n * `;\n *\n * const combineNotifications = (notifications = [], data) => {\n *   return [...notifications, data.newNotification];\n * };\n *\n * const [result, executeSubscription] = useSubscription(\n *   { query: NotificationsSubscription },\n *   combineNotifications,\n * );\n * ```\n */\n\n/** State of the current subscription, your {@link useSubscription} hook is executing.\n *\n * @remarks\n * `UseSubscriptionState` is returned (in a tuple) by {@link useSubscription} and\n * gives you the updating {@link OperationResult} of GraphQL subscriptions.\n *\n * If a {@link SubscriptionHandler} has been passed to `useSubscription` then\n * {@link UseSubscriptionState.data} is instead the updated data as returned\n * by the handler, otherwise it’s the latest result’s data.\n *\n * Hint: Even when the query and variables passed to {@link useSubscription} change,\n * this state preserves the prior state.\n */\n\n/** Triggers {@link useSubscription} to reexecute a GraphQL subscription operation.\n *\n * @param opts - optionally, context options that will be merged with the hook's\n * {@link UseSubscriptionArgs.context} options and the `Client`’s options.\n *\n * @remarks\n * When called, {@link useSubscription} will restart the GraphQL subscription\n * operation it currently holds. If {@link UseSubscriptionArgs.pause} is set\n * to `true`, it will start executing the subscription.\n *\n * ```ts\n * const [result, executeSubscription] = useSubscription({\n *   query,\n *   pause: true,\n * });\n *\n * const start = () => {\n *   executeSubscription();\n * };\n * ```\n */\n\n/** Result tuple returned by the {@link useSubscription} hook.\n *\n * @remarks\n * Similarly to a `useState` hook’s return value,\n * the first element is the {@link useSubscription}’s state,\n * a {@link UseSubscriptionState} object,\n * and the second is used to imperatively re-execute or start the subscription\n * via a {@link UseMutationExecute} function.\n */\n\n/** Hook to run a GraphQL subscription and get updated GraphQL results.\n *\n * @param args - a {@link UseSubscriptionArgs} object, to pass a `query`, `variables`, and options.\n * @param handler - optionally, a {@link SubscriptionHandler} function to combine multiple subscription results.\n * @returns a {@link UseSubscriptionResponse} tuple of a {@link UseSubscriptionState} result, and an execute function.\n *\n * @remarks\n * `useSubscription` allows GraphQL subscriptions to be defined and executed.\n * Given {@link UseSubscriptionArgs.query}, it executes the GraphQL subscription with the\n * context’s {@link Client}.\n *\n * The returned result updates when the `Client` has new results\n * for the subscription, and `data` is updated with the result’s data\n * or with the `data` that a `handler` returns.\n *\n * @example\n * ```ts\n * import { gql, useSubscription } from 'urql';\n *\n * const NotificationsSubscription = gql`\n *   subscription { newNotification { id, text } }\n * `;\n *\n * const combineNotifications = (notifications = [], data) => {\n *   return [...notifications, data.newNotification];\n * };\n *\n * const Notifications = () => {\n *   const [result, executeSubscription] = useSubscription(\n *     { query: NotificationsSubscription },\n *     combineNotifications,\n *   );\n *   // ...\n * };\n * ```\n */\nfunction useSubscription(args, handler) {\n  var client = useClient();\n  var request = useRequest(args.query, args.variables);\n  var handlerRef = React.useRef(handler);\n  handlerRef.current = handler;\n  var source = React.useMemo(() => !args.pause ? client.executeSubscription(request, args.context) : null, [client, request, args.pause, args.context]);\n  var deps = [client, request, args.context, args.pause];\n  var [state, setState] = React.useState(() => [source, {\n    ...initialState,\n    fetching: !!source\n  }, deps]);\n  var currentResult = state[1];\n  if (source !== state[0] && hasDepsChanged(state[2], deps)) {\n    setState([source, currentResult = computeNextState(state[1], {\n      fetching: !!source\n    }), deps]);\n  }\n  React.useEffect(() => {\n    var updateResult = result => {\n      deferDispatch(setState, state => {\n        var nextResult = computeNextState(state[1], result);\n        if (state[1] === nextResult) return state;\n        if (handlerRef.current && state[1].data !== nextResult.data) {\n          nextResult.data = handlerRef.current(state[1].data, nextResult.data);\n        }\n        return [state[0], nextResult, state[2]];\n      });\n    };\n    if (state[0]) {\n      return wonka.subscribe(updateResult)(wonka.onEnd(() => {\n        updateResult({\n          fetching: !!source\n        });\n      })(state[0])).unsubscribe;\n    } else {\n      updateResult({\n        fetching: false\n      });\n    }\n  }, [state[0]]);\n\n  // This is the imperative execute function passed to the user\n  var executeSubscription = React.useCallback(opts => {\n    var source = client.executeSubscription(request, {\n      ...args.context,\n      ...opts\n    });\n    deferDispatch(setState, state => [source, state[1], deps]);\n  }, [client, args.context, request]);\n  return [currentResult, executeSubscription];\n}\n\n/** Props accepted by {@link Mutation}.\n *\n * @remarks\n * `MutationProps` are the props accepted by the {@link Mutation} component.\n *\n * The result, the {@link MutationState} object, will be passed to\n * a {@link MutationProps.children} function, passed as children\n * to the `Mutation` component.\n */\n\n/** Object that {@link MutationProps.children} is called with.\n *\n * @remarks\n * This is an extented {@link UseMutationstate} with an added\n * {@link MutationState.executeMutation} method, which is usually\n * part of a tuple returned by {@link useMutation}.\n */\n\n/** Component Wrapper around {@link useMutation} to run a GraphQL query.\n *\n * @remarks\n * `Mutation` is a component wrapper around the {@link useMutation} hook\n * that calls the {@link MutationProps.children} prop, as a function,\n * with the {@link MutationState} object.\n */\nfunction Mutation(props) {\n  var mutation = useMutation(props.query);\n  return props.children({\n    ...mutation[0],\n    executeMutation: mutation[1]\n  });\n}\n\n/** Props accepted by {@link Query}.\n *\n * @remarks\n * `QueryProps` are the props accepted by the {@link Query} component,\n * which is identical to {@link UseQueryArgs}.\n *\n * The result, the {@link QueryState} object, will be passed to\n * a {@link QueryProps.children} function, passed as children\n * to the `Query` component.\n */\n\n/** Object that {@link QueryProps.children} is called with.\n *\n * @remarks\n * This is an extented {@link UseQueryState} with an added\n * {@link QueryState.executeQuery} method, which is usually\n * part of a tuple returned by {@link useQuery}.\n */\n\n/** Component Wrapper around {@link useQuery} to run a GraphQL query.\n *\n * @remarks\n * `Query` is a component wrapper around the {@link useQuery} hook\n * that calls the {@link QueryProps.children} prop, as a function,\n * with the {@link QueryState} object.\n */\nfunction Query(props) {\n  var query = useQuery(props);\n  return props.children({\n    ...query[0],\n    executeQuery: query[1]\n  });\n}\n\n/** Props accepted by {@link Subscription}.\n *\n * @remarks\n * `SubscriptionProps` are the props accepted by the {@link Subscription} component,\n * which is identical to {@link UseSubscriptionArgs} with an added\n * {@link SubscriptionProps.handler} prop, which {@link useSubscription} usually\n * accepts as an additional argument.\n *\n * The result, the {@link SubscriptionState} object, will be passed to\n * a {@link SubscriptionProps.children} function, passed as children\n * to the `Subscription` component.\n */\n\n/** Object that {@link SubscriptionProps.children} is called with.\n *\n * @remarks\n * This is an extented {@link UseSubscriptionState} with an added\n * {@link SubscriptionState.executeSubscription} method, which is usually\n * part of a tuple returned by {@link useSubscription}.\n */\n\n/** Component Wrapper around {@link useSubscription} to run a GraphQL subscription.\n *\n * @remarks\n * `Subscription` is a component wrapper around the {@link useSubscription} hook\n * that calls the {@link SubscriptionProps.children} prop, as a function,\n * with the {@link SubscriptionState} object.\n */\nfunction Subscription(props) {\n  var subscription = useSubscription(props, props.handler);\n  return props.children({\n    ...subscription[0],\n    executeSubscription: subscription[1]\n  });\n}\n\nexports.Consumer = Consumer;\nexports.Context = Context;\nexports.Mutation = Mutation;\nexports.Provider = Provider;\nexports.Query = Query;\nexports.Subscription = Subscription;\nexports.useClient = useClient;\nexports.useMutation = useMutation;\nexports.useQuery = useQuery;\nexports.useSubscription = useSubscription;\nObject.keys(core).forEach(function (k) {\nif (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {\nenumerable: true,\nget: function () { return core[k]; }\n});\n});\n//# sourceMappingURL=urql.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdXJxbEA0LjAuNF9ncmFwaHFsQDE2LjExLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy91cnFsL2Rpc3QvdXJxbC5qcyIsIm1hcHBpbmdzIjoiQUFBQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdELFdBQVcsbUJBQU8sQ0FBQyx5SUFBWTtBQUMvQixZQUFZLG1CQUFPLENBQUMsb0JBQU87QUFDM0IsWUFBWSxtQkFBTyxDQUFDLHFHQUFPOztBQUUzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRCwrQkFBK0IsZ0JBQWdCO0FBQy9DO0FBQ0E7O0FBRUEsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBLHlCQUF5QixjQUFjO0FBQ3ZDLFFBQVEsZ0JBQWdCO0FBQ3hCO0FBQ0EscUNBQXFDLGNBQWM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQSxZQUFZLHVDQUF1QztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QyxjQUFjO0FBQzNEO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGNBQWMsTUFBTSxjQUFjO0FBQ3hEO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Qsb0JBQW9CLGNBQWM7QUFDbEM7QUFDQSxxQkFBcUIsY0FBYyxpQkFBaUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsYUFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QUE4QyxnQkFBZ0I7QUFDOUQsbUJBQW1CLDJCQUEyQjtBQUM5QyxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0Esc0RBQXNELG9CQUFvQjtBQUMxRSwwQkFBMEIsMkJBQTJCO0FBQ3JELElBQUksaUNBQWlDLGFBQWEsdUJBQXVCO0FBQ3pFO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDLE1BQU0sa0NBQWtDO0FBQ3hDO0FBQ0E7O0FBRUEsaUJBQWlCLGtDQUFrQztBQUNuRDtBQUNBO0FBQ0Esd0JBQXdCLDRCQUE0QjtBQUNwRCxJQUFJLDZDQUE2QztBQUNqRCxnQ0FBZ0Msc0JBQXNCO0FBQ3REOztBQUVBLDhCQUE4Qix1QkFBdUI7QUFDckQ7QUFDQTtBQUNBLHFEQUFxRCx1QkFBdUI7QUFDNUUsbUJBQW1CLGtDQUFrQztBQUNyRCxhQUFhLHlCQUF5QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsZ0JBQWdCO0FBQ2hCLGVBQWU7QUFDZixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGFBQWE7QUFDYixvQkFBb0I7QUFDcEIsaUJBQWlCO0FBQ2pCLG1CQUFtQjtBQUNuQixnQkFBZ0I7QUFDaEIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixDQUFDO0FBQ0QsQ0FBQztBQUNEIiwic291cmNlcyI6WyIvaG9tZS9taWNoYWVsL3NhbGVvci1wbGF0Zm9ybS9zYWxlb3ItYXBwcy9ub2RlX21vZHVsZXMvLnBucG0vdXJxbEA0LjAuNF9ncmFwaHFsQDE2LjExLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy91cnFsL2Rpc3QvdXJxbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ0B1cnFsL2NvcmUnKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgd29ua2EgPSByZXF1aXJlKCd3b25rYScpO1xuXG52YXIgT0JKID0ge307XG5cbi8qKiBgdXJxbGAncyBSZWFjdCBDb250ZXh0LlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGUgUmVhY3QgQ29udGV4dCB0aGF0IGB1cnFsYOKAmXMge0BsaW5rIENsaWVudH0gd2lsbCBiZSBwcm92aWRlZCB3aXRoLlxuICogWW91IG1heSB1c2UgdGhlIHJlZXhwb3J0ZWQge0BsaW5rIFByb3ZpZGVyfSB0byBwcm92aWRlIGEgYENsaWVudGAgYXMgd2VsbC5cbiAqL1xudmFyIENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KE9CSik7XG5cbi8qKiBQcm92aWRlciBmb3IgYHVycWxgJ3Mge0BsaW5rIENsaWVudH0gdG8gR3JhcGhRTCBob29rcy5cbiAqXG4gKiBAcmVtYXJrc1xuICogYFByb3ZpZGVyYCBhY2NlcHRzIGEge0BsaW5rIENsaWVudH0gYW5kIHByb3ZpZGVzIGl0IHRvIGFsbCBHcmFwaFFMIGhvb2tzLFxuICogYW5kIHtAbGluayB1c2VDbGllbnR9LlxuICpcbiAqIFlvdSBzaG91bGQgbWFrZSBzdXJlIHRvIGNyZWF0ZSBhIHtAbGluayBDbGllbnR9IGFuZCBwcm92aWRlIGl0IHdpdGggdGhlXG4gKiBgUHJvdmlkZXJgIHRvIHBhcnRzIG9mIHlvdXIgY29tcG9uZW50IHRyZWUgdGhhdCB1c2UgR3JhcGhRTCBob29rcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBpbXBvcnQgeyBQcm92aWRlciB9IGZyb20gJ3VycWwnO1xuICogLy8gQWxsIG9mIGBAdXJxbC9jb3JlYCBpcyBhbHNvIHJlLWV4cG9ydGVkIGJ5IGB1cnFsYDpcbiAqIGltcG9ydCB7IENsaWVudCwgY2FjaGVFeGNoYW5nZSwgZmV0Y2hFeGNoYW5nZSB9IGZyb20gJ0B1cnFsL2NvcmUnO1xuICpcbiAqIGNvbnN0IGNsaWVudCA9IG5ldyBDbGllbnQoe1xuICogICB1cmw6ICdodHRwczovL0FQSScsXG4gKiAgIGV4Y2hhbmdlczogW2NhY2hlRXhjaGFuZ2UsIGZldGNoRXhjaGFuZ2VdLFxuICogfSk7XG4gKlxuICogY29uc3QgQXBwID0gKCkgPT4gKFxuICogICA8UHJvdmlkZXIgdmFsdWU9e2NsaWVudH0+XG4gKiAgICAgPENvbXBvbmVudCAvPlxuICogICA8L1Byb3ZpZGVyPlxuICogKTtcbiAqIGBgYFxuICovXG52YXIgUHJvdmlkZXIgPSBDb250ZXh0LlByb3ZpZGVyO1xuXG4vKiogUmVhY3QgQ29uc3VtZXIgY29tcG9uZW50LCBwcm92aWRpbmcgdGhlIHtAbGluayBDbGllbnR9IHByb3ZpZGVkIG9uIGEgcGFyZW50IGNvbXBvbmVudC5cbiAqIEByZW1hcmtzXG4gKiBUaGlzIGlzIGFuIGFsaWFzIGZvciB7QGxpbmsgQ29udGV4dC5Db25zdW1lcn0uXG4gKi9cbnZhciBDb25zdW1lciA9IENvbnRleHQuQ29uc3VtZXI7XG5Db250ZXh0LmRpc3BsYXlOYW1lID0gJ1VycWxDb250ZXh0JztcblxuLyoqIEhvb2sgcmV0dXJuaW5nIGEge0BsaW5rIENsaWVudH0gZnJvbSB7QGxpbmsgQ29udGV4dH0uXG4gKlxuICogQHJlbWFya3NcbiAqIGB1c2VDbGllbnRgIGlzIGEgY29udmVuaWVuY2UgaG9vaywgd2hpY2ggYWNjZXNzZXMgYHVycWxgJ3Mge0BsaW5rIENvbnRleHR9XG4gKiBhbmQgcmV0dXJucyB0aGUge0BsaW5rIENsaWVudH0gZGVmaW5lZCBvbiBpdC5cbiAqXG4gKiBUaGlzIHdpbGwgYmUgdGhlIHtAbGluayBDbGllbnR9IHlvdSBwYXNzZWQgdG8gYSB7QGxpbmsgUHJvdmlkZXJ9XG4gKiB5b3Ugd3JhcHBlZCB5b3VyIGVsZW1lbnRzIGNvbnRhaW5pbmcgdGhpcyBob29rIHdpdGguXG4gKlxuICogQHRocm93c1xuICogSW4gZGV2ZWxvcG1lbnQsIGlmIHRoZSBjb21wb25lbnQgeW91IGNhbGwgYHVzZUNsaWVudCgpYCBpbiBpc1xuICogbm90IHdyYXBwZWQgaW4gYSB7QGxpbmsgUHJvdmlkZXJ9LCBhbiBlcnJvciBpcyB0aHJvd24uXG4gKi9cbnZhciB1c2VDbGllbnQgPSAoKSA9PiB7XG4gIHZhciBjbGllbnQgPSBSZWFjdC51c2VDb250ZXh0KENvbnRleHQpO1xuICBpZiAoY2xpZW50ID09PSBPQkogJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBlcnJvciA9IFwiTm8gY2xpZW50IGhhcyBiZWVuIHNwZWNpZmllZCB1c2luZyB1cnFsJ3MgUHJvdmlkZXIuIHBsZWFzZSBjcmVhdGUgYSBjbGllbnQgYW5kIGFkZCBhIFByb3ZpZGVyLlwiO1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XG4gIH1cbiAgcmV0dXJuIGNsaWVudDtcbn07XG5cbnZhciBpbml0aWFsU3RhdGUgPSB7XG4gIGZldGNoaW5nOiBmYWxzZSxcbiAgc3RhbGU6IGZhbHNlLFxuICBlcnJvcjogdW5kZWZpbmVkLFxuICBkYXRhOiB1bmRlZmluZWQsXG4gIGV4dGVuc2lvbnM6IHVuZGVmaW5lZCxcbiAgb3BlcmF0aW9uOiB1bmRlZmluZWRcbn07XG5cbi8vIFR3byBvcGVyYXRpb25zIGFyZSBjb25zaWRlcmVkIGVxdWFsIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSBrZXlcbnZhciBhcmVPcGVyYXRpb25zRXF1YWwgPSAoYSwgYikgPT4ge1xuICByZXR1cm4gYSA9PT0gYiB8fCAhIShhICYmIGIgJiYgYS5rZXkgPT09IGIua2V5KTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHR3byBvYmplY3RzIGFyZSBzaGFsbG93bHkgZGlmZmVyZW50IHdpdGggYSBzcGVjaWFsIGNhc2UgZm9yXG4gKiAnb3BlcmF0aW9uJyB3aGVyZSBpdCBjb21wYXJlcyB0aGUga2V5IGlmIHRoZXkgYXJlIG5vdCB0aGUgb3RoZXJ3aXNlIGVxdWFsXG4gKi9cbnZhciBpc1NoYWxsb3dEaWZmZXJlbnQgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBrZXkgaW4gYSkgaWYgKCEoa2V5IGluIGIpKSByZXR1cm4gdHJ1ZTtcbiAgZm9yICh2YXIgX2tleSBpbiBiKSB7XG4gICAgaWYgKF9rZXkgPT09ICdvcGVyYXRpb24nID8gIWFyZU9wZXJhdGlvbnNFcXVhbChhW19rZXldLCBiW19rZXldKSA6IGFbX2tleV0gIT09IGJbX2tleV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xudmFyIGNvbXB1dGVOZXh0U3RhdGUgPSAocHJldlN0YXRlLCByZXN1bHQpID0+IHtcbiAgdmFyIG5ld1N0YXRlID0ge1xuICAgIC4uLnByZXZTdGF0ZSxcbiAgICAuLi5yZXN1bHQsXG4gICAgZGF0YTogcmVzdWx0LmRhdGEgIT09IHVuZGVmaW5lZCB8fCByZXN1bHQuZXJyb3IgPyByZXN1bHQuZGF0YSA6IHByZXZTdGF0ZS5kYXRhLFxuICAgIGZldGNoaW5nOiAhIXJlc3VsdC5mZXRjaGluZyxcbiAgICBzdGFsZTogISFyZXN1bHQuc3RhbGVcbiAgfTtcbiAgcmV0dXJuIGlzU2hhbGxvd0RpZmZlcmVudChwcmV2U3RhdGUsIG5ld1N0YXRlKSA/IG5ld1N0YXRlIDogcHJldlN0YXRlO1xufTtcbnZhciBoYXNEZXBzQ2hhbmdlZCA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYi5sZW5ndGg7IGkgPCBsOyBpKyspIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufTtcbnZhciByZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuZnVuY3Rpb24gZGVmZXJEaXNwYXRjaChzZXRTdGF0ZSwgdmFsdWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgISFyZWFjdFNoYXJlZEludGVybmFscyAmJiAhIXJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyICYmICEhcmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihzZXRTdGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgc2V0U3RhdGUodmFsdWUpO1xuICB9XG59XG5cbi8qKiBTdGF0ZSBvZiB0aGUgbGFzdCBtdXRhdGlvbiBleGVjdXRlZCBieSB5b3VyIHtAbGluayB1c2VNdXRhdGlvbn0gaG9vay5cbiAqXG4gKiBAcmVtYXJrc1xuICogYFVzZU11dGF0aW9uU3RhdGVgIGlzIHJldHVybmVkIChpbiBhIHR1cGxlKSBieSB7QGxpbmsgdXNlTXV0YXRpb259IGFuZFxuICogZ2l2ZXMgeW91IHRoZSB7QGxpbmsgT3BlcmF0aW9uUmVzdWx0fSBvZiB0aGUgbGFzdCBtdXRhdGlvbiBleGVjdXRlZFxuICogd2l0aCB7QGxpbmsgVXNlTXV0YXRpb25FeGVjdXRlfS5cbiAqXG4gKiBFdmVuIGlmIHRoZSBtdXRhdGlvbiBkb2N1bWVudCBwYXNzZWQgdG8ge0BsaW5rIHVzZU11dGF0aW9ufSBjaGFuZ2VzLFxuICogdGhlIHN0YXRlIGlzbuKAmXQgcmVzZXQsIHNvIHlvdSBjYW4ga2VlcCBkaXNwbGF5aW5nIHRoZSBwcmV2aW91cyByZXN1bHQuXG4gKi9cblxuLyoqIFRyaWdnZXJzIHtAbGluayB1c2VNdXRhdGlvbn0gdG8gZXhlY3V0ZSBpdHMgR3JhcGhRTCBtdXRhdGlvbiBvcGVyYXRpb24uXG4gKlxuICogQHBhcmFtIHZhcmlhYmxlcyAtIHZhcmlhYmxlcyB1c2luZyB3aGljaCB0aGUgbXV0YXRpb24gd2lsbCBiZSBleGVjdXRlZC5cbiAqIEBwYXJhbSBjb250ZXh0IC0gb3B0aW9uYWxseSwgY29udGV4dCBvcHRpb25zIHRoYXQgd2lsbCBiZSBtZXJnZWQgd2l0aCB0aGUgaG9vaydzXG4gKiB7QGxpbmsgVXNlUXVlcnlBcmdzLmNvbnRleHR9IG9wdGlvbnMgYW5kIHRoZSBgQ2xpZW50YOKAmXMgb3B0aW9ucy5cbiAqIEByZXR1cm5zIHRoZSB7QGxpbmsgT3BlcmF0aW9uUmVzdWx0fSBvZiB0aGUgbXV0YXRpb24uXG4gKlxuICogQHJlbWFya3NcbiAqIFdoZW4gY2FsbGVkLCB7QGxpbmsgdXNlTXV0YXRpb259IHdpbGwgc3RhcnQgdGhlIEdyYXBoUUwgbXV0YXRpb25cbiAqIGl0IGN1cnJlbnRseSBob2xkcyBhbmQgdXNlIHRoZSBgdmFyaWFibGVzYCBwYXNzZWQgdG8gaXQuXG4gKlxuICogT25jZSB0aGUgbXV0YXRpb24gcmVzcG9uc2UgY29tZXMgYmFjayBmcm9tIHRoZSBBUEksIGl0c1xuICogcmV0dXJuZWQgcHJvbWlzZSB3aWxsIHJlc29sdmUgdG8gdGhlIG11dGF0aW9u4oCZcyB7QGxpbmsgT3BlcmF0aW9uUmVzdWx0fVxuICogYW5kIHRoZSB7QGxpbmsgVXNlTXV0YXRpb25TdGF0ZX0gd2lsbCBiZSB1cGRhdGVkIHdpdGggdGhlIHJlc3VsdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IFtyZXN1bHQsIGV4ZWN1dGVNdXRhdGlvbl0gPSB1c2VNdXRhdGlvbihVcGRhdGVUb2RvKTtcbiAqIGNvbnN0IHN0YXJ0ID0gYXN5bmMgKHsgaWQsIHRpdGxlIH0pID0+IHtcbiAqICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXhlY3V0ZU11dGF0aW9uKHsgaWQsIHRpdGxlIH0pO1xuICogfTtcbiAqL1xuXG4vKiogUmVzdWx0IHR1cGxlIHJldHVybmVkIGJ5IHRoZSB7QGxpbmsgdXNlTXV0YXRpb259IGhvb2suXG4gKlxuICogQHJlbWFya3NcbiAqIFNpbWlsYXJseSB0byBhIGB1c2VTdGF0ZWAgaG9va+KAmXMgcmV0dXJuIHZhbHVlLFxuICogdGhlIGZpcnN0IGVsZW1lbnQgaXMgdGhlIHtAbGluayB1c2VNdXRhdGlvbn3igJlzIHN0YXRlLCB1cGRhdGVkXG4gKiBhcyBtdXRhdGlvbnMgYXJlIGV4ZWN1dGVkIHdpdGggdGhlIHNlY29uZCB2YWx1ZSwgd2hpY2ggaXNcbiAqIHVzZWQgdG8gc3RhcnQgbXV0YXRpb25zIGFuZCBpcyBhIHtAbGluayBVc2VNdXRhdGlvbkV4ZWN1dGV9XG4gKiBmdW5jdGlvbi5cbiAqL1xuXG4vKiogSG9vayB0byBjcmVhdGUgYSBHcmFwaFFMIG11dGF0aW9uLCBydW4gYnkgcGFzc2luZyB2YXJpYWJsZXMgdG8gdGhlIHJldHVybmVkIGV4ZWN1dGUgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHF1ZXJ5IC0gYSBHcmFwaFFMIG11dGF0aW9uIGRvY3VtZW50IHdoaWNoIGB1c2VNdXRhdGlvbmAgd2lsbCBleGVjdXRlLlxuICogQHJldHVybnMgYSB7QGxpbmsgVXNlTXV0YXRpb25SZXNwb25zZX0gdHVwbGUgb2YgYSB7QGxpbmsgVXNlTXV0YXRpb25TdGF0ZX0gcmVzdWx0LFxuICogYW5kIGFuIGV4ZWN1dGUgZnVuY3Rpb24gdG8gc3RhcnQgdGhlIG11dGF0aW9uLlxuICpcbiAqIEByZW1hcmtzXG4gKiBgdXNlTXV0YXRpb25gIGFsbG93cyBHcmFwaFFMIG11dGF0aW9ucyB0byBiZSBkZWZpbmVkIGFuZCBrZWVwcyBpdHMgc3RhdGVcbiAqIGFmdGVyIHRoZSBtdXRhdGlvbiBpcyBzdGFydGVkIHdpdGggdGhlIHJldHVybmVkIGV4ZWN1dGUgZnVuY3Rpb24uXG4gKlxuICogR2l2ZW4gYSBHcmFwaFFMIG11dGF0aW9uIGRvY3VtZW50IGl0IHJldHVybnMgc3RhdGUgdG8ga2VlcCB0cmFjayBvZiB0aGVcbiAqIG11dGF0aW9uIHN0YXRlIGFuZCBhIHtAbGluayBVc2VNdXRhdGlvbkV4ZWN1dGV9IGZ1bmN0aW9uLCB3aGljaCBhY2NlcHRzXG4gKiB2YXJpYWJsZXMgZm9yIHRoZSBtdXRhdGlvbiB0byBiZSBleGVjdXRlZC5cbiAqIE9uY2UgY2FsbGVkLCB0aGUgbXV0YXRpb24gZXhlY3V0ZXMgYW5kIHRoZSBzdGF0ZSB3aWxsIGJlIHVwZGF0ZWQgd2l0aFxuICogdGhlIG11dGF0aW9u4oCZcyByZXN1bHQuXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly91cnFsLmRldi9nb3RvL3VycWwvZG9jcy9iYXNpY3MvcmVhY3QtcHJlYWN0LyNtdXRhdGlvbnN9IGZvciBgdXNlTXV0YXRpb25gIGRvY3MuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBncWwsIHVzZU11dGF0aW9uIH0gZnJvbSAndXJxbCc7XG4gKlxuICogY29uc3QgVXBkYXRlVG9kbyA9IGdxbGBcbiAqICAgbXV0YXRpb24gKCRpZDogSUQhLCAkdGl0bGU6IFN0cmluZyEpIHtcbiAqICAgICB1cGRhdGVUb2RvKGlkOiAkaWQsIHRpdGxlOiAkdGl0bGUpIHtcbiAqICAgICAgIGlkLCB0aXRsZVxuICogICAgIH1cbiAqICAgfVxuICogYDtcbiAqXG4gKiBjb25zdCBVcGRhdGVUb2RvID0gKCkgPT4ge1xuICogICBjb25zdCBbcmVzdWx0LCBleGVjdXRlTXV0YXRpb25dID0gdXNlTXV0YXRpb24oVXBkYXRlVG9kbyk7XG4gKiAgIGNvbnN0IHN0YXJ0ID0gYXN5bmMgKHsgaWQsIHRpdGxlIH0pID0+IHtcbiAqICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBleGVjdXRlTXV0YXRpb24oeyBpZCwgdGl0bGUgfSk7XG4gKiAgIH07XG4gKiAgIC8vIC4uLlxuICogfTtcbiAqIGBgYFxuICovXG5mdW5jdGlvbiB1c2VNdXRhdGlvbihxdWVyeSkge1xuICB2YXIgaXNNb3VudGVkID0gUmVhY3QudXNlUmVmKHRydWUpO1xuICB2YXIgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIHZhciBbc3RhdGUsIHNldFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gIHZhciBleGVjdXRlTXV0YXRpb24gPSBSZWFjdC51c2VDYWxsYmFjaygodmFyaWFibGVzLCBjb250ZXh0KSA9PiB7XG4gICAgZGVmZXJEaXNwYXRjaChzZXRTdGF0ZSwge1xuICAgICAgLi4uaW5pdGlhbFN0YXRlLFxuICAgICAgZmV0Y2hpbmc6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gd29ua2EudG9Qcm9taXNlKHdvbmthLnRha2UoMSkod29ua2EuZmlsdGVyKHJlc3VsdCA9PiAhcmVzdWx0Lmhhc05leHQpKHdvbmthLm9uUHVzaChyZXN1bHQgPT4ge1xuICAgICAgaWYgKGlzTW91bnRlZC5jdXJyZW50KSB7XG4gICAgICAgIGRlZmVyRGlzcGF0Y2goc2V0U3RhdGUsIHtcbiAgICAgICAgICBmZXRjaGluZzogZmFsc2UsXG4gICAgICAgICAgc3RhbGU6IHJlc3VsdC5zdGFsZSxcbiAgICAgICAgICBkYXRhOiByZXN1bHQuZGF0YSxcbiAgICAgICAgICBlcnJvcjogcmVzdWx0LmVycm9yLFxuICAgICAgICAgIGV4dGVuc2lvbnM6IHJlc3VsdC5leHRlbnNpb25zLFxuICAgICAgICAgIG9wZXJhdGlvbjogcmVzdWx0Lm9wZXJhdGlvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KShjbGllbnQuZXhlY3V0ZU11dGF0aW9uKGNvcmUuY3JlYXRlUmVxdWVzdChxdWVyeSwgdmFyaWFibGVzKSwgY29udGV4dCB8fCB7fSkpKSkpO1xuICB9LFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFtjbGllbnQsIHF1ZXJ5LCBzZXRTdGF0ZV0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlzTW91bnRlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaXNNb3VudGVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIHJldHVybiBbc3RhdGUsIGV4ZWN1dGVNdXRhdGlvbl07XG59XG5cbi8qKiBDcmVhdGVzIGEgcmVxdWVzdCBmcm9tIGEgcXVlcnkgYW5kIHZhcmlhYmxlcyBidXQgcHJlc2VydmVzIHJlZmVyZW5jZSBlcXVhbGl0eSBpZiB0aGUga2V5IGlzbid0IGNoYW5naW5nXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdXNlUmVxdWVzdChxdWVyeSwgdmFyaWFibGVzKSB7XG4gIHZhciBwcmV2ID0gUmVhY3QudXNlUmVmKHVuZGVmaW5lZCk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICB2YXIgcmVxdWVzdCA9IGNvcmUuY3JlYXRlUmVxdWVzdChxdWVyeSwgdmFyaWFibGVzKTtcbiAgICAvLyBXZSBtYW51YWxseSBlbnN1cmUgcmVmZXJlbmNlIGVxdWFsaXR5IGlmIHRoZSBrZXkgaGFzbid0IGNoYW5nZWRcbiAgICBpZiAocHJldi5jdXJyZW50ICE9PSB1bmRlZmluZWQgJiYgcHJldi5jdXJyZW50LmtleSA9PT0gcmVxdWVzdC5rZXkpIHtcbiAgICAgIHJldHVybiBwcmV2LmN1cnJlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZXYuY3VycmVudCA9IHJlcXVlc3Q7XG4gICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9XG4gIH0sIFtxdWVyeSwgdmFyaWFibGVzXSk7XG59XG5cbnZhciBnZXRDYWNoZUZvckNsaWVudCA9IGNsaWVudCA9PiB7XG4gIGlmICghY2xpZW50Ll9yZWFjdCkge1xuICAgIHZhciByZWNsYWltID0gbmV3IFNldCgpO1xuICAgIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gICAgaWYgKGNsaWVudC5vcGVyYXRpb25zJCAvKiBub3QgYXZhaWxhYmxlIGluIG1vY2tzICovKSB7XG4gICAgICB3b25rYS5zdWJzY3JpYmUob3BlcmF0aW9uID0+IHtcbiAgICAgICAgaWYgKG9wZXJhdGlvbi5raW5kID09PSAndGVhcmRvd24nICYmIHJlY2xhaW0uaGFzKG9wZXJhdGlvbi5rZXkpKSB7XG4gICAgICAgICAgcmVjbGFpbS5kZWxldGUob3BlcmF0aW9uLmtleSk7XG4gICAgICAgICAgbWFwLmRlbGV0ZShvcGVyYXRpb24ua2V5KTtcbiAgICAgICAgfVxuICAgICAgfSkoY2xpZW50Lm9wZXJhdGlvbnMkKTtcbiAgICB9XG4gICAgY2xpZW50Ll9yZWFjdCA9IHtcbiAgICAgIGdldChrZXkpIHtcbiAgICAgICAgcmV0dXJuIG1hcC5nZXQoa2V5KTtcbiAgICAgIH0sXG4gICAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICByZWNsYWltLmRlbGV0ZShrZXkpO1xuICAgICAgICBtYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgfSxcbiAgICAgIGRpc3Bvc2Uoa2V5KSB7XG4gICAgICAgIHJlY2xhaW0uYWRkKGtleSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4gY2xpZW50Ll9yZWFjdDtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwcyAqL1xuXG4vKiogSW5wdXQgYXJndW1lbnRzIGZvciB0aGUge0BsaW5rIHVzZVF1ZXJ5fSBob29rLlxuICpcbiAqIEBwYXJhbSBxdWVyeSAtIFRoZSBHcmFwaFFMIHF1ZXJ5IHRoYXQgYHVzZVF1ZXJ5YCBleGVjdXRlcy5cbiAqIEBwYXJhbSB2YXJpYWJsZXMgLSBUaGUgdmFyaWFibGVzIGZvciB0aGUgR3JhcGhRTCBxdWVyeSB0aGF0IGB1c2VRdWVyeWAgZXhlY3V0ZXMuXG4gKi9cblxuLyoqIFN0YXRlIG9mIHRoZSBjdXJyZW50IHF1ZXJ5LCB5b3VyIHtAbGluayB1c2VRdWVyeX0gaG9vayBpcyBleGVjdXRpbmcuXG4gKlxuICogQHJlbWFya3NcbiAqIGBVc2VRdWVyeVN0YXRlYCBpcyByZXR1cm5lZCAoaW4gYSB0dXBsZSkgYnkge0BsaW5rIHVzZVF1ZXJ5fSBhbmRcbiAqIGdpdmVzIHlvdSB0aGUgdXBkYXRpbmcge0BsaW5rIE9wZXJhdGlvblJlc3VsdH0gb2YgR3JhcGhRTCBxdWVyaWVzLlxuICpcbiAqIEV2ZW4gd2hlbiB0aGUgcXVlcnkgYW5kIHZhcmlhYmxlcyBwYXNzZWQgdG8ge0BsaW5rIHVzZVF1ZXJ5fSBjaGFuZ2UsXG4gKiB0aGlzIHN0YXRlIHByZXNlcnZlcyB0aGUgcHJpb3Igc3RhdGUgYW5kIHNldHMgdGhlIGBmZXRjaGluZ2AgZmxhZyB0b1xuICogYHRydWVgLlxuICogVGhpcyBhbGxvd3MgeW91IHRvIGRpc3BsYXkgdGhlIHByZXZpb3VzIHN0YXRlLCB3aGlsZSBpbXBsZW1lbnRpbmdcbiAqIGEgc2VwYXJhdGUgbG9hZGluZyBpbmRpY2F0b3Igc2VwYXJhdGVseS5cbiAqL1xuXG4vKiogVHJpZ2dlcnMge0BsaW5rIHVzZVF1ZXJ5fSB0byBleGVjdXRlIGEgbmV3IEdyYXBoUUwgcXVlcnkgb3BlcmF0aW9uLlxuICpcbiAqIEBwYXJhbSBvcHRzIC0gb3B0aW9uYWxseSwgY29udGV4dCBvcHRpb25zIHRoYXQgd2lsbCBiZSBtZXJnZWQgd2l0aCB0aGUgaG9vaydzXG4gKiB7QGxpbmsgVXNlUXVlcnlBcmdzLmNvbnRleHR9IG9wdGlvbnMgYW5kIHRoZSBgQ2xpZW50YOKAmXMgb3B0aW9ucy5cbiAqXG4gKiBAcmVtYXJrc1xuICogV2hlbiBjYWxsZWQsIHtAbGluayB1c2VRdWVyeX0gd2lsbCByZS1leGVjdXRlIHRoZSBHcmFwaFFMIHF1ZXJ5IG9wZXJhdGlvblxuICogaXQgY3VycmVudGx5IGhvbGRzLCBldmVuIGlmIHtAbGluayBVc2VRdWVyeUFyZ3MucGF1c2V9IGlzIHNldCB0byBgdHJ1ZWAuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIGV4ZWN1dGluZyBhIHBhdXNlZCBxdWVyeSBvciByZS1leGVjdXRpbmcgYSBxdWVyeVxuICogYW5kIGdldCBhIG5ldyBuZXR3b3JrIHJlc3VsdCwgYnkgcGFzc2luZyBhIG5ldyByZXF1ZXN0IHBvbGljeS5cbiAqXG4gKiBgYGB0c1xuICogY29uc3QgW3Jlc3VsdCwgcmVleGVjdXRlUXVlcnldID0gdXNlUXVlcnkoeyBxdWVyeSB9KTtcbiAqXG4gKiBjb25zdCByZWZyZXNoID0gKCkgPT4ge1xuICogICAvLyBSZS1leGVjdXRlIHRoZSBxdWVyeSB3aXRoIGEgbmV0d29yay1vbmx5IHBvbGljeSwgc2tpcHBpbmcgdGhlIGNhY2hlXG4gKiAgIHJlZXhlY3V0ZVF1ZXJ5KHsgcmVxdWVzdFBvbGljeTogJ25ldHdvcmstb25seScgfSk7XG4gKiB9O1xuICogYGBgXG4gKi9cblxuLyoqIFJlc3VsdCB0dXBsZSByZXR1cm5lZCBieSB0aGUge0BsaW5rIHVzZVF1ZXJ5fSBob29rLlxuICpcbiAqIEByZW1hcmtzXG4gKiBTaW1pbGFybHkgdG8gYSBgdXNlU3RhdGVgIGhvb2vigJlzIHJldHVybiB2YWx1ZSxcbiAqIHRoZSBmaXJzdCBlbGVtZW50IGlzIHRoZSB7QGxpbmsgdXNlUXVlcnl94oCZcyByZXN1bHQgYW5kIHN0YXRlLFxuICogYSB7QGxpbmsgVXNlUXVlcnlTdGF0ZX0gb2JqZWN0LFxuICogYW5kIHRoZSBzZWNvbmQgaXMgdXNlZCB0byBpbXBlcmF0aXZlbHkgcmUtZXhlY3V0ZSB0aGUgcXVlcnlcbiAqIHZpYSBhIHtAbGluayBVc2VRdWVyeUV4ZWN1dGV9IGZ1bmN0aW9uLlxuICovXG5cbnZhciBpc1N1c3BlbnNlID0gKGNsaWVudCwgY29udGV4dCkgPT4gY2xpZW50LnN1c3BlbnNlICYmICghY29udGV4dCB8fCBjb250ZXh0LnN1c3BlbnNlICE9PSBmYWxzZSk7XG5cbi8qKiBIb29rIHRvIHJ1biBhIEdyYXBoUUwgcXVlcnkgYW5kIGdldCB1cGRhdGVkIEdyYXBoUUwgcmVzdWx0cy5cbiAqXG4gKiBAcGFyYW0gYXJncyAtIGEge0BsaW5rIFVzZVF1ZXJ5QXJnc30gb2JqZWN0LCB0byBwYXNzIGEgYHF1ZXJ5YCwgYHZhcmlhYmxlc2AsIGFuZCBvcHRpb25zLlxuICogQHJldHVybnMgYSB7QGxpbmsgVXNlUXVlcnlSZXNwb25zZX0gdHVwbGUgb2YgYSB7QGxpbmsgVXNlUXVlcnlTdGF0ZX0gcmVzdWx0LCBhbmQgcmUtZXhlY3V0ZSBmdW5jdGlvbi5cbiAqXG4gKiBAcmVtYXJrc1xuICogYHVzZVF1ZXJ5YCBhbGxvd3MgR3JhcGhRTCBxdWVyaWVzIHRvIGJlIGRlZmluZWQgYW5kIGV4ZWN1dGVkLlxuICogR2l2ZW4ge0BsaW5rIFVzZVF1ZXJ5QXJncy5xdWVyeX0sIGl0IGV4ZWN1dGVzIHRoZSBHcmFwaFFMIHF1ZXJ5IHdpdGggdGhlXG4gKiBjb250ZXh04oCZcyB7QGxpbmsgQ2xpZW50fS5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgcmVzdWx0IHVwZGF0ZXMgd2hlbiB0aGUgYENsaWVudGAgaGFzIG5ldyByZXN1bHRzXG4gKiBmb3IgdGhlIHF1ZXJ5LCBhbmQgY2hhbmdlcyB3aGVuIHlvdXIgaW5wdXQgYGFyZ3NgIGNoYW5nZS5cbiAqXG4gKiBBZGRpdGlvbmFsbHksIGlmIHRoZSBgc3VzcGVuc2VgIG9wdGlvbiBpcyBlbmFibGVkIG9uIHRoZSBgQ2xpZW50YCxcbiAqIHRoZSBgdXNlUXVlcnlgIGhvb2sgd2lsbCBzdXNwZW5kIGluc3RlYWQgb2YgaW5kaWNhdGluZyB0aGF0IGl04oCZc1xuICogd2FpdGluZyBmb3IgYSByZXN1bHQgdmlhIHtAbGluayBVc2VRdWVyeVN0YXRlLmZldGNoaW5nfS5cbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL3VycWwuZGV2L2dvdG8vdXJxbC9kb2NzL2Jhc2ljcy9yZWFjdC1wcmVhY3QvI3F1ZXJpZXN9IGZvciBgdXNlUXVlcnlgIGRvY3MuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBncWwsIHVzZVF1ZXJ5IH0gZnJvbSAndXJxbCc7XG4gKlxuICogY29uc3QgVG9kb3NRdWVyeSA9IGdxbGBcbiAqICAgcXVlcnkgeyB0b2RvcyB7IGlkLCB0aXRsZSB9IH1cbiAqIGA7XG4gKlxuICogY29uc3QgVG9kb3MgPSAoKSA9PiB7XG4gKiAgIGNvbnN0IFtyZXN1bHQsIHJlZXhlY3V0ZVF1ZXJ5XSA9IHVzZVF1ZXJ5KHtcbiAqICAgICBxdWVyeTogVG9kb3NRdWVyeSxcbiAqICAgICB2YXJpYWJsZXM6IHt9LFxuICogICB9KTtcbiAqICAgLy8gLi4uXG4gKiB9O1xuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHVzZVF1ZXJ5KGFyZ3MpIHtcbiAgdmFyIGNsaWVudCA9IHVzZUNsaWVudCgpO1xuICB2YXIgY2FjaGUgPSBnZXRDYWNoZUZvckNsaWVudChjbGllbnQpO1xuICB2YXIgc3VzcGVuc2UgPSBpc1N1c3BlbnNlKGNsaWVudCwgYXJncy5jb250ZXh0KTtcbiAgdmFyIHJlcXVlc3QgPSB1c2VSZXF1ZXN0KGFyZ3MucXVlcnksIGFyZ3MudmFyaWFibGVzKTtcbiAgdmFyIHNvdXJjZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmIChhcmdzLnBhdXNlKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgc291cmNlID0gY2xpZW50LmV4ZWN1dGVRdWVyeShyZXF1ZXN0LCB7XG4gICAgICByZXF1ZXN0UG9saWN5OiBhcmdzLnJlcXVlc3RQb2xpY3ksXG4gICAgICAuLi5hcmdzLmNvbnRleHRcbiAgICB9KTtcbiAgICByZXR1cm4gc3VzcGVuc2UgPyB3b25rYS5vblB1c2gocmVzdWx0ID0+IHtcbiAgICAgIGNhY2hlLnNldChyZXF1ZXN0LmtleSwgcmVzdWx0KTtcbiAgICB9KShzb3VyY2UpIDogc291cmNlO1xuICB9LCBbY2FjaGUsIGNsaWVudCwgcmVxdWVzdCwgc3VzcGVuc2UsIGFyZ3MucGF1c2UsIGFyZ3MucmVxdWVzdFBvbGljeSwgYXJncy5jb250ZXh0XSk7XG4gIHZhciBnZXRTbmFwc2hvdCA9IFJlYWN0LnVzZUNhbGxiYWNrKChzb3VyY2UsIHN1c3BlbnNlKSA9PiB7XG4gICAgaWYgKCFzb3VyY2UpIHJldHVybiB7XG4gICAgICBmZXRjaGluZzogZmFsc2VcbiAgICB9O1xuICAgIHZhciByZXN1bHQgPSBjYWNoZS5nZXQocmVxdWVzdC5rZXkpO1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICB2YXIgcmVzb2x2ZTtcbiAgICAgIHZhciBzdWJzY3JpcHRpb24gPSB3b25rYS5zdWJzY3JpYmUoX3Jlc3VsdCA9PiB7XG4gICAgICAgIHJlc3VsdCA9IF9yZXN1bHQ7XG4gICAgICAgIGlmIChyZXNvbHZlKSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9KSh3b25rYS50YWtlV2hpbGUoKCkgPT4gc3VzcGVuc2UgJiYgIXJlc29sdmUgfHwgIXJlc3VsdCkoc291cmNlKSk7XG4gICAgICBpZiAocmVzdWx0ID09IG51bGwgJiYgc3VzcGVuc2UpIHtcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShfcmVzb2x2ZSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZSA9IF9yZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICAgICAgY2FjaGUuc2V0KHJlcXVlc3Qua2V5LCBwcm9taXNlKTtcbiAgICAgICAgdGhyb3cgcHJvbWlzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3VzcGVuc2UgJiYgcmVzdWx0ICE9IG51bGwgJiYgJ3RoZW4nIGluIHJlc3VsdCkge1xuICAgICAgdGhyb3cgcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0IHx8IHtcbiAgICAgIGZldGNoaW5nOiB0cnVlXG4gICAgfTtcbiAgfSwgW2NhY2hlLCByZXF1ZXN0XSk7XG4gIHZhciBkZXBzID0gW2NsaWVudCwgcmVxdWVzdCwgYXJncy5yZXF1ZXN0UG9saWN5LCBhcmdzLmNvbnRleHQsIGFyZ3MucGF1c2VdO1xuICB2YXIgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBbc291cmNlLCBjb21wdXRlTmV4dFN0YXRlKGluaXRpYWxTdGF0ZSwgZ2V0U25hcHNob3Qoc291cmNlLCBzdXNwZW5zZSkpLCBkZXBzXSk7XG4gIHZhciBjdXJyZW50UmVzdWx0ID0gc3RhdGVbMV07XG4gIGlmIChzb3VyY2UgIT09IHN0YXRlWzBdICYmIGhhc0RlcHNDaGFuZ2VkKHN0YXRlWzJdLCBkZXBzKSkge1xuICAgIHNldFN0YXRlKFtzb3VyY2UsIGN1cnJlbnRSZXN1bHQgPSBjb21wdXRlTmV4dFN0YXRlKHN0YXRlWzFdLCBnZXRTbmFwc2hvdChzb3VyY2UsIHN1c3BlbnNlKSksIGRlcHNdKTtcbiAgfVxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHZhciBzb3VyY2UgPSBzdGF0ZVswXTtcbiAgICB2YXIgcmVxdWVzdCA9IHN0YXRlWzJdWzFdO1xuICAgIHZhciBoYXNSZXN1bHQgPSBmYWxzZTtcbiAgICB2YXIgdXBkYXRlUmVzdWx0ID0gcmVzdWx0ID0+IHtcbiAgICAgIGhhc1Jlc3VsdCA9IHRydWU7XG4gICAgICBkZWZlckRpc3BhdGNoKHNldFN0YXRlLCBzdGF0ZSA9PiB7XG4gICAgICAgIHZhciBuZXh0UmVzdWx0ID0gY29tcHV0ZU5leHRTdGF0ZShzdGF0ZVsxXSwgcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHN0YXRlWzFdICE9PSBuZXh0UmVzdWx0ID8gW3N0YXRlWzBdLCBuZXh0UmVzdWx0LCBzdGF0ZVsyXV0gOiBzdGF0ZTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHdvbmthLnN1YnNjcmliZSh1cGRhdGVSZXN1bHQpKHdvbmthLm9uRW5kKCgpID0+IHtcbiAgICAgICAgdXBkYXRlUmVzdWx0KHtcbiAgICAgICAgICBmZXRjaGluZzogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9KShzb3VyY2UpKTtcbiAgICAgIGlmICghaGFzUmVzdWx0KSB1cGRhdGVSZXN1bHQoe1xuICAgICAgICBmZXRjaGluZzogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjYWNoZS5kaXNwb3NlKHJlcXVlc3Qua2V5KTtcbiAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGVSZXN1bHQoe1xuICAgICAgICBmZXRjaGluZzogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2NhY2hlLCBzdGF0ZVswXSwgc3RhdGVbMl1bMV1dKTtcbiAgdmFyIGV4ZWN1dGVRdWVyeSA9IFJlYWN0LnVzZUNhbGxiYWNrKG9wdHMgPT4ge1xuICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgcmVxdWVzdFBvbGljeTogYXJncy5yZXF1ZXN0UG9saWN5LFxuICAgICAgLi4uYXJncy5jb250ZXh0LFxuICAgICAgLi4ub3B0c1xuICAgIH07XG4gICAgZGVmZXJEaXNwYXRjaChzZXRTdGF0ZSwgc3RhdGUgPT4ge1xuICAgICAgdmFyIHNvdXJjZSA9IHN1c3BlbnNlID8gd29ua2Eub25QdXNoKHJlc3VsdCA9PiB7XG4gICAgICAgIGNhY2hlLnNldChyZXF1ZXN0LmtleSwgcmVzdWx0KTtcbiAgICAgIH0pKGNsaWVudC5leGVjdXRlUXVlcnkocmVxdWVzdCwgY29udGV4dCkpIDogY2xpZW50LmV4ZWN1dGVRdWVyeShyZXF1ZXN0LCBjb250ZXh0KTtcbiAgICAgIHJldHVybiBbc291cmNlLCBzdGF0ZVsxXSwgZGVwc107XG4gICAgfSk7XG4gIH0sIFtjbGllbnQsIGNhY2hlLCByZXF1ZXN0LCBzdXNwZW5zZSwgZ2V0U25hcHNob3QsIGFyZ3MucmVxdWVzdFBvbGljeSwgYXJncy5jb250ZXh0XSk7XG4gIHJldHVybiBbY3VycmVudFJlc3VsdCwgZXhlY3V0ZVF1ZXJ5XTtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzICovXG5cbi8qKiBJbnB1dCBhcmd1bWVudHMgZm9yIHRoZSB7QGxpbmsgdXNlU3Vic2NyaXB0aW9ufSBob29rLlxuICpcbiAqIEBwYXJhbSBxdWVyeSAtIFRoZSBHcmFwaFFMIHN1YnNjcmlwdGlvbiBkb2N1bWVudCB0aGF0IGB1c2VTdWJzY3JpcHRpb25gIGV4ZWN1dGVzLlxuICogQHBhcmFtIHZhcmlhYmxlcyAtIFRoZSB2YXJpYWJsZXMgZm9yIHRoZSBHcmFwaFFMIHN1YnNjcmlwdGlvbiB0aGF0IGB1c2VTdWJzY3JpcHRpb25gIGV4ZWN1dGVzLlxuICovXG5cbi8qKiBDb21iaW5lcyBwcmV2aW91cyBkYXRhIHdpdGggYW4gaW5jb21pbmcgc3Vic2NyaXB0aW9uIHJlc3VsdOKAmXMgZGF0YS5cbiAqXG4gKiBAcmVtYXJrc1xuICogQSBgU3Vic2NyaXB0aW9uSGFuZGxlcmAgbWF5IGJlIHBhc3NlZCB0byB7QGxpbmsgdXNlU3Vic2NyaXB0aW9ufSB0b1xuICogYWdncmVnYXRlIHN1YnNjcmlwdGlvbiByZXN1bHRzIGludG8gYSBjb21iaW5lZCB7QGxpbmsgVXNlU3Vic2NyaXB0aW9uU3RhdGUuZGF0YX1cbiAqIHZhbHVlLlxuICpcbiAqIFRoaXMgaXMgdXNlZnVsIHdoZW4gYSBzdWJzY3JpcHRpb24gZXZlbnQgZGVsaXZlcnMgYSBzaW5nbGUgaXRlbSwgd2hpbGVcbiAqIHlvdeKAmWQgbGlrZSB0byBkaXNwbGF5IGEgbGlzdCBvZiBldmVudHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBOb3RpZmljYXRpb25zU3Vic2NyaXB0aW9uID0gZ3FsYFxuICogICBzdWJzY3JpcHRpb24geyBuZXdOb3RpZmljYXRpb24geyBpZCwgdGV4dCB9IH1cbiAqIGA7XG4gKlxuICogY29uc3QgY29tYmluZU5vdGlmaWNhdGlvbnMgPSAobm90aWZpY2F0aW9ucyA9IFtdLCBkYXRhKSA9PiB7XG4gKiAgIHJldHVybiBbLi4ubm90aWZpY2F0aW9ucywgZGF0YS5uZXdOb3RpZmljYXRpb25dO1xuICogfTtcbiAqXG4gKiBjb25zdCBbcmVzdWx0LCBleGVjdXRlU3Vic2NyaXB0aW9uXSA9IHVzZVN1YnNjcmlwdGlvbihcbiAqICAgeyBxdWVyeTogTm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbiB9LFxuICogICBjb21iaW5lTm90aWZpY2F0aW9ucyxcbiAqICk7XG4gKiBgYGBcbiAqL1xuXG4vKiogU3RhdGUgb2YgdGhlIGN1cnJlbnQgc3Vic2NyaXB0aW9uLCB5b3VyIHtAbGluayB1c2VTdWJzY3JpcHRpb259IGhvb2sgaXMgZXhlY3V0aW5nLlxuICpcbiAqIEByZW1hcmtzXG4gKiBgVXNlU3Vic2NyaXB0aW9uU3RhdGVgIGlzIHJldHVybmVkIChpbiBhIHR1cGxlKSBieSB7QGxpbmsgdXNlU3Vic2NyaXB0aW9ufSBhbmRcbiAqIGdpdmVzIHlvdSB0aGUgdXBkYXRpbmcge0BsaW5rIE9wZXJhdGlvblJlc3VsdH0gb2YgR3JhcGhRTCBzdWJzY3JpcHRpb25zLlxuICpcbiAqIElmIGEge0BsaW5rIFN1YnNjcmlwdGlvbkhhbmRsZXJ9IGhhcyBiZWVuIHBhc3NlZCB0byBgdXNlU3Vic2NyaXB0aW9uYCB0aGVuXG4gKiB7QGxpbmsgVXNlU3Vic2NyaXB0aW9uU3RhdGUuZGF0YX0gaXMgaW5zdGVhZCB0aGUgdXBkYXRlZCBkYXRhIGFzIHJldHVybmVkXG4gKiBieSB0aGUgaGFuZGxlciwgb3RoZXJ3aXNlIGl04oCZcyB0aGUgbGF0ZXN0IHJlc3VsdOKAmXMgZGF0YS5cbiAqXG4gKiBIaW50OiBFdmVuIHdoZW4gdGhlIHF1ZXJ5IGFuZCB2YXJpYWJsZXMgcGFzc2VkIHRvIHtAbGluayB1c2VTdWJzY3JpcHRpb259IGNoYW5nZSxcbiAqIHRoaXMgc3RhdGUgcHJlc2VydmVzIHRoZSBwcmlvciBzdGF0ZS5cbiAqL1xuXG4vKiogVHJpZ2dlcnMge0BsaW5rIHVzZVN1YnNjcmlwdGlvbn0gdG8gcmVleGVjdXRlIGEgR3JhcGhRTCBzdWJzY3JpcHRpb24gb3BlcmF0aW9uLlxuICpcbiAqIEBwYXJhbSBvcHRzIC0gb3B0aW9uYWxseSwgY29udGV4dCBvcHRpb25zIHRoYXQgd2lsbCBiZSBtZXJnZWQgd2l0aCB0aGUgaG9vaydzXG4gKiB7QGxpbmsgVXNlU3Vic2NyaXB0aW9uQXJncy5jb250ZXh0fSBvcHRpb25zIGFuZCB0aGUgYENsaWVudGDigJlzIG9wdGlvbnMuXG4gKlxuICogQHJlbWFya3NcbiAqIFdoZW4gY2FsbGVkLCB7QGxpbmsgdXNlU3Vic2NyaXB0aW9ufSB3aWxsIHJlc3RhcnQgdGhlIEdyYXBoUUwgc3Vic2NyaXB0aW9uXG4gKiBvcGVyYXRpb24gaXQgY3VycmVudGx5IGhvbGRzLiBJZiB7QGxpbmsgVXNlU3Vic2NyaXB0aW9uQXJncy5wYXVzZX0gaXMgc2V0XG4gKiB0byBgdHJ1ZWAsIGl0IHdpbGwgc3RhcnQgZXhlY3V0aW5nIHRoZSBzdWJzY3JpcHRpb24uXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IFtyZXN1bHQsIGV4ZWN1dGVTdWJzY3JpcHRpb25dID0gdXNlU3Vic2NyaXB0aW9uKHtcbiAqICAgcXVlcnksXG4gKiAgIHBhdXNlOiB0cnVlLFxuICogfSk7XG4gKlxuICogY29uc3Qgc3RhcnQgPSAoKSA9PiB7XG4gKiAgIGV4ZWN1dGVTdWJzY3JpcHRpb24oKTtcbiAqIH07XG4gKiBgYGBcbiAqL1xuXG4vKiogUmVzdWx0IHR1cGxlIHJldHVybmVkIGJ5IHRoZSB7QGxpbmsgdXNlU3Vic2NyaXB0aW9ufSBob29rLlxuICpcbiAqIEByZW1hcmtzXG4gKiBTaW1pbGFybHkgdG8gYSBgdXNlU3RhdGVgIGhvb2vigJlzIHJldHVybiB2YWx1ZSxcbiAqIHRoZSBmaXJzdCBlbGVtZW50IGlzIHRoZSB7QGxpbmsgdXNlU3Vic2NyaXB0aW9ufeKAmXMgc3RhdGUsXG4gKiBhIHtAbGluayBVc2VTdWJzY3JpcHRpb25TdGF0ZX0gb2JqZWN0LFxuICogYW5kIHRoZSBzZWNvbmQgaXMgdXNlZCB0byBpbXBlcmF0aXZlbHkgcmUtZXhlY3V0ZSBvciBzdGFydCB0aGUgc3Vic2NyaXB0aW9uXG4gKiB2aWEgYSB7QGxpbmsgVXNlTXV0YXRpb25FeGVjdXRlfSBmdW5jdGlvbi5cbiAqL1xuXG4vKiogSG9vayB0byBydW4gYSBHcmFwaFFMIHN1YnNjcmlwdGlvbiBhbmQgZ2V0IHVwZGF0ZWQgR3JhcGhRTCByZXN1bHRzLlxuICpcbiAqIEBwYXJhbSBhcmdzIC0gYSB7QGxpbmsgVXNlU3Vic2NyaXB0aW9uQXJnc30gb2JqZWN0LCB0byBwYXNzIGEgYHF1ZXJ5YCwgYHZhcmlhYmxlc2AsIGFuZCBvcHRpb25zLlxuICogQHBhcmFtIGhhbmRsZXIgLSBvcHRpb25hbGx5LCBhIHtAbGluayBTdWJzY3JpcHRpb25IYW5kbGVyfSBmdW5jdGlvbiB0byBjb21iaW5lIG11bHRpcGxlIHN1YnNjcmlwdGlvbiByZXN1bHRzLlxuICogQHJldHVybnMgYSB7QGxpbmsgVXNlU3Vic2NyaXB0aW9uUmVzcG9uc2V9IHR1cGxlIG9mIGEge0BsaW5rIFVzZVN1YnNjcmlwdGlvblN0YXRlfSByZXN1bHQsIGFuZCBhbiBleGVjdXRlIGZ1bmN0aW9uLlxuICpcbiAqIEByZW1hcmtzXG4gKiBgdXNlU3Vic2NyaXB0aW9uYCBhbGxvd3MgR3JhcGhRTCBzdWJzY3JpcHRpb25zIHRvIGJlIGRlZmluZWQgYW5kIGV4ZWN1dGVkLlxuICogR2l2ZW4ge0BsaW5rIFVzZVN1YnNjcmlwdGlvbkFyZ3MucXVlcnl9LCBpdCBleGVjdXRlcyB0aGUgR3JhcGhRTCBzdWJzY3JpcHRpb24gd2l0aCB0aGVcbiAqIGNvbnRleHTigJlzIHtAbGluayBDbGllbnR9LlxuICpcbiAqIFRoZSByZXR1cm5lZCByZXN1bHQgdXBkYXRlcyB3aGVuIHRoZSBgQ2xpZW50YCBoYXMgbmV3IHJlc3VsdHNcbiAqIGZvciB0aGUgc3Vic2NyaXB0aW9uLCBhbmQgYGRhdGFgIGlzIHVwZGF0ZWQgd2l0aCB0aGUgcmVzdWx04oCZcyBkYXRhXG4gKiBvciB3aXRoIHRoZSBgZGF0YWAgdGhhdCBhIGBoYW5kbGVyYCByZXR1cm5zLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZ3FsLCB1c2VTdWJzY3JpcHRpb24gfSBmcm9tICd1cnFsJztcbiAqXG4gKiBjb25zdCBOb3RpZmljYXRpb25zU3Vic2NyaXB0aW9uID0gZ3FsYFxuICogICBzdWJzY3JpcHRpb24geyBuZXdOb3RpZmljYXRpb24geyBpZCwgdGV4dCB9IH1cbiAqIGA7XG4gKlxuICogY29uc3QgY29tYmluZU5vdGlmaWNhdGlvbnMgPSAobm90aWZpY2F0aW9ucyA9IFtdLCBkYXRhKSA9PiB7XG4gKiAgIHJldHVybiBbLi4ubm90aWZpY2F0aW9ucywgZGF0YS5uZXdOb3RpZmljYXRpb25dO1xuICogfTtcbiAqXG4gKiBjb25zdCBOb3RpZmljYXRpb25zID0gKCkgPT4ge1xuICogICBjb25zdCBbcmVzdWx0LCBleGVjdXRlU3Vic2NyaXB0aW9uXSA9IHVzZVN1YnNjcmlwdGlvbihcbiAqICAgICB7IHF1ZXJ5OiBOb3RpZmljYXRpb25zU3Vic2NyaXB0aW9uIH0sXG4gKiAgICAgY29tYmluZU5vdGlmaWNhdGlvbnMsXG4gKiAgICk7XG4gKiAgIC8vIC4uLlxuICogfTtcbiAqIGBgYFxuICovXG5mdW5jdGlvbiB1c2VTdWJzY3JpcHRpb24oYXJncywgaGFuZGxlcikge1xuICB2YXIgY2xpZW50ID0gdXNlQ2xpZW50KCk7XG4gIHZhciByZXF1ZXN0ID0gdXNlUmVxdWVzdChhcmdzLnF1ZXJ5LCBhcmdzLnZhcmlhYmxlcyk7XG4gIHZhciBoYW5kbGVyUmVmID0gUmVhY3QudXNlUmVmKGhhbmRsZXIpO1xuICBoYW5kbGVyUmVmLmN1cnJlbnQgPSBoYW5kbGVyO1xuICB2YXIgc291cmNlID0gUmVhY3QudXNlTWVtbygoKSA9PiAhYXJncy5wYXVzZSA/IGNsaWVudC5leGVjdXRlU3Vic2NyaXB0aW9uKHJlcXVlc3QsIGFyZ3MuY29udGV4dCkgOiBudWxsLCBbY2xpZW50LCByZXF1ZXN0LCBhcmdzLnBhdXNlLCBhcmdzLmNvbnRleHRdKTtcbiAgdmFyIGRlcHMgPSBbY2xpZW50LCByZXF1ZXN0LCBhcmdzLmNvbnRleHQsIGFyZ3MucGF1c2VdO1xuICB2YXIgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBbc291cmNlLCB7XG4gICAgLi4uaW5pdGlhbFN0YXRlLFxuICAgIGZldGNoaW5nOiAhIXNvdXJjZVxuICB9LCBkZXBzXSk7XG4gIHZhciBjdXJyZW50UmVzdWx0ID0gc3RhdGVbMV07XG4gIGlmIChzb3VyY2UgIT09IHN0YXRlWzBdICYmIGhhc0RlcHNDaGFuZ2VkKHN0YXRlWzJdLCBkZXBzKSkge1xuICAgIHNldFN0YXRlKFtzb3VyY2UsIGN1cnJlbnRSZXN1bHQgPSBjb21wdXRlTmV4dFN0YXRlKHN0YXRlWzFdLCB7XG4gICAgICBmZXRjaGluZzogISFzb3VyY2VcbiAgICB9KSwgZGVwc10pO1xuICB9XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdmFyIHVwZGF0ZVJlc3VsdCA9IHJlc3VsdCA9PiB7XG4gICAgICBkZWZlckRpc3BhdGNoKHNldFN0YXRlLCBzdGF0ZSA9PiB7XG4gICAgICAgIHZhciBuZXh0UmVzdWx0ID0gY29tcHV0ZU5leHRTdGF0ZShzdGF0ZVsxXSwgcmVzdWx0KTtcbiAgICAgICAgaWYgKHN0YXRlWzFdID09PSBuZXh0UmVzdWx0KSByZXR1cm4gc3RhdGU7XG4gICAgICAgIGlmIChoYW5kbGVyUmVmLmN1cnJlbnQgJiYgc3RhdGVbMV0uZGF0YSAhPT0gbmV4dFJlc3VsdC5kYXRhKSB7XG4gICAgICAgICAgbmV4dFJlc3VsdC5kYXRhID0gaGFuZGxlclJlZi5jdXJyZW50KHN0YXRlWzFdLmRhdGEsIG5leHRSZXN1bHQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtzdGF0ZVswXSwgbmV4dFJlc3VsdCwgc3RhdGVbMl1dO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAoc3RhdGVbMF0pIHtcbiAgICAgIHJldHVybiB3b25rYS5zdWJzY3JpYmUodXBkYXRlUmVzdWx0KSh3b25rYS5vbkVuZCgoKSA9PiB7XG4gICAgICAgIHVwZGF0ZVJlc3VsdCh7XG4gICAgICAgICAgZmV0Y2hpbmc6ICEhc291cmNlXG4gICAgICAgIH0pO1xuICAgICAgfSkoc3RhdGVbMF0pKS51bnN1YnNjcmliZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlUmVzdWx0KHtcbiAgICAgICAgZmV0Y2hpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtzdGF0ZVswXV0pO1xuXG4gIC8vIFRoaXMgaXMgdGhlIGltcGVyYXRpdmUgZXhlY3V0ZSBmdW5jdGlvbiBwYXNzZWQgdG8gdGhlIHVzZXJcbiAgdmFyIGV4ZWN1dGVTdWJzY3JpcHRpb24gPSBSZWFjdC51c2VDYWxsYmFjayhvcHRzID0+IHtcbiAgICB2YXIgc291cmNlID0gY2xpZW50LmV4ZWN1dGVTdWJzY3JpcHRpb24ocmVxdWVzdCwge1xuICAgICAgLi4uYXJncy5jb250ZXh0LFxuICAgICAgLi4ub3B0c1xuICAgIH0pO1xuICAgIGRlZmVyRGlzcGF0Y2goc2V0U3RhdGUsIHN0YXRlID0+IFtzb3VyY2UsIHN0YXRlWzFdLCBkZXBzXSk7XG4gIH0sIFtjbGllbnQsIGFyZ3MuY29udGV4dCwgcmVxdWVzdF0pO1xuICByZXR1cm4gW2N1cnJlbnRSZXN1bHQsIGV4ZWN1dGVTdWJzY3JpcHRpb25dO1xufVxuXG4vKiogUHJvcHMgYWNjZXB0ZWQgYnkge0BsaW5rIE11dGF0aW9ufS5cbiAqXG4gKiBAcmVtYXJrc1xuICogYE11dGF0aW9uUHJvcHNgIGFyZSB0aGUgcHJvcHMgYWNjZXB0ZWQgYnkgdGhlIHtAbGluayBNdXRhdGlvbn0gY29tcG9uZW50LlxuICpcbiAqIFRoZSByZXN1bHQsIHRoZSB7QGxpbmsgTXV0YXRpb25TdGF0ZX0gb2JqZWN0LCB3aWxsIGJlIHBhc3NlZCB0b1xuICogYSB7QGxpbmsgTXV0YXRpb25Qcm9wcy5jaGlsZHJlbn0gZnVuY3Rpb24sIHBhc3NlZCBhcyBjaGlsZHJlblxuICogdG8gdGhlIGBNdXRhdGlvbmAgY29tcG9uZW50LlxuICovXG5cbi8qKiBPYmplY3QgdGhhdCB7QGxpbmsgTXV0YXRpb25Qcm9wcy5jaGlsZHJlbn0gaXMgY2FsbGVkIHdpdGguXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgaXMgYW4gZXh0ZW50ZWQge0BsaW5rIFVzZU11dGF0aW9uc3RhdGV9IHdpdGggYW4gYWRkZWRcbiAqIHtAbGluayBNdXRhdGlvblN0YXRlLmV4ZWN1dGVNdXRhdGlvbn0gbWV0aG9kLCB3aGljaCBpcyB1c3VhbGx5XG4gKiBwYXJ0IG9mIGEgdHVwbGUgcmV0dXJuZWQgYnkge0BsaW5rIHVzZU11dGF0aW9ufS5cbiAqL1xuXG4vKiogQ29tcG9uZW50IFdyYXBwZXIgYXJvdW5kIHtAbGluayB1c2VNdXRhdGlvbn0gdG8gcnVuIGEgR3JhcGhRTCBxdWVyeS5cbiAqXG4gKiBAcmVtYXJrc1xuICogYE11dGF0aW9uYCBpcyBhIGNvbXBvbmVudCB3cmFwcGVyIGFyb3VuZCB0aGUge0BsaW5rIHVzZU11dGF0aW9ufSBob29rXG4gKiB0aGF0IGNhbGxzIHRoZSB7QGxpbmsgTXV0YXRpb25Qcm9wcy5jaGlsZHJlbn0gcHJvcCwgYXMgYSBmdW5jdGlvbixcbiAqIHdpdGggdGhlIHtAbGluayBNdXRhdGlvblN0YXRlfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIE11dGF0aW9uKHByb3BzKSB7XG4gIHZhciBtdXRhdGlvbiA9IHVzZU11dGF0aW9uKHByb3BzLnF1ZXJ5KTtcbiAgcmV0dXJuIHByb3BzLmNoaWxkcmVuKHtcbiAgICAuLi5tdXRhdGlvblswXSxcbiAgICBleGVjdXRlTXV0YXRpb246IG11dGF0aW9uWzFdXG4gIH0pO1xufVxuXG4vKiogUHJvcHMgYWNjZXB0ZWQgYnkge0BsaW5rIFF1ZXJ5fS5cbiAqXG4gKiBAcmVtYXJrc1xuICogYFF1ZXJ5UHJvcHNgIGFyZSB0aGUgcHJvcHMgYWNjZXB0ZWQgYnkgdGhlIHtAbGluayBRdWVyeX0gY29tcG9uZW50LFxuICogd2hpY2ggaXMgaWRlbnRpY2FsIHRvIHtAbGluayBVc2VRdWVyeUFyZ3N9LlxuICpcbiAqIFRoZSByZXN1bHQsIHRoZSB7QGxpbmsgUXVlcnlTdGF0ZX0gb2JqZWN0LCB3aWxsIGJlIHBhc3NlZCB0b1xuICogYSB7QGxpbmsgUXVlcnlQcm9wcy5jaGlsZHJlbn0gZnVuY3Rpb24sIHBhc3NlZCBhcyBjaGlsZHJlblxuICogdG8gdGhlIGBRdWVyeWAgY29tcG9uZW50LlxuICovXG5cbi8qKiBPYmplY3QgdGhhdCB7QGxpbmsgUXVlcnlQcm9wcy5jaGlsZHJlbn0gaXMgY2FsbGVkIHdpdGguXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgaXMgYW4gZXh0ZW50ZWQge0BsaW5rIFVzZVF1ZXJ5U3RhdGV9IHdpdGggYW4gYWRkZWRcbiAqIHtAbGluayBRdWVyeVN0YXRlLmV4ZWN1dGVRdWVyeX0gbWV0aG9kLCB3aGljaCBpcyB1c3VhbGx5XG4gKiBwYXJ0IG9mIGEgdHVwbGUgcmV0dXJuZWQgYnkge0BsaW5rIHVzZVF1ZXJ5fS5cbiAqL1xuXG4vKiogQ29tcG9uZW50IFdyYXBwZXIgYXJvdW5kIHtAbGluayB1c2VRdWVyeX0gdG8gcnVuIGEgR3JhcGhRTCBxdWVyeS5cbiAqXG4gKiBAcmVtYXJrc1xuICogYFF1ZXJ5YCBpcyBhIGNvbXBvbmVudCB3cmFwcGVyIGFyb3VuZCB0aGUge0BsaW5rIHVzZVF1ZXJ5fSBob29rXG4gKiB0aGF0IGNhbGxzIHRoZSB7QGxpbmsgUXVlcnlQcm9wcy5jaGlsZHJlbn0gcHJvcCwgYXMgYSBmdW5jdGlvbixcbiAqIHdpdGggdGhlIHtAbGluayBRdWVyeVN0YXRlfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIFF1ZXJ5KHByb3BzKSB7XG4gIHZhciBxdWVyeSA9IHVzZVF1ZXJ5KHByb3BzKTtcbiAgcmV0dXJuIHByb3BzLmNoaWxkcmVuKHtcbiAgICAuLi5xdWVyeVswXSxcbiAgICBleGVjdXRlUXVlcnk6IHF1ZXJ5WzFdXG4gIH0pO1xufVxuXG4vKiogUHJvcHMgYWNjZXB0ZWQgYnkge0BsaW5rIFN1YnNjcmlwdGlvbn0uXG4gKlxuICogQHJlbWFya3NcbiAqIGBTdWJzY3JpcHRpb25Qcm9wc2AgYXJlIHRoZSBwcm9wcyBhY2NlcHRlZCBieSB0aGUge0BsaW5rIFN1YnNjcmlwdGlvbn0gY29tcG9uZW50LFxuICogd2hpY2ggaXMgaWRlbnRpY2FsIHRvIHtAbGluayBVc2VTdWJzY3JpcHRpb25BcmdzfSB3aXRoIGFuIGFkZGVkXG4gKiB7QGxpbmsgU3Vic2NyaXB0aW9uUHJvcHMuaGFuZGxlcn0gcHJvcCwgd2hpY2gge0BsaW5rIHVzZVN1YnNjcmlwdGlvbn0gdXN1YWxseVxuICogYWNjZXB0cyBhcyBhbiBhZGRpdGlvbmFsIGFyZ3VtZW50LlxuICpcbiAqIFRoZSByZXN1bHQsIHRoZSB7QGxpbmsgU3Vic2NyaXB0aW9uU3RhdGV9IG9iamVjdCwgd2lsbCBiZSBwYXNzZWQgdG9cbiAqIGEge0BsaW5rIFN1YnNjcmlwdGlvblByb3BzLmNoaWxkcmVufSBmdW5jdGlvbiwgcGFzc2VkIGFzIGNoaWxkcmVuXG4gKiB0byB0aGUgYFN1YnNjcmlwdGlvbmAgY29tcG9uZW50LlxuICovXG5cbi8qKiBPYmplY3QgdGhhdCB7QGxpbmsgU3Vic2NyaXB0aW9uUHJvcHMuY2hpbGRyZW59IGlzIGNhbGxlZCB3aXRoLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIGlzIGFuIGV4dGVudGVkIHtAbGluayBVc2VTdWJzY3JpcHRpb25TdGF0ZX0gd2l0aCBhbiBhZGRlZFxuICoge0BsaW5rIFN1YnNjcmlwdGlvblN0YXRlLmV4ZWN1dGVTdWJzY3JpcHRpb259IG1ldGhvZCwgd2hpY2ggaXMgdXN1YWxseVxuICogcGFydCBvZiBhIHR1cGxlIHJldHVybmVkIGJ5IHtAbGluayB1c2VTdWJzY3JpcHRpb259LlxuICovXG5cbi8qKiBDb21wb25lbnQgV3JhcHBlciBhcm91bmQge0BsaW5rIHVzZVN1YnNjcmlwdGlvbn0gdG8gcnVuIGEgR3JhcGhRTCBzdWJzY3JpcHRpb24uXG4gKlxuICogQHJlbWFya3NcbiAqIGBTdWJzY3JpcHRpb25gIGlzIGEgY29tcG9uZW50IHdyYXBwZXIgYXJvdW5kIHRoZSB7QGxpbmsgdXNlU3Vic2NyaXB0aW9ufSBob29rXG4gKiB0aGF0IGNhbGxzIHRoZSB7QGxpbmsgU3Vic2NyaXB0aW9uUHJvcHMuY2hpbGRyZW59IHByb3AsIGFzIGEgZnVuY3Rpb24sXG4gKiB3aXRoIHRoZSB7QGxpbmsgU3Vic2NyaXB0aW9uU3RhdGV9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gU3Vic2NyaXB0aW9uKHByb3BzKSB7XG4gIHZhciBzdWJzY3JpcHRpb24gPSB1c2VTdWJzY3JpcHRpb24ocHJvcHMsIHByb3BzLmhhbmRsZXIpO1xuICByZXR1cm4gcHJvcHMuY2hpbGRyZW4oe1xuICAgIC4uLnN1YnNjcmlwdGlvblswXSxcbiAgICBleGVjdXRlU3Vic2NyaXB0aW9uOiBzdWJzY3JpcHRpb25bMV1cbiAgfSk7XG59XG5cbmV4cG9ydHMuQ29uc3VtZXIgPSBDb25zdW1lcjtcbmV4cG9ydHMuQ29udGV4dCA9IENvbnRleHQ7XG5leHBvcnRzLk11dGF0aW9uID0gTXV0YXRpb247XG5leHBvcnRzLlByb3ZpZGVyID0gUHJvdmlkZXI7XG5leHBvcnRzLlF1ZXJ5ID0gUXVlcnk7XG5leHBvcnRzLlN1YnNjcmlwdGlvbiA9IFN1YnNjcmlwdGlvbjtcbmV4cG9ydHMudXNlQ2xpZW50ID0gdXNlQ2xpZW50O1xuZXhwb3J0cy51c2VNdXRhdGlvbiA9IHVzZU11dGF0aW9uO1xuZXhwb3J0cy51c2VRdWVyeSA9IHVzZVF1ZXJ5O1xuZXhwb3J0cy51c2VTdWJzY3JpcHRpb24gPSB1c2VTdWJzY3JpcHRpb247XG5PYmplY3Qua2V5cyhjb3JlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5pZiAoayAhPT0gJ2RlZmF1bHQnICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KGspKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuZW51bWVyYWJsZTogdHJ1ZSxcbmdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29yZVtrXTsgfVxufSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVycWwuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../../node_modules/.pnpm/urql@4.0.4_graphql@16.11.0_react@18.2.0/node_modules/urql/dist/urql.js\n");

/***/ })

};
;
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@urql+core@4.0.10_graphql@16.11.0";
exports.ids = ["vendor-chunks/@urql+core@4.0.10_graphql@16.11.0"];
exports.modules = {

/***/ "(pages-dir-node)/../../node_modules/.pnpm/@urql+core@4.0.10_graphql@16.11.0/node_modules/@urql/core/dist/urql-core-chunk.js":
/*!******************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@urql+core@4.0.10_graphql@16.11.0/node_modules/@urql/core/dist/urql-core-chunk.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var graphql_web = __webpack_require__(/*! @0no-co/graphql.web */ \"(pages-dir-node)/../../node_modules/.pnpm/@0no-co+graphql.web@1.0.4_graphql@16.11.0/node_modules/@0no-co/graphql.web/dist/graphql.web.js\");\nvar wonka = __webpack_require__(/*! wonka */ \"(pages-dir-node)/../../node_modules/.pnpm/wonka@6.3.2/node_modules/wonka/dist/wonka.js\");\n\nvar generateErrorMessage = (networkErr, graphQlErrs) => {\n  var error = '';\n  if (networkErr) return `[Network] ${networkErr.message}`;\n  if (graphQlErrs) {\n    for (var err of graphQlErrs) {\n      if (error) error += '\\n';\n      error += `[GraphQL] ${err.message}`;\n    }\n  }\n  return error;\n};\nvar rehydrateGraphQlError = error => {\n  if (error && error.message && (error.extensions || error.name === 'GraphQLError')) {\n    return error;\n  } else if (typeof error === 'object' && error.message) {\n    return new graphql_web.GraphQLError(error.message, error.nodes, error.source, error.positions, error.path, error, error.extensions || {});\n  } else {\n    return new graphql_web.GraphQLError(error);\n  }\n};\n\n/** An abstracted `Error` that provides either a `networkError` or `graphQLErrors`.\n *\n * @remarks\n * During a GraphQL request, either the request can fail entirely, causing a network error,\n * or the GraphQL execution or fields can fail, which will cause an {@link ExecutionResult}\n * to contain an array of GraphQL errors.\n *\n * The `CombinedError` abstracts and normalizes both failure cases. When {@link OperationResult.error}\n * is set to this error, the `CombinedError` abstracts all errors, making it easier to handle only\n * a subset of error cases.\n *\n * @see {@link https://urql.dev/goto/docs/basics/errors} for more information on handling\n * GraphQL errors and the `CombinedError`.\n */\nclass CombinedError extends Error {\n  /** A list of GraphQL errors rehydrated from a {@link ExecutionResult}.\n   *\n   * @remarks\n   * If an {@link ExecutionResult} received from the API contains a list of errors,\n   * the `CombinedError` will rehydrate them, normalize them to\n   * {@link GraphQLError | GraphQLErrors} and list them here.\n   * An empty list indicates that no GraphQL error has been sent by the API.\n   */\n\n  /** Set to an error, if a GraphQL request has failed outright.\n   *\n   * @remarks\n   * A GraphQL over HTTP request may fail and not reach the API. Any error that\n   * prevents a GraphQl request outright, will be considered a “network error” and\n   * set here.\n   */\n\n  /** Set to the {@link Response} object a fetch exchange received.\n   *\n   * @remarks\n   * If a built-in fetch {@link Exchange} is used in `urql`, this may\n   * be set to the {@link Response} object of the Fetch API response.\n   * However, since `urql` doesn’t assume that all users will use HTTP\n   * as the only or exclusive transport for GraphQL this property is\n   * neither typed nor guaranteed and may be re-used for other purposes\n   * by non-fetch exchanges.\n   *\n   * Hint: It can be useful to use `response.status` here, however, if\n   * you plan on relying on this being a {@link Response} in your app,\n   * which it is by default, then make sure you add some extra checks\n   * before blindly assuming so!\n   */\n\n  constructor(input) {\n    var normalizedGraphQLErrors = (input.graphQLErrors || []).map(rehydrateGraphQlError);\n    var message = generateErrorMessage(input.networkError, normalizedGraphQLErrors);\n    super(message);\n    this.name = 'CombinedError';\n    this.message = message;\n    this.graphQLErrors = normalizedGraphQLErrors;\n    this.networkError = input.networkError;\n    this.response = input.response;\n  }\n  toString() {\n    return this.message;\n  }\n}\n\n/** A hash value as computed by {@link phash}.\n *\n * @remarks\n * Typically `HashValue`s are used as hashes and keys of GraphQL documents,\n * variables, and combined, for GraphQL requests.\n */\n\n/** Computes a djb2 hash of the given string.\n *\n * @param x - the string to be hashed\n * @param seed - optionally a prior hash for progressive hashing\n * @returns a hash value, i.e. a number\n *\n * @remark\n * This is the hashing function used throughout `urql`, primarily to compute\n * {@link Operation.key}.\n *\n * @see {@link http://www.cse.yorku.ca/~oz/hash.html#djb2} for a further description of djb2.\n */\nvar phash = (x, seed) => {\n  var h = (seed || 5381) | 0;\n  for (var i = 0, l = x.length | 0; i < l; i++) h = (h << 5) + h + x.charCodeAt(i);\n  return h;\n};\n\nvar seen = new Set();\nvar cache = new WeakMap();\nvar stringify = x => {\n  if (x === null || seen.has(x)) {\n    return 'null';\n  } else if (typeof x !== 'object') {\n    return JSON.stringify(x) || '';\n  } else if (x.toJSON) {\n    return stringify(x.toJSON());\n  } else if (Array.isArray(x)) {\n    var _out = '[';\n    for (var value of x) {\n      if (_out.length > 1) _out += ',';\n      _out += stringify(value) || 'null';\n    }\n    _out += ']';\n    return _out;\n  } else if (FileConstructor !== NoopConstructor && x instanceof FileConstructor || BlobConstructor !== NoopConstructor && x instanceof BlobConstructor) {\n    return 'null';\n  }\n  var keys = Object.keys(x).sort();\n  if (!keys.length && x.constructor && x.constructor !== Object) {\n    var key = cache.get(x) || Math.random().toString(36).slice(2);\n    cache.set(x, key);\n    return stringify({\n      __key: key\n    });\n  }\n  seen.add(x);\n  var out = '{';\n  for (var _key of keys) {\n    var _value = stringify(x[_key]);\n    if (_value) {\n      if (out.length > 1) out += ',';\n      out += stringify(_key) + ':' + _value;\n    }\n  }\n  seen.delete(x);\n  out += '}';\n  return out;\n};\nvar extract = (map, path, x) => {\n  if (x == null || typeof x !== 'object' || x.toJSON || seen.has(x)) ; else if (Array.isArray(x)) {\n    for (var i = 0, l = x.length; i < l; i++) extract(map, `${path}.${i}`, x[i]);\n  } else if (x instanceof FileConstructor || x instanceof BlobConstructor) {\n    map.set(path, x);\n  } else {\n    seen.add(x);\n    for (var key of Object.keys(x)) extract(map, `${path}.${key}`, x[key]);\n  }\n};\n\n/** A stable stringifier for GraphQL variables objects.\n *\n * @param x - any JSON-like data.\n * @return A JSON string.\n *\n * @remarks\n * This utility creates a stable JSON string from any passed data,\n * and protects itself from throwing.\n *\n * The JSON string is stable insofar as objects’ keys are sorted,\n * and instances of non-plain objects are replaced with random keys\n * replacing their values, which remain stable for the objects’\n * instance.\n */\nvar stringifyVariables = x => {\n  seen.clear();\n  return stringify(x);\n};\nclass NoopConstructor {}\nvar FileConstructor = typeof File !== 'undefined' ? File : NoopConstructor;\nvar BlobConstructor = typeof Blob !== 'undefined' ? Blob : NoopConstructor;\nvar extractFiles = x => {\n  var map = new Map();\n  if (FileConstructor !== NoopConstructor || BlobConstructor !== NoopConstructor) {\n    seen.clear();\n    extract(map, 'variables', x);\n  }\n  return map;\n};\n\n/** A `DocumentNode` annotated with its hashed key.\n * @internal\n */\n\nvar SOURCE_NAME = 'gql';\nvar GRAPHQL_STRING_RE = /(\"{3}[\\s\\S]*\"{3}|\"(?:\\\\.|[^\"])*\")/g;\nvar REPLACE_CHAR_RE = /(?:#[^\\n\\r]+)?(?:[\\r\\n]+|$)/g;\nvar replaceOutsideStrings = (str, idx) => idx % 2 === 0 ? str.replace(REPLACE_CHAR_RE, '\\n') : str;\n\n/** Sanitizes a GraphQL document string by replacing comments and redundant newlines in it. */\nvar sanitizeDocument = node => node.split(GRAPHQL_STRING_RE).map(replaceOutsideStrings).join('').trim();\nvar prints = new Map();\nvar docs = new Map();\n\n/** A cached printing function for GraphQL documents.\n *\n * @param node - A string of a document or a {@link DocumentNode}\n * @returns A normalized printed string of the passed GraphQL document.\n *\n * @remarks\n * This function accepts a GraphQL query string or {@link DocumentNode},\n * then prints and sanitizes it. The sanitizer takes care of removing\n * comments, which otherwise alter the key of the document although the\n * document is otherwise equivalent to another.\n *\n * When a {@link DocumentNode} is passed to this function, it caches its\n * output by modifying the `loc.source.body` property on the GraphQL node.\n */\nvar stringifyDocument = node => {\n  var printed;\n  if (typeof node === 'string') {\n    printed = sanitizeDocument(node);\n  } else if (node.loc && docs.get(node.__key) === node) {\n    printed = node.loc.source.body;\n  } else {\n    printed = prints.get(node) || sanitizeDocument(graphql_web.print(node));\n    prints.set(node, printed);\n  }\n  if (typeof node !== 'string' && !node.loc) {\n    node.loc = {\n      start: 0,\n      end: printed.length,\n      source: {\n        body: printed,\n        name: SOURCE_NAME,\n        locationOffset: {\n          line: 1,\n          column: 1\n        }\n      }\n    };\n  }\n  return printed;\n};\n\n/** Computes the hash for a document's string using {@link stringifyDocument}'s output.\n *\n * @param node - A string of a document or a {@link DocumentNode}\n * @returns A {@link HashValue}\n *\n * @privateRemarks\n * This function adds the operation name of the document to the hash, since sometimes\n * a merged document with multiple operations may be used. Although `urql` requires a\n * `DocumentNode` to only contain a single operation, when the cached `loc.source.body`\n * of a `DocumentNode` is used, this string may still contain multiple operations and\n * the resulting hash should account for only one at a time.\n */\nvar hashDocument = node => {\n  var key = phash(stringifyDocument(node));\n  // Add the operation name to the produced hash\n  if (node.definitions) {\n    var operationName = getOperationName(node);\n    if (operationName) key = phash(`\\n# ${operationName}`, key);\n  }\n  return key;\n};\n\n/** Returns a canonical version of the passed `DocumentNode` with an added hash key.\n *\n * @param node - A string of a document or a {@link DocumentNode}\n * @returns A {@link KeyedDocumentNode}\n *\n * @remarks\n * `urql` will always avoid unnecessary work, no matter whether a user passes `DocumentNode`s\n * or strings of GraphQL documents to its APIs.\n *\n * This function will return a canonical version of a {@link KeyedDocumentNode} no matter\n * which kind of input is passed, avoiding parsing or hashing of passed data as needed.\n */\nvar keyDocument = node => {\n  var key;\n  var query;\n  if (typeof node === 'string') {\n    key = hashDocument(node);\n    query = docs.get(key) || graphql_web.parse(node, {\n      noLocation: true\n    });\n  } else {\n    key = node.__key || hashDocument(node);\n    query = docs.get(key) || node;\n  }\n\n  // Add location information if it's missing\n  if (!query.loc) stringifyDocument(query);\n  query.__key = key;\n  docs.set(key, query);\n  return query;\n};\n\n/** Creates a `GraphQLRequest` from the passed parameters.\n *\n * @param q - A string of a document or a {@link DocumentNode}\n * @param variables - A variables object for the defined GraphQL operation.\n * @returns A {@link GraphQLRequest}\n *\n * @remarks\n * `createRequest` creates a {@link GraphQLRequest} from the passed parameters,\n * while replacing the document as needed with a canonical version of itself,\n * to avoid parsing, printing, or hashing the same input multiple times.\n *\n * If no variables are passed, canonically it'll default to an empty object,\n * which is removed from the resulting hash key.\n */\nvar createRequest = (_query, _variables, extensions) => {\n  var variables = _variables || {};\n  var query = keyDocument(_query);\n  var printedVars = stringifyVariables(variables);\n  var key = query.__key;\n  if (printedVars !== '{}') key = phash(printedVars, key);\n  return {\n    key,\n    query,\n    variables,\n    extensions\n  };\n};\n\n/** Returns the name of the `DocumentNode`'s operation, if any.\n * @param query - A {@link DocumentNode}\n * @returns the operation's name contained within the document, or `undefined`\n */\nvar getOperationName = query => {\n  for (var node of query.definitions) {\n    if (node.kind === graphql_web.Kind.OPERATION_DEFINITION) {\n      return node.name ? node.name.value : undefined;\n    }\n  }\n};\n\n/** Returns the type of the `DocumentNode`'s operation, if any.\n * @param query - A {@link DocumentNode}\n * @returns the operation's type contained within the document, or `undefined`\n */\nvar getOperationType = query => {\n  for (var node of query.definitions) {\n    if (node.kind === graphql_web.Kind.OPERATION_DEFINITION) {\n      return node.operation;\n    }\n  }\n};\n\n/** Converts the `ExecutionResult` received for a given `Operation` to an `OperationResult`.\n *\n * @param operation - The {@link Operation} for which the API’s result is for.\n * @param result - The GraphQL API’s {@link ExecutionResult}.\n * @param response - Optionally, a raw object representing the API’s result (Typically a {@link Response}).\n * @returns An {@link OperationResult}.\n *\n * @remarks\n * This utility can be used to create {@link OperationResult | OperationResults} in the shape\n * that `urql` expects and defines, and should be used rather than creating the results manually.\n *\n * @throws\n * If no data, or errors are contained within the result, or the result is instead an incremental\n * response containing a `path` property, a “No Content” error is thrown.\n *\n * @see {@link ExecutionResult} for the type definition of GraphQL API results.\n */\nvar makeResult = (operation, result, response) => {\n  if (!('data' in result) && !('errors' in result)) {\n    throw new Error('No Content');\n  }\n  var defaultHasNext = operation.kind === 'subscription';\n  return {\n    operation,\n    data: result.data,\n    error: Array.isArray(result.errors) ? new CombinedError({\n      graphQLErrors: result.errors,\n      response\n    }) : undefined,\n    extensions: result.extensions ? {\n      ...result.extensions\n    } : undefined,\n    hasNext: result.hasNext == null ? defaultHasNext : result.hasNext,\n    stale: false\n  };\n};\nvar deepMerge = (target, source) => {\n  if (typeof target === 'object' && target != null) {\n    if (!target.constructor || target.constructor === Object || Array.isArray(target)) {\n      target = Array.isArray(target) ? [...target] : {\n        ...target\n      };\n      for (var key of Object.keys(source)) target[key] = deepMerge(target[key], source[key]);\n      return target;\n    }\n  }\n  return source;\n};\n\n/** Merges an incrementally delivered `ExecutionResult` into a previous `OperationResult`.\n *\n * @param prevResult - The {@link OperationResult} that preceded this result.\n * @param path - The GraphQL API’s {@link ExecutionResult} that should be patching the `prevResult`.\n * @param response - Optionally, a raw object representing the API’s result (Typically a {@link Response}).\n * @returns A new {@link OperationResult} patched with the incremental result.\n *\n * @remarks\n * This utility should be used to merge subsequent {@link ExecutionResult | ExecutionResults} of\n * incremental responses into a prior {@link OperationResult}.\n *\n * When directives like `@defer`, `@stream`, and `@live` are used, GraphQL may deliver new\n * results that modify previous results. In these cases, it'll set a `path` property to modify\n * the result it sent last. This utility is built to handle these cases and merge these payloads\n * into existing {@link OperationResult | OperationResults}.\n *\n * @see {@link ExecutionResult} for the type definition of GraphQL API results.\n */\nvar mergeResultPatch = (prevResult, nextResult, response) => {\n  var errors = prevResult.error ? prevResult.error.graphQLErrors : [];\n  var hasExtensions = !!prevResult.extensions || !!nextResult.extensions;\n  var extensions = {\n    ...prevResult.extensions,\n    ...nextResult.extensions\n  };\n  var incremental = nextResult.incremental;\n\n  // NOTE: We handle the old version of the incremental delivery payloads as well\n  if ('path' in nextResult) {\n    incremental = [nextResult];\n  }\n  var withData = {\n    data: prevResult.data\n  };\n  if (incremental) {\n    for (var patch of incremental) {\n      if (Array.isArray(patch.errors)) {\n        errors.push(...patch.errors);\n      }\n      if (patch.extensions) {\n        Object.assign(extensions, patch.extensions);\n        hasExtensions = true;\n      }\n      var prop = 'data';\n      var part = withData;\n      for (var i = 0, l = patch.path.length; i < l; prop = patch.path[i++]) {\n        part = part[prop] = Array.isArray(part[prop]) ? [...part[prop]] : {\n          ...part[prop]\n        };\n      }\n      if (patch.items) {\n        var startIndex = +prop >= 0 ? prop : 0;\n        for (var _i = 0, _l = patch.items.length; _i < _l; _i++) part[startIndex + _i] = deepMerge(part[startIndex + _i], patch.items[_i]);\n      } else if (patch.data !== undefined) {\n        part[prop] = deepMerge(part[prop], patch.data);\n      }\n    }\n  } else {\n    withData.data = nextResult.data || prevResult.data;\n    errors = nextResult.errors || errors;\n  }\n  return {\n    operation: prevResult.operation,\n    data: withData.data,\n    error: errors.length ? new CombinedError({\n      graphQLErrors: errors,\n      response\n    }) : undefined,\n    extensions: hasExtensions ? extensions : undefined,\n    hasNext: nextResult.hasNext != null ? nextResult.hasNext : prevResult.hasNext,\n    stale: false\n  };\n};\n\n/** Creates an `OperationResult` containing a network error for requests that encountered unexpected errors.\n *\n * @param operation - The {@link Operation} for which the API’s result is for.\n * @param error - The network-like error that prevented an API result from being delivered.\n * @param response - Optionally, a raw object representing the API’s result (Typically a {@link Response}).\n * @returns An {@link OperationResult} containing only a {@link CombinedError}.\n *\n * @remarks\n * This utility can be used to create {@link OperationResult | OperationResults} in the shape\n * that `urql` expects and defines, and should be used rather than creating the results manually.\n * This function should be used for when the {@link CombinedError.networkError} property is\n * populated and no GraphQL execution actually occurred.\n */\nvar makeErrorResult = (operation, error, response) => ({\n  operation,\n  data: undefined,\n  error: new CombinedError({\n    networkError: error,\n    response\n  }),\n  extensions: undefined,\n  hasNext: false,\n  stale: false\n});\n\n/** Abstract definition of the JSON data sent during GraphQL HTTP POST requests. */\n\n/** Creates a GraphQL over HTTP compliant JSON request body.\n * @param request - An object containing a `query` document and `variables`.\n * @returns A {@link FetchBody}\n * @see {@link https://github.com/graphql/graphql-over-http} for the GraphQL over HTTP spec.\n */\nfunction makeFetchBody(request) {\n  var isAPQ = request.extensions && request.extensions.persistedQuery && !request.extensions.persistedQuery.miss;\n  return {\n    query: isAPQ ? undefined : stringifyDocument(request.query),\n    operationName: getOperationName(request.query),\n    variables: request.variables || undefined,\n    extensions: request.extensions\n  };\n}\n\n/** Creates a URL that will be called for a GraphQL HTTP request.\n *\n * @param operation - An {@link Operation} for which to make the request.\n * @param body - A {@link FetchBody} which may be replaced with a URL.\n *\n * @remarks\n * Creates the URL that’ll be called as part of a GraphQL HTTP request.\n * Built-in fetch exchanges support sending GET requests, even for\n * non-persisted full requests, which this function supports by being\n * able to serialize GraphQL requests into the URL.\n */\nvar makeFetchURL = (operation, body) => {\n  var useGETMethod = operation.kind === 'query' && operation.context.preferGetMethod;\n  if (!useGETMethod || !body) return operation.context.url;\n  var url = new URL(operation.context.url);\n  for (var key in body) {\n    var value = body[key];\n    if (value) {\n      url.searchParams.set(key, typeof value === 'object' ? stringifyVariables(value) : value);\n    }\n  }\n  var finalUrl = url.toString();\n  if (finalUrl.length > 2047 && useGETMethod !== 'force') {\n    operation.context.preferGetMethod = false;\n    return operation.context.url;\n  }\n  return finalUrl;\n};\n\n/** Serializes a {@link FetchBody} into a {@link RequestInit.body} format. */\nvar serializeBody = (operation, body) => {\n  var omitBody = operation.kind === 'query' && !!operation.context.preferGetMethod;\n  if (body && !omitBody) {\n    var json = stringifyVariables(body);\n    var files = extractFiles(body.variables);\n    if (files.size) {\n      var form = new FormData();\n      form.append('operations', json);\n      form.append('map', stringifyVariables({\n        ...[...files.keys()].map(value => [value])\n      }));\n      var index = 0;\n      for (var file of files.values()) form.append(`${index++}`, file);\n      return form;\n    }\n    return json;\n  }\n};\n\n/** Creates a `RequestInit` object for a given `Operation`.\n *\n * @param operation - An {@link Operation} for which to make the request.\n * @param body - A {@link FetchBody} which is added to the options, if the request isn’t a GET request.\n *\n * @remarks\n * Creates the fetch options {@link RequestInit} object that’ll be passed to the Fetch API\n * as part of a GraphQL over HTTP request. It automatically sets a default `Content-Type`\n * header.\n *\n * @see {@link https://github.com/graphql/graphql-over-http} for the GraphQL over HTTP spec.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API} for the Fetch API spec.\n */\nvar makeFetchOptions = (operation, body) => {\n  var headers = {\n    accept: operation.kind === 'subscription' ? 'text/event-stream, multipart/mixed' : 'application/graphql-response+json, application/graphql+json, application/json, text/event-stream, multipart/mixed'\n  };\n  var extraOptions = (typeof operation.context.fetchOptions === 'function' ? operation.context.fetchOptions() : operation.context.fetchOptions) || {};\n  if (extraOptions.headers) for (var key in extraOptions.headers) headers[key.toLowerCase()] = extraOptions.headers[key];\n  var serializedBody = serializeBody(operation, body);\n  if (typeof serializedBody === 'string' && !headers['content-type']) headers['content-type'] = 'application/json';\n  return {\n    ...extraOptions,\n    method: serializedBody ? 'POST' : 'GET',\n    body: serializedBody,\n    headers\n  };\n};\n\nvar decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder() : null;\nvar boundaryHeaderRe = /boundary=\"?([^=\";]+)\"?/i;\nvar eventStreamRe = /data: ?([^\\n]+)/;\n// NOTE: We're avoiding referencing the `Buffer` global here to prevent\n// auto-polyfilling in Webpack\nvar toString = input => input.constructor.name === 'Buffer' ? input.toString() : decoder.decode(input);\nasync function* streamBody(response) {\n  if (response.body[Symbol.asyncIterator]) {\n    for await (var chunk of response.body) yield toString(chunk);\n  } else {\n    var reader = response.body.getReader();\n    var result;\n    try {\n      while (!(result = await reader.read()).done) yield toString(result.value);\n    } finally {\n      reader.cancel();\n    }\n  }\n}\nasync function* split(chunks, boundary) {\n  var buffer = '';\n  var boundaryIndex;\n  for await (var chunk of chunks) {\n    buffer += chunk;\n    while ((boundaryIndex = buffer.indexOf(boundary)) > -1) {\n      yield buffer.slice(0, boundaryIndex);\n      buffer = buffer.slice(boundaryIndex + boundary.length);\n    }\n  }\n}\nasync function* parseJSON(response) {\n  yield JSON.parse(await response.text());\n}\nasync function* parseEventStream(response) {\n  var payload;\n  for await (var chunk of split(streamBody(response), '\\n\\n')) {\n    var match = chunk.match(eventStreamRe);\n    if (match) {\n      var _chunk = match[1];\n      try {\n        yield payload = JSON.parse(_chunk);\n      } catch (error) {\n        if (!payload) throw error;\n      }\n      if (payload && payload.hasNext === false) break;\n    }\n  }\n  if (payload && payload.hasNext !== false) {\n    yield {\n      hasNext: false\n    };\n  }\n}\nasync function* parseMultipartMixed(contentType, response) {\n  var boundaryHeader = contentType.match(boundaryHeaderRe);\n  var boundary = '--' + (boundaryHeader ? boundaryHeader[1] : '-');\n  var isPreamble = true;\n  var payload;\n  for await (var chunk of split(streamBody(response), '\\r\\n' + boundary)) {\n    if (isPreamble) {\n      isPreamble = false;\n      var preambleIndex = chunk.indexOf(boundary);\n      if (preambleIndex > -1) {\n        chunk = chunk.slice(preambleIndex + boundary.length);\n      } else {\n        continue;\n      }\n    }\n    try {\n      yield payload = JSON.parse(chunk.slice(chunk.indexOf('\\r\\n\\r\\n') + 4));\n    } catch (error) {\n      if (!payload) throw error;\n    }\n    if (payload && payload.hasNext === false) break;\n  }\n  if (payload && payload.hasNext !== false) {\n    yield {\n      hasNext: false\n    };\n  }\n}\nasync function* fetchOperation(operation, url, fetchOptions) {\n  var networkMode = true;\n  var result = null;\n  var response;\n  try {\n    // Delay for a tick to give the Client a chance to cancel the request\n    // if a teardown comes in immediately\n    yield await Promise.resolve();\n    response = await (operation.context.fetch || fetch)(url, fetchOptions);\n    var contentType = response.headers.get('Content-Type') || '';\n    var results;\n    if (/multipart\\/mixed/i.test(contentType)) {\n      results = parseMultipartMixed(contentType, response);\n    } else if (/text\\/event-stream/i.test(contentType)) {\n      results = parseEventStream(response);\n    } else if (!/text\\//i.test(contentType)) {\n      results = parseJSON(response);\n    } else {\n      throw new Error(await response.text());\n    }\n    for await (var payload of results) {\n      result = result ? mergeResultPatch(result, payload, response) : makeResult(operation, payload, response);\n      networkMode = false;\n      yield result;\n      networkMode = true;\n    }\n    if (!result) {\n      yield result = makeResult(operation, {}, response);\n    }\n  } catch (error) {\n    if (!networkMode) {\n      throw error;\n    }\n    yield makeErrorResult(operation, response && (response.status < 200 || response.status >= 300) && response.statusText ? new Error(response.statusText) : error, response);\n  }\n}\n\n/** Makes a GraphQL HTTP request to a given API by wrapping around the Fetch API.\n *\n * @param operation - The {@link Operation} that should be sent via GraphQL over HTTP.\n * @param url - The endpoint URL for the GraphQL HTTP API.\n * @param fetchOptions - The {@link RequestInit} fetch options for the request.\n * @returns A Wonka {@link Source} of {@link OperationResult | OperationResults}.\n *\n * @remarks\n * This utility defines how all built-in fetch exchanges make GraphQL HTTP requests,\n * supporting multipart incremental responses, cancellation and other smaller\n * implementation details.\n *\n * If you’re implementing a modified fetch exchange for a GraphQL over HTTP API\n * it’s recommended you use this utility.\n *\n * Hint: This function does not use the passed `operation` to create or modify the\n * `fetchOptions` and instead expects that the options have already been created\n * using {@link makeFetchOptions} and modified as needed.\n *\n * @throws\n * If the `fetch` polyfill or globally available `fetch` function doesn’t support\n * streamed multipart responses while trying to handle a `multipart/mixed` GraphQL response,\n * the source will throw “Streaming requests unsupported”.\n * This shouldn’t happen in modern browsers and Node.js.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API} for the Fetch API spec.\n */\nfunction makeFetchSource(operation, url, fetchOptions) {\n  var abortController;\n  if (typeof AbortController !== 'undefined') {\n    fetchOptions.signal = (abortController = new AbortController()).signal;\n  }\n  return wonka.onEnd(() => {\n    if (abortController) abortController.abort();\n  })(wonka.filter(result => !!result)(wonka.fromAsyncIterable(fetchOperation(operation, url, fetchOptions))));\n}\n\nexports.CombinedError = CombinedError;\nexports.createRequest = createRequest;\nexports.getOperationType = getOperationType;\nexports.keyDocument = keyDocument;\nexports.makeErrorResult = makeErrorResult;\nexports.makeFetchBody = makeFetchBody;\nexports.makeFetchOptions = makeFetchOptions;\nexports.makeFetchSource = makeFetchSource;\nexports.makeFetchURL = makeFetchURL;\nexports.makeResult = makeResult;\nexports.mergeResultPatch = mergeResultPatch;\nexports.stringifyDocument = stringifyDocument;\nexports.stringifyVariables = stringifyVariables;\n//# sourceMappingURL=urql-core-chunk.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHVycWwrY29yZUA0LjAuMTBfZ3JhcGhxbEAxNi4xMS4wL25vZGVfbW9kdWxlcy9AdXJxbC9jb3JlL2Rpc3QvdXJxbC1jb3JlLWNodW5rLmpzIiwibWFwcGluZ3MiOiJBQUFBLGtCQUFrQixtQkFBTyxDQUFDLHFLQUFxQjtBQUMvQyxZQUFZLG1CQUFPLENBQUMscUdBQU87O0FBRTNCO0FBQ0E7QUFDQSxzQ0FBc0MsbUJBQW1CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLDRJQUE0STtBQUM1SSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsU0FBUyxnREFBZ0Q7QUFDekQ7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHNCQUFzQjtBQUN4RTtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQSxNQUFNLG9DQUFvQztBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBLDBCQUEwQixnQkFBZ0I7QUFDMUMsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsZ0JBQWdCO0FBQzFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxZQUFZO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksb0JBQW9CO0FBQ3hC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QTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0EsOEJBQThCLG1CQUFtQjtBQUNqRCxxQkFBcUIsY0FBYyxJQUFJLHlDQUF5QztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3QkFBd0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGtFQUFrRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIsd0JBQXdCO0FBQ3hCLG1CQUFtQjtBQUNuQix1QkFBdUI7QUFDdkIscUJBQXFCO0FBQ3JCLHdCQUF3QjtBQUN4Qix1QkFBdUI7QUFDdkIsb0JBQW9CO0FBQ3BCLGtCQUFrQjtBQUNsQix3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCLDBCQUEwQjtBQUMxQiIsInNvdXJjZXMiOlsiL2hvbWUvbWljaGFlbC9zYWxlb3ItcGxhdGZvcm0vc2FsZW9yLWFwcHMvbm9kZV9tb2R1bGVzLy5wbnBtL0B1cnFsK2NvcmVANC4wLjEwX2dyYXBocWxAMTYuMTEuMC9ub2RlX21vZHVsZXMvQHVycWwvY29yZS9kaXN0L3VycWwtY29yZS1jaHVuay5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZ3JhcGhxbF93ZWIgPSByZXF1aXJlKCdAMG5vLWNvL2dyYXBocWwud2ViJyk7XG52YXIgd29ua2EgPSByZXF1aXJlKCd3b25rYScpO1xuXG52YXIgZ2VuZXJhdGVFcnJvck1lc3NhZ2UgPSAobmV0d29ya0VyciwgZ3JhcGhRbEVycnMpID0+IHtcbiAgdmFyIGVycm9yID0gJyc7XG4gIGlmIChuZXR3b3JrRXJyKSByZXR1cm4gYFtOZXR3b3JrXSAke25ldHdvcmtFcnIubWVzc2FnZX1gO1xuICBpZiAoZ3JhcGhRbEVycnMpIHtcbiAgICBmb3IgKHZhciBlcnIgb2YgZ3JhcGhRbEVycnMpIHtcbiAgICAgIGlmIChlcnJvcikgZXJyb3IgKz0gJ1xcbic7XG4gICAgICBlcnJvciArPSBgW0dyYXBoUUxdICR7ZXJyLm1lc3NhZ2V9YDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVycm9yO1xufTtcbnZhciByZWh5ZHJhdGVHcmFwaFFsRXJyb3IgPSBlcnJvciA9PiB7XG4gIGlmIChlcnJvciAmJiBlcnJvci5tZXNzYWdlICYmIChlcnJvci5leHRlbnNpb25zIHx8IGVycm9yLm5hbWUgPT09ICdHcmFwaFFMRXJyb3InKSkge1xuICAgIHJldHVybiBlcnJvcjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIGVycm9yLm1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbmV3IGdyYXBocWxfd2ViLkdyYXBoUUxFcnJvcihlcnJvci5tZXNzYWdlLCBlcnJvci5ub2RlcywgZXJyb3Iuc291cmNlLCBlcnJvci5wb3NpdGlvbnMsIGVycm9yLnBhdGgsIGVycm9yLCBlcnJvci5leHRlbnNpb25zIHx8IHt9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IGdyYXBocWxfd2ViLkdyYXBoUUxFcnJvcihlcnJvcik7XG4gIH1cbn07XG5cbi8qKiBBbiBhYnN0cmFjdGVkIGBFcnJvcmAgdGhhdCBwcm92aWRlcyBlaXRoZXIgYSBgbmV0d29ya0Vycm9yYCBvciBgZ3JhcGhRTEVycm9yc2AuXG4gKlxuICogQHJlbWFya3NcbiAqIER1cmluZyBhIEdyYXBoUUwgcmVxdWVzdCwgZWl0aGVyIHRoZSByZXF1ZXN0IGNhbiBmYWlsIGVudGlyZWx5LCBjYXVzaW5nIGEgbmV0d29yayBlcnJvcixcbiAqIG9yIHRoZSBHcmFwaFFMIGV4ZWN1dGlvbiBvciBmaWVsZHMgY2FuIGZhaWwsIHdoaWNoIHdpbGwgY2F1c2UgYW4ge0BsaW5rIEV4ZWN1dGlvblJlc3VsdH1cbiAqIHRvIGNvbnRhaW4gYW4gYXJyYXkgb2YgR3JhcGhRTCBlcnJvcnMuXG4gKlxuICogVGhlIGBDb21iaW5lZEVycm9yYCBhYnN0cmFjdHMgYW5kIG5vcm1hbGl6ZXMgYm90aCBmYWlsdXJlIGNhc2VzLiBXaGVuIHtAbGluayBPcGVyYXRpb25SZXN1bHQuZXJyb3J9XG4gKiBpcyBzZXQgdG8gdGhpcyBlcnJvciwgdGhlIGBDb21iaW5lZEVycm9yYCBhYnN0cmFjdHMgYWxsIGVycm9ycywgbWFraW5nIGl0IGVhc2llciB0byBoYW5kbGUgb25seVxuICogYSBzdWJzZXQgb2YgZXJyb3IgY2FzZXMuXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly91cnFsLmRldi9nb3RvL2RvY3MvYmFzaWNzL2Vycm9yc30gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gaGFuZGxpbmdcbiAqIEdyYXBoUUwgZXJyb3JzIGFuZCB0aGUgYENvbWJpbmVkRXJyb3JgLlxuICovXG5jbGFzcyBDb21iaW5lZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAvKiogQSBsaXN0IG9mIEdyYXBoUUwgZXJyb3JzIHJlaHlkcmF0ZWQgZnJvbSBhIHtAbGluayBFeGVjdXRpb25SZXN1bHR9LlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBJZiBhbiB7QGxpbmsgRXhlY3V0aW9uUmVzdWx0fSByZWNlaXZlZCBmcm9tIHRoZSBBUEkgY29udGFpbnMgYSBsaXN0IG9mIGVycm9ycyxcbiAgICogdGhlIGBDb21iaW5lZEVycm9yYCB3aWxsIHJlaHlkcmF0ZSB0aGVtLCBub3JtYWxpemUgdGhlbSB0b1xuICAgKiB7QGxpbmsgR3JhcGhRTEVycm9yIHwgR3JhcGhRTEVycm9yc30gYW5kIGxpc3QgdGhlbSBoZXJlLlxuICAgKiBBbiBlbXB0eSBsaXN0IGluZGljYXRlcyB0aGF0IG5vIEdyYXBoUUwgZXJyb3IgaGFzIGJlZW4gc2VudCBieSB0aGUgQVBJLlxuICAgKi9cblxuICAvKiogU2V0IHRvIGFuIGVycm9yLCBpZiBhIEdyYXBoUUwgcmVxdWVzdCBoYXMgZmFpbGVkIG91dHJpZ2h0LlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBBIEdyYXBoUUwgb3ZlciBIVFRQIHJlcXVlc3QgbWF5IGZhaWwgYW5kIG5vdCByZWFjaCB0aGUgQVBJLiBBbnkgZXJyb3IgdGhhdFxuICAgKiBwcmV2ZW50cyBhIEdyYXBoUWwgcmVxdWVzdCBvdXRyaWdodCwgd2lsbCBiZSBjb25zaWRlcmVkIGEg4oCcbmV0d29yayBlcnJvcuKAnSBhbmRcbiAgICogc2V0IGhlcmUuXG4gICAqL1xuXG4gIC8qKiBTZXQgdG8gdGhlIHtAbGluayBSZXNwb25zZX0gb2JqZWN0IGEgZmV0Y2ggZXhjaGFuZ2UgcmVjZWl2ZWQuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIElmIGEgYnVpbHQtaW4gZmV0Y2gge0BsaW5rIEV4Y2hhbmdlfSBpcyB1c2VkIGluIGB1cnFsYCwgdGhpcyBtYXlcbiAgICogYmUgc2V0IHRvIHRoZSB7QGxpbmsgUmVzcG9uc2V9IG9iamVjdCBvZiB0aGUgRmV0Y2ggQVBJIHJlc3BvbnNlLlxuICAgKiBIb3dldmVyLCBzaW5jZSBgdXJxbGAgZG9lc27igJl0IGFzc3VtZSB0aGF0IGFsbCB1c2VycyB3aWxsIHVzZSBIVFRQXG4gICAqIGFzIHRoZSBvbmx5IG9yIGV4Y2x1c2l2ZSB0cmFuc3BvcnQgZm9yIEdyYXBoUUwgdGhpcyBwcm9wZXJ0eSBpc1xuICAgKiBuZWl0aGVyIHR5cGVkIG5vciBndWFyYW50ZWVkIGFuZCBtYXkgYmUgcmUtdXNlZCBmb3Igb3RoZXIgcHVycG9zZXNcbiAgICogYnkgbm9uLWZldGNoIGV4Y2hhbmdlcy5cbiAgICpcbiAgICogSGludDogSXQgY2FuIGJlIHVzZWZ1bCB0byB1c2UgYHJlc3BvbnNlLnN0YXR1c2AgaGVyZSwgaG93ZXZlciwgaWZcbiAgICogeW91IHBsYW4gb24gcmVseWluZyBvbiB0aGlzIGJlaW5nIGEge0BsaW5rIFJlc3BvbnNlfSBpbiB5b3VyIGFwcCxcbiAgICogd2hpY2ggaXQgaXMgYnkgZGVmYXVsdCwgdGhlbiBtYWtlIHN1cmUgeW91IGFkZCBzb21lIGV4dHJhIGNoZWNrc1xuICAgKiBiZWZvcmUgYmxpbmRseSBhc3N1bWluZyBzbyFcbiAgICovXG5cbiAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICB2YXIgbm9ybWFsaXplZEdyYXBoUUxFcnJvcnMgPSAoaW5wdXQuZ3JhcGhRTEVycm9ycyB8fCBbXSkubWFwKHJlaHlkcmF0ZUdyYXBoUWxFcnJvcik7XG4gICAgdmFyIG1lc3NhZ2UgPSBnZW5lcmF0ZUVycm9yTWVzc2FnZShpbnB1dC5uZXR3b3JrRXJyb3IsIG5vcm1hbGl6ZWRHcmFwaFFMRXJyb3JzKTtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnQ29tYmluZWRFcnJvcic7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLmdyYXBoUUxFcnJvcnMgPSBub3JtYWxpemVkR3JhcGhRTEVycm9ycztcbiAgICB0aGlzLm5ldHdvcmtFcnJvciA9IGlucHV0Lm5ldHdvcmtFcnJvcjtcbiAgICB0aGlzLnJlc3BvbnNlID0gaW5wdXQucmVzcG9uc2U7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgfVxufVxuXG4vKiogQSBoYXNoIHZhbHVlIGFzIGNvbXB1dGVkIGJ5IHtAbGluayBwaGFzaH0uXG4gKlxuICogQHJlbWFya3NcbiAqIFR5cGljYWxseSBgSGFzaFZhbHVlYHMgYXJlIHVzZWQgYXMgaGFzaGVzIGFuZCBrZXlzIG9mIEdyYXBoUUwgZG9jdW1lbnRzLFxuICogdmFyaWFibGVzLCBhbmQgY29tYmluZWQsIGZvciBHcmFwaFFMIHJlcXVlc3RzLlxuICovXG5cbi8qKiBDb21wdXRlcyBhIGRqYjIgaGFzaCBvZiB0aGUgZ2l2ZW4gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB4IC0gdGhlIHN0cmluZyB0byBiZSBoYXNoZWRcbiAqIEBwYXJhbSBzZWVkIC0gb3B0aW9uYWxseSBhIHByaW9yIGhhc2ggZm9yIHByb2dyZXNzaXZlIGhhc2hpbmdcbiAqIEByZXR1cm5zIGEgaGFzaCB2YWx1ZSwgaS5lLiBhIG51bWJlclxuICpcbiAqIEByZW1hcmtcbiAqIFRoaXMgaXMgdGhlIGhhc2hpbmcgZnVuY3Rpb24gdXNlZCB0aHJvdWdob3V0IGB1cnFsYCwgcHJpbWFyaWx5IHRvIGNvbXB1dGVcbiAqIHtAbGluayBPcGVyYXRpb24ua2V5fS5cbiAqXG4gKiBAc2VlIHtAbGluayBodHRwOi8vd3d3LmNzZS55b3JrdS5jYS9+b3ovaGFzaC5odG1sI2RqYjJ9IGZvciBhIGZ1cnRoZXIgZGVzY3JpcHRpb24gb2YgZGpiMi5cbiAqL1xudmFyIHBoYXNoID0gKHgsIHNlZWQpID0+IHtcbiAgdmFyIGggPSAoc2VlZCB8fCA1MzgxKSB8IDA7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geC5sZW5ndGggfCAwOyBpIDwgbDsgaSsrKSBoID0gKGggPDwgNSkgKyBoICsgeC5jaGFyQ29kZUF0KGkpO1xuICByZXR1cm4gaDtcbn07XG5cbnZhciBzZWVuID0gbmV3IFNldCgpO1xudmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbnZhciBzdHJpbmdpZnkgPSB4ID0+IHtcbiAgaWYgKHggPT09IG51bGwgfHwgc2Vlbi5oYXMoeCkpIHtcbiAgICByZXR1cm4gJ251bGwnO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB4ICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh4KSB8fCAnJztcbiAgfSBlbHNlIGlmICh4LnRvSlNPTikge1xuICAgIHJldHVybiBzdHJpbmdpZnkoeC50b0pTT04oKSk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh4KSkge1xuICAgIHZhciBfb3V0ID0gJ1snO1xuICAgIGZvciAodmFyIHZhbHVlIG9mIHgpIHtcbiAgICAgIGlmIChfb3V0Lmxlbmd0aCA+IDEpIF9vdXQgKz0gJywnO1xuICAgICAgX291dCArPSBzdHJpbmdpZnkodmFsdWUpIHx8ICdudWxsJztcbiAgICB9XG4gICAgX291dCArPSAnXSc7XG4gICAgcmV0dXJuIF9vdXQ7XG4gIH0gZWxzZSBpZiAoRmlsZUNvbnN0cnVjdG9yICE9PSBOb29wQ29uc3RydWN0b3IgJiYgeCBpbnN0YW5jZW9mIEZpbGVDb25zdHJ1Y3RvciB8fCBCbG9iQ29uc3RydWN0b3IgIT09IE5vb3BDb25zdHJ1Y3RvciAmJiB4IGluc3RhbmNlb2YgQmxvYkNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuICdudWxsJztcbiAgfVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHgpLnNvcnQoKTtcbiAgaWYgKCFrZXlzLmxlbmd0aCAmJiB4LmNvbnN0cnVjdG9yICYmIHguY29uc3RydWN0b3IgIT09IE9iamVjdCkge1xuICAgIHZhciBrZXkgPSBjYWNoZS5nZXQoeCkgfHwgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG4gICAgY2FjaGUuc2V0KHgsIGtleSk7XG4gICAgcmV0dXJuIHN0cmluZ2lmeSh7XG4gICAgICBfX2tleToga2V5XG4gICAgfSk7XG4gIH1cbiAgc2Vlbi5hZGQoeCk7XG4gIHZhciBvdXQgPSAneyc7XG4gIGZvciAodmFyIF9rZXkgb2Yga2V5cykge1xuICAgIHZhciBfdmFsdWUgPSBzdHJpbmdpZnkoeFtfa2V5XSk7XG4gICAgaWYgKF92YWx1ZSkge1xuICAgICAgaWYgKG91dC5sZW5ndGggPiAxKSBvdXQgKz0gJywnO1xuICAgICAgb3V0ICs9IHN0cmluZ2lmeShfa2V5KSArICc6JyArIF92YWx1ZTtcbiAgICB9XG4gIH1cbiAgc2Vlbi5kZWxldGUoeCk7XG4gIG91dCArPSAnfSc7XG4gIHJldHVybiBvdXQ7XG59O1xudmFyIGV4dHJhY3QgPSAobWFwLCBwYXRoLCB4KSA9PiB7XG4gIGlmICh4ID09IG51bGwgfHwgdHlwZW9mIHggIT09ICdvYmplY3QnIHx8IHgudG9KU09OIHx8IHNlZW4uaGFzKHgpKSA7IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoeCkpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHgubGVuZ3RoOyBpIDwgbDsgaSsrKSBleHRyYWN0KG1hcCwgYCR7cGF0aH0uJHtpfWAsIHhbaV0pO1xuICB9IGVsc2UgaWYgKHggaW5zdGFuY2VvZiBGaWxlQ29uc3RydWN0b3IgfHwgeCBpbnN0YW5jZW9mIEJsb2JDb25zdHJ1Y3Rvcikge1xuICAgIG1hcC5zZXQocGF0aCwgeCk7XG4gIH0gZWxzZSB7XG4gICAgc2Vlbi5hZGQoeCk7XG4gICAgZm9yICh2YXIga2V5IG9mIE9iamVjdC5rZXlzKHgpKSBleHRyYWN0KG1hcCwgYCR7cGF0aH0uJHtrZXl9YCwgeFtrZXldKTtcbiAgfVxufTtcblxuLyoqIEEgc3RhYmxlIHN0cmluZ2lmaWVyIGZvciBHcmFwaFFMIHZhcmlhYmxlcyBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB4IC0gYW55IEpTT04tbGlrZSBkYXRhLlxuICogQHJldHVybiBBIEpTT04gc3RyaW5nLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIHV0aWxpdHkgY3JlYXRlcyBhIHN0YWJsZSBKU09OIHN0cmluZyBmcm9tIGFueSBwYXNzZWQgZGF0YSxcbiAqIGFuZCBwcm90ZWN0cyBpdHNlbGYgZnJvbSB0aHJvd2luZy5cbiAqXG4gKiBUaGUgSlNPTiBzdHJpbmcgaXMgc3RhYmxlIGluc29mYXIgYXMgb2JqZWN0c+KAmSBrZXlzIGFyZSBzb3J0ZWQsXG4gKiBhbmQgaW5zdGFuY2VzIG9mIG5vbi1wbGFpbiBvYmplY3RzIGFyZSByZXBsYWNlZCB3aXRoIHJhbmRvbSBrZXlzXG4gKiByZXBsYWNpbmcgdGhlaXIgdmFsdWVzLCB3aGljaCByZW1haW4gc3RhYmxlIGZvciB0aGUgb2JqZWN0c+KAmVxuICogaW5zdGFuY2UuXG4gKi9cbnZhciBzdHJpbmdpZnlWYXJpYWJsZXMgPSB4ID0+IHtcbiAgc2Vlbi5jbGVhcigpO1xuICByZXR1cm4gc3RyaW5naWZ5KHgpO1xufTtcbmNsYXNzIE5vb3BDb25zdHJ1Y3RvciB7fVxudmFyIEZpbGVDb25zdHJ1Y3RvciA9IHR5cGVvZiBGaWxlICE9PSAndW5kZWZpbmVkJyA/IEZpbGUgOiBOb29wQ29uc3RydWN0b3I7XG52YXIgQmxvYkNvbnN0cnVjdG9yID0gdHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnID8gQmxvYiA6IE5vb3BDb25zdHJ1Y3RvcjtcbnZhciBleHRyYWN0RmlsZXMgPSB4ID0+IHtcbiAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgaWYgKEZpbGVDb25zdHJ1Y3RvciAhPT0gTm9vcENvbnN0cnVjdG9yIHx8IEJsb2JDb25zdHJ1Y3RvciAhPT0gTm9vcENvbnN0cnVjdG9yKSB7XG4gICAgc2Vlbi5jbGVhcigpO1xuICAgIGV4dHJhY3QobWFwLCAndmFyaWFibGVzJywgeCk7XG4gIH1cbiAgcmV0dXJuIG1hcDtcbn07XG5cbi8qKiBBIGBEb2N1bWVudE5vZGVgIGFubm90YXRlZCB3aXRoIGl0cyBoYXNoZWQga2V5LlxuICogQGludGVybmFsXG4gKi9cblxudmFyIFNPVVJDRV9OQU1FID0gJ2dxbCc7XG52YXIgR1JBUEhRTF9TVFJJTkdfUkUgPSAvKFwiezN9W1xcc1xcU10qXCJ7M318XCIoPzpcXFxcLnxbXlwiXSkqXCIpL2c7XG52YXIgUkVQTEFDRV9DSEFSX1JFID0gLyg/OiNbXlxcblxccl0rKT8oPzpbXFxyXFxuXSt8JCkvZztcbnZhciByZXBsYWNlT3V0c2lkZVN0cmluZ3MgPSAoc3RyLCBpZHgpID0+IGlkeCAlIDIgPT09IDAgPyBzdHIucmVwbGFjZShSRVBMQUNFX0NIQVJfUkUsICdcXG4nKSA6IHN0cjtcblxuLyoqIFNhbml0aXplcyBhIEdyYXBoUUwgZG9jdW1lbnQgc3RyaW5nIGJ5IHJlcGxhY2luZyBjb21tZW50cyBhbmQgcmVkdW5kYW50IG5ld2xpbmVzIGluIGl0LiAqL1xudmFyIHNhbml0aXplRG9jdW1lbnQgPSBub2RlID0+IG5vZGUuc3BsaXQoR1JBUEhRTF9TVFJJTkdfUkUpLm1hcChyZXBsYWNlT3V0c2lkZVN0cmluZ3MpLmpvaW4oJycpLnRyaW0oKTtcbnZhciBwcmludHMgPSBuZXcgTWFwKCk7XG52YXIgZG9jcyA9IG5ldyBNYXAoKTtcblxuLyoqIEEgY2FjaGVkIHByaW50aW5nIGZ1bmN0aW9uIGZvciBHcmFwaFFMIGRvY3VtZW50cy5cbiAqXG4gKiBAcGFyYW0gbm9kZSAtIEEgc3RyaW5nIG9mIGEgZG9jdW1lbnQgb3IgYSB7QGxpbmsgRG9jdW1lbnROb2RlfVxuICogQHJldHVybnMgQSBub3JtYWxpemVkIHByaW50ZWQgc3RyaW5nIG9mIHRoZSBwYXNzZWQgR3JhcGhRTCBkb2N1bWVudC5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGEgR3JhcGhRTCBxdWVyeSBzdHJpbmcgb3Ige0BsaW5rIERvY3VtZW50Tm9kZX0sXG4gKiB0aGVuIHByaW50cyBhbmQgc2FuaXRpemVzIGl0LiBUaGUgc2FuaXRpemVyIHRha2VzIGNhcmUgb2YgcmVtb3ZpbmdcbiAqIGNvbW1lbnRzLCB3aGljaCBvdGhlcndpc2UgYWx0ZXIgdGhlIGtleSBvZiB0aGUgZG9jdW1lbnQgYWx0aG91Z2ggdGhlXG4gKiBkb2N1bWVudCBpcyBvdGhlcndpc2UgZXF1aXZhbGVudCB0byBhbm90aGVyLlxuICpcbiAqIFdoZW4gYSB7QGxpbmsgRG9jdW1lbnROb2RlfSBpcyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiwgaXQgY2FjaGVzIGl0c1xuICogb3V0cHV0IGJ5IG1vZGlmeWluZyB0aGUgYGxvYy5zb3VyY2UuYm9keWAgcHJvcGVydHkgb24gdGhlIEdyYXBoUUwgbm9kZS5cbiAqL1xudmFyIHN0cmluZ2lmeURvY3VtZW50ID0gbm9kZSA9PiB7XG4gIHZhciBwcmludGVkO1xuICBpZiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcHJpbnRlZCA9IHNhbml0aXplRG9jdW1lbnQobm9kZSk7XG4gIH0gZWxzZSBpZiAobm9kZS5sb2MgJiYgZG9jcy5nZXQobm9kZS5fX2tleSkgPT09IG5vZGUpIHtcbiAgICBwcmludGVkID0gbm9kZS5sb2Muc291cmNlLmJvZHk7XG4gIH0gZWxzZSB7XG4gICAgcHJpbnRlZCA9IHByaW50cy5nZXQobm9kZSkgfHwgc2FuaXRpemVEb2N1bWVudChncmFwaHFsX3dlYi5wcmludChub2RlKSk7XG4gICAgcHJpbnRzLnNldChub2RlLCBwcmludGVkKTtcbiAgfVxuICBpZiAodHlwZW9mIG5vZGUgIT09ICdzdHJpbmcnICYmICFub2RlLmxvYykge1xuICAgIG5vZGUubG9jID0ge1xuICAgICAgc3RhcnQ6IDAsXG4gICAgICBlbmQ6IHByaW50ZWQubGVuZ3RoLFxuICAgICAgc291cmNlOiB7XG4gICAgICAgIGJvZHk6IHByaW50ZWQsXG4gICAgICAgIG5hbWU6IFNPVVJDRV9OQU1FLFxuICAgICAgICBsb2NhdGlvbk9mZnNldDoge1xuICAgICAgICAgIGxpbmU6IDEsXG4gICAgICAgICAgY29sdW1uOiAxXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiBwcmludGVkO1xufTtcblxuLyoqIENvbXB1dGVzIHRoZSBoYXNoIGZvciBhIGRvY3VtZW50J3Mgc3RyaW5nIHVzaW5nIHtAbGluayBzdHJpbmdpZnlEb2N1bWVudH0ncyBvdXRwdXQuXG4gKlxuICogQHBhcmFtIG5vZGUgLSBBIHN0cmluZyBvZiBhIGRvY3VtZW50IG9yIGEge0BsaW5rIERvY3VtZW50Tm9kZX1cbiAqIEByZXR1cm5zIEEge0BsaW5rIEhhc2hWYWx1ZX1cbiAqXG4gKiBAcHJpdmF0ZVJlbWFya3NcbiAqIFRoaXMgZnVuY3Rpb24gYWRkcyB0aGUgb3BlcmF0aW9uIG5hbWUgb2YgdGhlIGRvY3VtZW50IHRvIHRoZSBoYXNoLCBzaW5jZSBzb21ldGltZXNcbiAqIGEgbWVyZ2VkIGRvY3VtZW50IHdpdGggbXVsdGlwbGUgb3BlcmF0aW9ucyBtYXkgYmUgdXNlZC4gQWx0aG91Z2ggYHVycWxgIHJlcXVpcmVzIGFcbiAqIGBEb2N1bWVudE5vZGVgIHRvIG9ubHkgY29udGFpbiBhIHNpbmdsZSBvcGVyYXRpb24sIHdoZW4gdGhlIGNhY2hlZCBgbG9jLnNvdXJjZS5ib2R5YFxuICogb2YgYSBgRG9jdW1lbnROb2RlYCBpcyB1c2VkLCB0aGlzIHN0cmluZyBtYXkgc3RpbGwgY29udGFpbiBtdWx0aXBsZSBvcGVyYXRpb25zIGFuZFxuICogdGhlIHJlc3VsdGluZyBoYXNoIHNob3VsZCBhY2NvdW50IGZvciBvbmx5IG9uZSBhdCBhIHRpbWUuXG4gKi9cbnZhciBoYXNoRG9jdW1lbnQgPSBub2RlID0+IHtcbiAgdmFyIGtleSA9IHBoYXNoKHN0cmluZ2lmeURvY3VtZW50KG5vZGUpKTtcbiAgLy8gQWRkIHRoZSBvcGVyYXRpb24gbmFtZSB0byB0aGUgcHJvZHVjZWQgaGFzaFxuICBpZiAobm9kZS5kZWZpbml0aW9ucykge1xuICAgIHZhciBvcGVyYXRpb25OYW1lID0gZ2V0T3BlcmF0aW9uTmFtZShub2RlKTtcbiAgICBpZiAob3BlcmF0aW9uTmFtZSkga2V5ID0gcGhhc2goYFxcbiMgJHtvcGVyYXRpb25OYW1lfWAsIGtleSk7XG4gIH1cbiAgcmV0dXJuIGtleTtcbn07XG5cbi8qKiBSZXR1cm5zIGEgY2Fub25pY2FsIHZlcnNpb24gb2YgdGhlIHBhc3NlZCBgRG9jdW1lbnROb2RlYCB3aXRoIGFuIGFkZGVkIGhhc2gga2V5LlxuICpcbiAqIEBwYXJhbSBub2RlIC0gQSBzdHJpbmcgb2YgYSBkb2N1bWVudCBvciBhIHtAbGluayBEb2N1bWVudE5vZGV9XG4gKiBAcmV0dXJucyBBIHtAbGluayBLZXllZERvY3VtZW50Tm9kZX1cbiAqXG4gKiBAcmVtYXJrc1xuICogYHVycWxgIHdpbGwgYWx3YXlzIGF2b2lkIHVubmVjZXNzYXJ5IHdvcmssIG5vIG1hdHRlciB3aGV0aGVyIGEgdXNlciBwYXNzZXMgYERvY3VtZW50Tm9kZWBzXG4gKiBvciBzdHJpbmdzIG9mIEdyYXBoUUwgZG9jdW1lbnRzIHRvIGl0cyBBUElzLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gYSBjYW5vbmljYWwgdmVyc2lvbiBvZiBhIHtAbGluayBLZXllZERvY3VtZW50Tm9kZX0gbm8gbWF0dGVyXG4gKiB3aGljaCBraW5kIG9mIGlucHV0IGlzIHBhc3NlZCwgYXZvaWRpbmcgcGFyc2luZyBvciBoYXNoaW5nIG9mIHBhc3NlZCBkYXRhIGFzIG5lZWRlZC5cbiAqL1xudmFyIGtleURvY3VtZW50ID0gbm9kZSA9PiB7XG4gIHZhciBrZXk7XG4gIHZhciBxdWVyeTtcbiAgaWYgKHR5cGVvZiBub2RlID09PSAnc3RyaW5nJykge1xuICAgIGtleSA9IGhhc2hEb2N1bWVudChub2RlKTtcbiAgICBxdWVyeSA9IGRvY3MuZ2V0KGtleSkgfHwgZ3JhcGhxbF93ZWIucGFyc2Uobm9kZSwge1xuICAgICAgbm9Mb2NhdGlvbjogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGtleSA9IG5vZGUuX19rZXkgfHwgaGFzaERvY3VtZW50KG5vZGUpO1xuICAgIHF1ZXJ5ID0gZG9jcy5nZXQoa2V5KSB8fCBub2RlO1xuICB9XG5cbiAgLy8gQWRkIGxvY2F0aW9uIGluZm9ybWF0aW9uIGlmIGl0J3MgbWlzc2luZ1xuICBpZiAoIXF1ZXJ5LmxvYykgc3RyaW5naWZ5RG9jdW1lbnQocXVlcnkpO1xuICBxdWVyeS5fX2tleSA9IGtleTtcbiAgZG9jcy5zZXQoa2V5LCBxdWVyeSk7XG4gIHJldHVybiBxdWVyeTtcbn07XG5cbi8qKiBDcmVhdGVzIGEgYEdyYXBoUUxSZXF1ZXN0YCBmcm9tIHRoZSBwYXNzZWQgcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0gcSAtIEEgc3RyaW5nIG9mIGEgZG9jdW1lbnQgb3IgYSB7QGxpbmsgRG9jdW1lbnROb2RlfVxuICogQHBhcmFtIHZhcmlhYmxlcyAtIEEgdmFyaWFibGVzIG9iamVjdCBmb3IgdGhlIGRlZmluZWQgR3JhcGhRTCBvcGVyYXRpb24uXG4gKiBAcmV0dXJucyBBIHtAbGluayBHcmFwaFFMUmVxdWVzdH1cbiAqXG4gKiBAcmVtYXJrc1xuICogYGNyZWF0ZVJlcXVlc3RgIGNyZWF0ZXMgYSB7QGxpbmsgR3JhcGhRTFJlcXVlc3R9IGZyb20gdGhlIHBhc3NlZCBwYXJhbWV0ZXJzLFxuICogd2hpbGUgcmVwbGFjaW5nIHRoZSBkb2N1bWVudCBhcyBuZWVkZWQgd2l0aCBhIGNhbm9uaWNhbCB2ZXJzaW9uIG9mIGl0c2VsZixcbiAqIHRvIGF2b2lkIHBhcnNpbmcsIHByaW50aW5nLCBvciBoYXNoaW5nIHRoZSBzYW1lIGlucHV0IG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIElmIG5vIHZhcmlhYmxlcyBhcmUgcGFzc2VkLCBjYW5vbmljYWxseSBpdCdsbCBkZWZhdWx0IHRvIGFuIGVtcHR5IG9iamVjdCxcbiAqIHdoaWNoIGlzIHJlbW92ZWQgZnJvbSB0aGUgcmVzdWx0aW5nIGhhc2gga2V5LlxuICovXG52YXIgY3JlYXRlUmVxdWVzdCA9IChfcXVlcnksIF92YXJpYWJsZXMsIGV4dGVuc2lvbnMpID0+IHtcbiAgdmFyIHZhcmlhYmxlcyA9IF92YXJpYWJsZXMgfHwge307XG4gIHZhciBxdWVyeSA9IGtleURvY3VtZW50KF9xdWVyeSk7XG4gIHZhciBwcmludGVkVmFycyA9IHN0cmluZ2lmeVZhcmlhYmxlcyh2YXJpYWJsZXMpO1xuICB2YXIga2V5ID0gcXVlcnkuX19rZXk7XG4gIGlmIChwcmludGVkVmFycyAhPT0gJ3t9Jykga2V5ID0gcGhhc2gocHJpbnRlZFZhcnMsIGtleSk7XG4gIHJldHVybiB7XG4gICAga2V5LFxuICAgIHF1ZXJ5LFxuICAgIHZhcmlhYmxlcyxcbiAgICBleHRlbnNpb25zXG4gIH07XG59O1xuXG4vKiogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgYERvY3VtZW50Tm9kZWAncyBvcGVyYXRpb24sIGlmIGFueS5cbiAqIEBwYXJhbSBxdWVyeSAtIEEge0BsaW5rIERvY3VtZW50Tm9kZX1cbiAqIEByZXR1cm5zIHRoZSBvcGVyYXRpb24ncyBuYW1lIGNvbnRhaW5lZCB3aXRoaW4gdGhlIGRvY3VtZW50LCBvciBgdW5kZWZpbmVkYFxuICovXG52YXIgZ2V0T3BlcmF0aW9uTmFtZSA9IHF1ZXJ5ID0+IHtcbiAgZm9yICh2YXIgbm9kZSBvZiBxdWVyeS5kZWZpbml0aW9ucykge1xuICAgIGlmIChub2RlLmtpbmQgPT09IGdyYXBocWxfd2ViLktpbmQuT1BFUkFUSU9OX0RFRklOSVRJT04pIHtcbiAgICAgIHJldHVybiBub2RlLm5hbWUgPyBub2RlLm5hbWUudmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59O1xuXG4vKiogUmV0dXJucyB0aGUgdHlwZSBvZiB0aGUgYERvY3VtZW50Tm9kZWAncyBvcGVyYXRpb24sIGlmIGFueS5cbiAqIEBwYXJhbSBxdWVyeSAtIEEge0BsaW5rIERvY3VtZW50Tm9kZX1cbiAqIEByZXR1cm5zIHRoZSBvcGVyYXRpb24ncyB0eXBlIGNvbnRhaW5lZCB3aXRoaW4gdGhlIGRvY3VtZW50LCBvciBgdW5kZWZpbmVkYFxuICovXG52YXIgZ2V0T3BlcmF0aW9uVHlwZSA9IHF1ZXJ5ID0+IHtcbiAgZm9yICh2YXIgbm9kZSBvZiBxdWVyeS5kZWZpbml0aW9ucykge1xuICAgIGlmIChub2RlLmtpbmQgPT09IGdyYXBocWxfd2ViLktpbmQuT1BFUkFUSU9OX0RFRklOSVRJT04pIHtcbiAgICAgIHJldHVybiBub2RlLm9wZXJhdGlvbjtcbiAgICB9XG4gIH1cbn07XG5cbi8qKiBDb252ZXJ0cyB0aGUgYEV4ZWN1dGlvblJlc3VsdGAgcmVjZWl2ZWQgZm9yIGEgZ2l2ZW4gYE9wZXJhdGlvbmAgdG8gYW4gYE9wZXJhdGlvblJlc3VsdGAuXG4gKlxuICogQHBhcmFtIG9wZXJhdGlvbiAtIFRoZSB7QGxpbmsgT3BlcmF0aW9ufSBmb3Igd2hpY2ggdGhlIEFQSeKAmXMgcmVzdWx0IGlzIGZvci5cbiAqIEBwYXJhbSByZXN1bHQgLSBUaGUgR3JhcGhRTCBBUEnigJlzIHtAbGluayBFeGVjdXRpb25SZXN1bHR9LlxuICogQHBhcmFtIHJlc3BvbnNlIC0gT3B0aW9uYWxseSwgYSByYXcgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgQVBJ4oCZcyByZXN1bHQgKFR5cGljYWxseSBhIHtAbGluayBSZXNwb25zZX0pLlxuICogQHJldHVybnMgQW4ge0BsaW5rIE9wZXJhdGlvblJlc3VsdH0uXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgdXRpbGl0eSBjYW4gYmUgdXNlZCB0byBjcmVhdGUge0BsaW5rIE9wZXJhdGlvblJlc3VsdCB8IE9wZXJhdGlvblJlc3VsdHN9IGluIHRoZSBzaGFwZVxuICogdGhhdCBgdXJxbGAgZXhwZWN0cyBhbmQgZGVmaW5lcywgYW5kIHNob3VsZCBiZSB1c2VkIHJhdGhlciB0aGFuIGNyZWF0aW5nIHRoZSByZXN1bHRzIG1hbnVhbGx5LlxuICpcbiAqIEB0aHJvd3NcbiAqIElmIG5vIGRhdGEsIG9yIGVycm9ycyBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGUgcmVzdWx0LCBvciB0aGUgcmVzdWx0IGlzIGluc3RlYWQgYW4gaW5jcmVtZW50YWxcbiAqIHJlc3BvbnNlIGNvbnRhaW5pbmcgYSBgcGF0aGAgcHJvcGVydHksIGEg4oCcTm8gQ29udGVudOKAnSBlcnJvciBpcyB0aHJvd24uXG4gKlxuICogQHNlZSB7QGxpbmsgRXhlY3V0aW9uUmVzdWx0fSBmb3IgdGhlIHR5cGUgZGVmaW5pdGlvbiBvZiBHcmFwaFFMIEFQSSByZXN1bHRzLlxuICovXG52YXIgbWFrZVJlc3VsdCA9IChvcGVyYXRpb24sIHJlc3VsdCwgcmVzcG9uc2UpID0+IHtcbiAgaWYgKCEoJ2RhdGEnIGluIHJlc3VsdCkgJiYgISgnZXJyb3JzJyBpbiByZXN1bHQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBDb250ZW50Jyk7XG4gIH1cbiAgdmFyIGRlZmF1bHRIYXNOZXh0ID0gb3BlcmF0aW9uLmtpbmQgPT09ICdzdWJzY3JpcHRpb24nO1xuICByZXR1cm4ge1xuICAgIG9wZXJhdGlvbixcbiAgICBkYXRhOiByZXN1bHQuZGF0YSxcbiAgICBlcnJvcjogQXJyYXkuaXNBcnJheShyZXN1bHQuZXJyb3JzKSA/IG5ldyBDb21iaW5lZEVycm9yKHtcbiAgICAgIGdyYXBoUUxFcnJvcnM6IHJlc3VsdC5lcnJvcnMsXG4gICAgICByZXNwb25zZVxuICAgIH0pIDogdW5kZWZpbmVkLFxuICAgIGV4dGVuc2lvbnM6IHJlc3VsdC5leHRlbnNpb25zID8ge1xuICAgICAgLi4ucmVzdWx0LmV4dGVuc2lvbnNcbiAgICB9IDogdW5kZWZpbmVkLFxuICAgIGhhc05leHQ6IHJlc3VsdC5oYXNOZXh0ID09IG51bGwgPyBkZWZhdWx0SGFzTmV4dCA6IHJlc3VsdC5oYXNOZXh0LFxuICAgIHN0YWxlOiBmYWxzZVxuICB9O1xufTtcbnZhciBkZWVwTWVyZ2UgPSAodGFyZ2V0LCBzb3VyY2UpID0+IHtcbiAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnICYmIHRhcmdldCAhPSBudWxsKSB7XG4gICAgaWYgKCF0YXJnZXQuY29uc3RydWN0b3IgfHwgdGFyZ2V0LmNvbnN0cnVjdG9yID09PSBPYmplY3QgfHwgQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICB0YXJnZXQgPSBBcnJheS5pc0FycmF5KHRhcmdldCkgPyBbLi4udGFyZ2V0XSA6IHtcbiAgICAgICAgLi4udGFyZ2V0XG4gICAgICB9O1xuICAgICAgZm9yICh2YXIga2V5IG9mIE9iamVjdC5rZXlzKHNvdXJjZSkpIHRhcmdldFtrZXldID0gZGVlcE1lcmdlKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSk7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gc291cmNlO1xufTtcblxuLyoqIE1lcmdlcyBhbiBpbmNyZW1lbnRhbGx5IGRlbGl2ZXJlZCBgRXhlY3V0aW9uUmVzdWx0YCBpbnRvIGEgcHJldmlvdXMgYE9wZXJhdGlvblJlc3VsdGAuXG4gKlxuICogQHBhcmFtIHByZXZSZXN1bHQgLSBUaGUge0BsaW5rIE9wZXJhdGlvblJlc3VsdH0gdGhhdCBwcmVjZWRlZCB0aGlzIHJlc3VsdC5cbiAqIEBwYXJhbSBwYXRoIC0gVGhlIEdyYXBoUUwgQVBJ4oCZcyB7QGxpbmsgRXhlY3V0aW9uUmVzdWx0fSB0aGF0IHNob3VsZCBiZSBwYXRjaGluZyB0aGUgYHByZXZSZXN1bHRgLlxuICogQHBhcmFtIHJlc3BvbnNlIC0gT3B0aW9uYWxseSwgYSByYXcgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgQVBJ4oCZcyByZXN1bHQgKFR5cGljYWxseSBhIHtAbGluayBSZXNwb25zZX0pLlxuICogQHJldHVybnMgQSBuZXcge0BsaW5rIE9wZXJhdGlvblJlc3VsdH0gcGF0Y2hlZCB3aXRoIHRoZSBpbmNyZW1lbnRhbCByZXN1bHQuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgdXRpbGl0eSBzaG91bGQgYmUgdXNlZCB0byBtZXJnZSBzdWJzZXF1ZW50IHtAbGluayBFeGVjdXRpb25SZXN1bHQgfCBFeGVjdXRpb25SZXN1bHRzfSBvZlxuICogaW5jcmVtZW50YWwgcmVzcG9uc2VzIGludG8gYSBwcmlvciB7QGxpbmsgT3BlcmF0aW9uUmVzdWx0fS5cbiAqXG4gKiBXaGVuIGRpcmVjdGl2ZXMgbGlrZSBgQGRlZmVyYCwgYEBzdHJlYW1gLCBhbmQgYEBsaXZlYCBhcmUgdXNlZCwgR3JhcGhRTCBtYXkgZGVsaXZlciBuZXdcbiAqIHJlc3VsdHMgdGhhdCBtb2RpZnkgcHJldmlvdXMgcmVzdWx0cy4gSW4gdGhlc2UgY2FzZXMsIGl0J2xsIHNldCBhIGBwYXRoYCBwcm9wZXJ0eSB0byBtb2RpZnlcbiAqIHRoZSByZXN1bHQgaXQgc2VudCBsYXN0LiBUaGlzIHV0aWxpdHkgaXMgYnVpbHQgdG8gaGFuZGxlIHRoZXNlIGNhc2VzIGFuZCBtZXJnZSB0aGVzZSBwYXlsb2Fkc1xuICogaW50byBleGlzdGluZyB7QGxpbmsgT3BlcmF0aW9uUmVzdWx0IHwgT3BlcmF0aW9uUmVzdWx0c30uXG4gKlxuICogQHNlZSB7QGxpbmsgRXhlY3V0aW9uUmVzdWx0fSBmb3IgdGhlIHR5cGUgZGVmaW5pdGlvbiBvZiBHcmFwaFFMIEFQSSByZXN1bHRzLlxuICovXG52YXIgbWVyZ2VSZXN1bHRQYXRjaCA9IChwcmV2UmVzdWx0LCBuZXh0UmVzdWx0LCByZXNwb25zZSkgPT4ge1xuICB2YXIgZXJyb3JzID0gcHJldlJlc3VsdC5lcnJvciA/IHByZXZSZXN1bHQuZXJyb3IuZ3JhcGhRTEVycm9ycyA6IFtdO1xuICB2YXIgaGFzRXh0ZW5zaW9ucyA9ICEhcHJldlJlc3VsdC5leHRlbnNpb25zIHx8ICEhbmV4dFJlc3VsdC5leHRlbnNpb25zO1xuICB2YXIgZXh0ZW5zaW9ucyA9IHtcbiAgICAuLi5wcmV2UmVzdWx0LmV4dGVuc2lvbnMsXG4gICAgLi4ubmV4dFJlc3VsdC5leHRlbnNpb25zXG4gIH07XG4gIHZhciBpbmNyZW1lbnRhbCA9IG5leHRSZXN1bHQuaW5jcmVtZW50YWw7XG5cbiAgLy8gTk9URTogV2UgaGFuZGxlIHRoZSBvbGQgdmVyc2lvbiBvZiB0aGUgaW5jcmVtZW50YWwgZGVsaXZlcnkgcGF5bG9hZHMgYXMgd2VsbFxuICBpZiAoJ3BhdGgnIGluIG5leHRSZXN1bHQpIHtcbiAgICBpbmNyZW1lbnRhbCA9IFtuZXh0UmVzdWx0XTtcbiAgfVxuICB2YXIgd2l0aERhdGEgPSB7XG4gICAgZGF0YTogcHJldlJlc3VsdC5kYXRhXG4gIH07XG4gIGlmIChpbmNyZW1lbnRhbCkge1xuICAgIGZvciAodmFyIHBhdGNoIG9mIGluY3JlbWVudGFsKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXRjaC5lcnJvcnMpKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKC4uLnBhdGNoLmVycm9ycyk7XG4gICAgICB9XG4gICAgICBpZiAocGF0Y2guZXh0ZW5zaW9ucykge1xuICAgICAgICBPYmplY3QuYXNzaWduKGV4dGVuc2lvbnMsIHBhdGNoLmV4dGVuc2lvbnMpO1xuICAgICAgICBoYXNFeHRlbnNpb25zID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wID0gJ2RhdGEnO1xuICAgICAgdmFyIHBhcnQgPSB3aXRoRGF0YTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcGF0Y2gucGF0aC5sZW5ndGg7IGkgPCBsOyBwcm9wID0gcGF0Y2gucGF0aFtpKytdKSB7XG4gICAgICAgIHBhcnQgPSBwYXJ0W3Byb3BdID0gQXJyYXkuaXNBcnJheShwYXJ0W3Byb3BdKSA/IFsuLi5wYXJ0W3Byb3BdXSA6IHtcbiAgICAgICAgICAuLi5wYXJ0W3Byb3BdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAocGF0Y2guaXRlbXMpIHtcbiAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSArcHJvcCA+PSAwID8gcHJvcCA6IDA7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2wgPSBwYXRjaC5pdGVtcy5sZW5ndGg7IF9pIDwgX2w7IF9pKyspIHBhcnRbc3RhcnRJbmRleCArIF9pXSA9IGRlZXBNZXJnZShwYXJ0W3N0YXJ0SW5kZXggKyBfaV0sIHBhdGNoLml0ZW1zW19pXSk7XG4gICAgICB9IGVsc2UgaWYgKHBhdGNoLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJ0W3Byb3BdID0gZGVlcE1lcmdlKHBhcnRbcHJvcF0sIHBhdGNoLmRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3aXRoRGF0YS5kYXRhID0gbmV4dFJlc3VsdC5kYXRhIHx8IHByZXZSZXN1bHQuZGF0YTtcbiAgICBlcnJvcnMgPSBuZXh0UmVzdWx0LmVycm9ycyB8fCBlcnJvcnM7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBvcGVyYXRpb246IHByZXZSZXN1bHQub3BlcmF0aW9uLFxuICAgIGRhdGE6IHdpdGhEYXRhLmRhdGEsXG4gICAgZXJyb3I6IGVycm9ycy5sZW5ndGggPyBuZXcgQ29tYmluZWRFcnJvcih7XG4gICAgICBncmFwaFFMRXJyb3JzOiBlcnJvcnMsXG4gICAgICByZXNwb25zZVxuICAgIH0pIDogdW5kZWZpbmVkLFxuICAgIGV4dGVuc2lvbnM6IGhhc0V4dGVuc2lvbnMgPyBleHRlbnNpb25zIDogdW5kZWZpbmVkLFxuICAgIGhhc05leHQ6IG5leHRSZXN1bHQuaGFzTmV4dCAhPSBudWxsID8gbmV4dFJlc3VsdC5oYXNOZXh0IDogcHJldlJlc3VsdC5oYXNOZXh0LFxuICAgIHN0YWxlOiBmYWxzZVxuICB9O1xufTtcblxuLyoqIENyZWF0ZXMgYW4gYE9wZXJhdGlvblJlc3VsdGAgY29udGFpbmluZyBhIG5ldHdvcmsgZXJyb3IgZm9yIHJlcXVlc3RzIHRoYXQgZW5jb3VudGVyZWQgdW5leHBlY3RlZCBlcnJvcnMuXG4gKlxuICogQHBhcmFtIG9wZXJhdGlvbiAtIFRoZSB7QGxpbmsgT3BlcmF0aW9ufSBmb3Igd2hpY2ggdGhlIEFQSeKAmXMgcmVzdWx0IGlzIGZvci5cbiAqIEBwYXJhbSBlcnJvciAtIFRoZSBuZXR3b3JrLWxpa2UgZXJyb3IgdGhhdCBwcmV2ZW50ZWQgYW4gQVBJIHJlc3VsdCBmcm9tIGJlaW5nIGRlbGl2ZXJlZC5cbiAqIEBwYXJhbSByZXNwb25zZSAtIE9wdGlvbmFsbHksIGEgcmF3IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIEFQSeKAmXMgcmVzdWx0IChUeXBpY2FsbHkgYSB7QGxpbmsgUmVzcG9uc2V9KS5cbiAqIEByZXR1cm5zIEFuIHtAbGluayBPcGVyYXRpb25SZXN1bHR9IGNvbnRhaW5pbmcgb25seSBhIHtAbGluayBDb21iaW5lZEVycm9yfS5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyB1dGlsaXR5IGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSB7QGxpbmsgT3BlcmF0aW9uUmVzdWx0IHwgT3BlcmF0aW9uUmVzdWx0c30gaW4gdGhlIHNoYXBlXG4gKiB0aGF0IGB1cnFsYCBleHBlY3RzIGFuZCBkZWZpbmVzLCBhbmQgc2hvdWxkIGJlIHVzZWQgcmF0aGVyIHRoYW4gY3JlYXRpbmcgdGhlIHJlc3VsdHMgbWFudWFsbHkuXG4gKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSB1c2VkIGZvciB3aGVuIHRoZSB7QGxpbmsgQ29tYmluZWRFcnJvci5uZXR3b3JrRXJyb3J9IHByb3BlcnR5IGlzXG4gKiBwb3B1bGF0ZWQgYW5kIG5vIEdyYXBoUUwgZXhlY3V0aW9uIGFjdHVhbGx5IG9jY3VycmVkLlxuICovXG52YXIgbWFrZUVycm9yUmVzdWx0ID0gKG9wZXJhdGlvbiwgZXJyb3IsIHJlc3BvbnNlKSA9PiAoe1xuICBvcGVyYXRpb24sXG4gIGRhdGE6IHVuZGVmaW5lZCxcbiAgZXJyb3I6IG5ldyBDb21iaW5lZEVycm9yKHtcbiAgICBuZXR3b3JrRXJyb3I6IGVycm9yLFxuICAgIHJlc3BvbnNlXG4gIH0pLFxuICBleHRlbnNpb25zOiB1bmRlZmluZWQsXG4gIGhhc05leHQ6IGZhbHNlLFxuICBzdGFsZTogZmFsc2Vcbn0pO1xuXG4vKiogQWJzdHJhY3QgZGVmaW5pdGlvbiBvZiB0aGUgSlNPTiBkYXRhIHNlbnQgZHVyaW5nIEdyYXBoUUwgSFRUUCBQT1NUIHJlcXVlc3RzLiAqL1xuXG4vKiogQ3JlYXRlcyBhIEdyYXBoUUwgb3ZlciBIVFRQIGNvbXBsaWFudCBKU09OIHJlcXVlc3QgYm9keS5cbiAqIEBwYXJhbSByZXF1ZXN0IC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgYSBgcXVlcnlgIGRvY3VtZW50IGFuZCBgdmFyaWFibGVzYC5cbiAqIEByZXR1cm5zIEEge0BsaW5rIEZldGNoQm9keX1cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmFwaHFsL2dyYXBocWwtb3Zlci1odHRwfSBmb3IgdGhlIEdyYXBoUUwgb3ZlciBIVFRQIHNwZWMuXG4gKi9cbmZ1bmN0aW9uIG1ha2VGZXRjaEJvZHkocmVxdWVzdCkge1xuICB2YXIgaXNBUFEgPSByZXF1ZXN0LmV4dGVuc2lvbnMgJiYgcmVxdWVzdC5leHRlbnNpb25zLnBlcnNpc3RlZFF1ZXJ5ICYmICFyZXF1ZXN0LmV4dGVuc2lvbnMucGVyc2lzdGVkUXVlcnkubWlzcztcbiAgcmV0dXJuIHtcbiAgICBxdWVyeTogaXNBUFEgPyB1bmRlZmluZWQgOiBzdHJpbmdpZnlEb2N1bWVudChyZXF1ZXN0LnF1ZXJ5KSxcbiAgICBvcGVyYXRpb25OYW1lOiBnZXRPcGVyYXRpb25OYW1lKHJlcXVlc3QucXVlcnkpLFxuICAgIHZhcmlhYmxlczogcmVxdWVzdC52YXJpYWJsZXMgfHwgdW5kZWZpbmVkLFxuICAgIGV4dGVuc2lvbnM6IHJlcXVlc3QuZXh0ZW5zaW9uc1xuICB9O1xufVxuXG4vKiogQ3JlYXRlcyBhIFVSTCB0aGF0IHdpbGwgYmUgY2FsbGVkIGZvciBhIEdyYXBoUUwgSFRUUCByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSBvcGVyYXRpb24gLSBBbiB7QGxpbmsgT3BlcmF0aW9ufSBmb3Igd2hpY2ggdG8gbWFrZSB0aGUgcmVxdWVzdC5cbiAqIEBwYXJhbSBib2R5IC0gQSB7QGxpbmsgRmV0Y2hCb2R5fSB3aGljaCBtYXkgYmUgcmVwbGFjZWQgd2l0aCBhIFVSTC5cbiAqXG4gKiBAcmVtYXJrc1xuICogQ3JlYXRlcyB0aGUgVVJMIHRoYXTigJlsbCBiZSBjYWxsZWQgYXMgcGFydCBvZiBhIEdyYXBoUUwgSFRUUCByZXF1ZXN0LlxuICogQnVpbHQtaW4gZmV0Y2ggZXhjaGFuZ2VzIHN1cHBvcnQgc2VuZGluZyBHRVQgcmVxdWVzdHMsIGV2ZW4gZm9yXG4gKiBub24tcGVyc2lzdGVkIGZ1bGwgcmVxdWVzdHMsIHdoaWNoIHRoaXMgZnVuY3Rpb24gc3VwcG9ydHMgYnkgYmVpbmdcbiAqIGFibGUgdG8gc2VyaWFsaXplIEdyYXBoUUwgcmVxdWVzdHMgaW50byB0aGUgVVJMLlxuICovXG52YXIgbWFrZUZldGNoVVJMID0gKG9wZXJhdGlvbiwgYm9keSkgPT4ge1xuICB2YXIgdXNlR0VUTWV0aG9kID0gb3BlcmF0aW9uLmtpbmQgPT09ICdxdWVyeScgJiYgb3BlcmF0aW9uLmNvbnRleHQucHJlZmVyR2V0TWV0aG9kO1xuICBpZiAoIXVzZUdFVE1ldGhvZCB8fCAhYm9keSkgcmV0dXJuIG9wZXJhdGlvbi5jb250ZXh0LnVybDtcbiAgdmFyIHVybCA9IG5ldyBVUkwob3BlcmF0aW9uLmNvbnRleHQudXJsKTtcbiAgZm9yICh2YXIga2V5IGluIGJvZHkpIHtcbiAgICB2YXIgdmFsdWUgPSBib2R5W2tleV07XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChrZXksIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgPyBzdHJpbmdpZnlWYXJpYWJsZXModmFsdWUpIDogdmFsdWUpO1xuICAgIH1cbiAgfVxuICB2YXIgZmluYWxVcmwgPSB1cmwudG9TdHJpbmcoKTtcbiAgaWYgKGZpbmFsVXJsLmxlbmd0aCA+IDIwNDcgJiYgdXNlR0VUTWV0aG9kICE9PSAnZm9yY2UnKSB7XG4gICAgb3BlcmF0aW9uLmNvbnRleHQucHJlZmVyR2V0TWV0aG9kID0gZmFsc2U7XG4gICAgcmV0dXJuIG9wZXJhdGlvbi5jb250ZXh0LnVybDtcbiAgfVxuICByZXR1cm4gZmluYWxVcmw7XG59O1xuXG4vKiogU2VyaWFsaXplcyBhIHtAbGluayBGZXRjaEJvZHl9IGludG8gYSB7QGxpbmsgUmVxdWVzdEluaXQuYm9keX0gZm9ybWF0LiAqL1xudmFyIHNlcmlhbGl6ZUJvZHkgPSAob3BlcmF0aW9uLCBib2R5KSA9PiB7XG4gIHZhciBvbWl0Qm9keSA9IG9wZXJhdGlvbi5raW5kID09PSAncXVlcnknICYmICEhb3BlcmF0aW9uLmNvbnRleHQucHJlZmVyR2V0TWV0aG9kO1xuICBpZiAoYm9keSAmJiAhb21pdEJvZHkpIHtcbiAgICB2YXIganNvbiA9IHN0cmluZ2lmeVZhcmlhYmxlcyhib2R5KTtcbiAgICB2YXIgZmlsZXMgPSBleHRyYWN0RmlsZXMoYm9keS52YXJpYWJsZXMpO1xuICAgIGlmIChmaWxlcy5zaXplKSB7XG4gICAgICB2YXIgZm9ybSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgZm9ybS5hcHBlbmQoJ29wZXJhdGlvbnMnLCBqc29uKTtcbiAgICAgIGZvcm0uYXBwZW5kKCdtYXAnLCBzdHJpbmdpZnlWYXJpYWJsZXMoe1xuICAgICAgICAuLi5bLi4uZmlsZXMua2V5cygpXS5tYXAodmFsdWUgPT4gW3ZhbHVlXSlcbiAgICAgIH0pKTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICBmb3IgKHZhciBmaWxlIG9mIGZpbGVzLnZhbHVlcygpKSBmb3JtLmFwcGVuZChgJHtpbmRleCsrfWAsIGZpbGUpO1xuICAgICAgcmV0dXJuIGZvcm07XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xuICB9XG59O1xuXG4vKiogQ3JlYXRlcyBhIGBSZXF1ZXN0SW5pdGAgb2JqZWN0IGZvciBhIGdpdmVuIGBPcGVyYXRpb25gLlxuICpcbiAqIEBwYXJhbSBvcGVyYXRpb24gLSBBbiB7QGxpbmsgT3BlcmF0aW9ufSBmb3Igd2hpY2ggdG8gbWFrZSB0aGUgcmVxdWVzdC5cbiAqIEBwYXJhbSBib2R5IC0gQSB7QGxpbmsgRmV0Y2hCb2R5fSB3aGljaCBpcyBhZGRlZCB0byB0aGUgb3B0aW9ucywgaWYgdGhlIHJlcXVlc3QgaXNu4oCZdCBhIEdFVCByZXF1ZXN0LlxuICpcbiAqIEByZW1hcmtzXG4gKiBDcmVhdGVzIHRoZSBmZXRjaCBvcHRpb25zIHtAbGluayBSZXF1ZXN0SW5pdH0gb2JqZWN0IHRoYXTigJlsbCBiZSBwYXNzZWQgdG8gdGhlIEZldGNoIEFQSVxuICogYXMgcGFydCBvZiBhIEdyYXBoUUwgb3ZlciBIVFRQIHJlcXVlc3QuIEl0IGF1dG9tYXRpY2FsbHkgc2V0cyBhIGRlZmF1bHQgYENvbnRlbnQtVHlwZWBcbiAqIGhlYWRlci5cbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZ3JhcGhxbC9ncmFwaHFsLW92ZXItaHR0cH0gZm9yIHRoZSBHcmFwaFFMIG92ZXIgSFRUUCBzcGVjLlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZldGNoX0FQSX0gZm9yIHRoZSBGZXRjaCBBUEkgc3BlYy5cbiAqL1xudmFyIG1ha2VGZXRjaE9wdGlvbnMgPSAob3BlcmF0aW9uLCBib2R5KSA9PiB7XG4gIHZhciBoZWFkZXJzID0ge1xuICAgIGFjY2VwdDogb3BlcmF0aW9uLmtpbmQgPT09ICdzdWJzY3JpcHRpb24nID8gJ3RleHQvZXZlbnQtc3RyZWFtLCBtdWx0aXBhcnQvbWl4ZWQnIDogJ2FwcGxpY2F0aW9uL2dyYXBocWwtcmVzcG9uc2UranNvbiwgYXBwbGljYXRpb24vZ3JhcGhxbCtqc29uLCBhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2V2ZW50LXN0cmVhbSwgbXVsdGlwYXJ0L21peGVkJ1xuICB9O1xuICB2YXIgZXh0cmFPcHRpb25zID0gKHR5cGVvZiBvcGVyYXRpb24uY29udGV4dC5mZXRjaE9wdGlvbnMgPT09ICdmdW5jdGlvbicgPyBvcGVyYXRpb24uY29udGV4dC5mZXRjaE9wdGlvbnMoKSA6IG9wZXJhdGlvbi5jb250ZXh0LmZldGNoT3B0aW9ucykgfHwge307XG4gIGlmIChleHRyYU9wdGlvbnMuaGVhZGVycykgZm9yICh2YXIga2V5IGluIGV4dHJhT3B0aW9ucy5oZWFkZXJzKSBoZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IGV4dHJhT3B0aW9ucy5oZWFkZXJzW2tleV07XG4gIHZhciBzZXJpYWxpemVkQm9keSA9IHNlcmlhbGl6ZUJvZHkob3BlcmF0aW9uLCBib2R5KTtcbiAgaWYgKHR5cGVvZiBzZXJpYWxpemVkQm9keSA9PT0gJ3N0cmluZycgJiYgIWhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddKSBoZWFkZXJzWydjb250ZW50LXR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgcmV0dXJuIHtcbiAgICAuLi5leHRyYU9wdGlvbnMsXG4gICAgbWV0aG9kOiBzZXJpYWxpemVkQm9keSA/ICdQT1NUJyA6ICdHRVQnLFxuICAgIGJvZHk6IHNlcmlhbGl6ZWRCb2R5LFxuICAgIGhlYWRlcnNcbiAgfTtcbn07XG5cbnZhciBkZWNvZGVyID0gdHlwZW9mIFRleHREZWNvZGVyICE9PSAndW5kZWZpbmVkJyA/IG5ldyBUZXh0RGVjb2RlcigpIDogbnVsbDtcbnZhciBib3VuZGFyeUhlYWRlclJlID0gL2JvdW5kYXJ5PVwiPyhbXj1cIjtdKylcIj8vaTtcbnZhciBldmVudFN0cmVhbVJlID0gL2RhdGE6ID8oW15cXG5dKykvO1xuLy8gTk9URTogV2UncmUgYXZvaWRpbmcgcmVmZXJlbmNpbmcgdGhlIGBCdWZmZXJgIGdsb2JhbCBoZXJlIHRvIHByZXZlbnRcbi8vIGF1dG8tcG9seWZpbGxpbmcgaW4gV2VicGFja1xudmFyIHRvU3RyaW5nID0gaW5wdXQgPT4gaW5wdXQuY29uc3RydWN0b3IubmFtZSA9PT0gJ0J1ZmZlcicgPyBpbnB1dC50b1N0cmluZygpIDogZGVjb2Rlci5kZWNvZGUoaW5wdXQpO1xuYXN5bmMgZnVuY3Rpb24qIHN0cmVhbUJvZHkocmVzcG9uc2UpIHtcbiAgaWYgKHJlc3BvbnNlLmJvZHlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKSB7XG4gICAgZm9yIGF3YWl0ICh2YXIgY2h1bmsgb2YgcmVzcG9uc2UuYm9keSkgeWllbGQgdG9TdHJpbmcoY2h1bmspO1xuICB9IGVsc2Uge1xuICAgIHZhciByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgIHZhciByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgIHdoaWxlICghKHJlc3VsdCA9IGF3YWl0IHJlYWRlci5yZWFkKCkpLmRvbmUpIHlpZWxkIHRvU3RyaW5nKHJlc3VsdC52YWx1ZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHJlYWRlci5jYW5jZWwoKTtcbiAgICB9XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uKiBzcGxpdChjaHVua3MsIGJvdW5kYXJ5KSB7XG4gIHZhciBidWZmZXIgPSAnJztcbiAgdmFyIGJvdW5kYXJ5SW5kZXg7XG4gIGZvciBhd2FpdCAodmFyIGNodW5rIG9mIGNodW5rcykge1xuICAgIGJ1ZmZlciArPSBjaHVuaztcbiAgICB3aGlsZSAoKGJvdW5kYXJ5SW5kZXggPSBidWZmZXIuaW5kZXhPZihib3VuZGFyeSkpID4gLTEpIHtcbiAgICAgIHlpZWxkIGJ1ZmZlci5zbGljZSgwLCBib3VuZGFyeUluZGV4KTtcbiAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShib3VuZGFyeUluZGV4ICsgYm91bmRhcnkubGVuZ3RoKTtcbiAgICB9XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uKiBwYXJzZUpTT04ocmVzcG9uc2UpIHtcbiAgeWllbGQgSlNPTi5wYXJzZShhd2FpdCByZXNwb25zZS50ZXh0KCkpO1xufVxuYXN5bmMgZnVuY3Rpb24qIHBhcnNlRXZlbnRTdHJlYW0ocmVzcG9uc2UpIHtcbiAgdmFyIHBheWxvYWQ7XG4gIGZvciBhd2FpdCAodmFyIGNodW5rIG9mIHNwbGl0KHN0cmVhbUJvZHkocmVzcG9uc2UpLCAnXFxuXFxuJykpIHtcbiAgICB2YXIgbWF0Y2ggPSBjaHVuay5tYXRjaChldmVudFN0cmVhbVJlKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHZhciBfY2h1bmsgPSBtYXRjaFsxXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHlpZWxkIHBheWxvYWQgPSBKU09OLnBhcnNlKF9jaHVuayk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoIXBheWxvYWQpIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgaWYgKHBheWxvYWQgJiYgcGF5bG9hZC5oYXNOZXh0ID09PSBmYWxzZSkgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChwYXlsb2FkICYmIHBheWxvYWQuaGFzTmV4dCAhPT0gZmFsc2UpIHtcbiAgICB5aWVsZCB7XG4gICAgICBoYXNOZXh0OiBmYWxzZVxuICAgIH07XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uKiBwYXJzZU11bHRpcGFydE1peGVkKGNvbnRlbnRUeXBlLCByZXNwb25zZSkge1xuICB2YXIgYm91bmRhcnlIZWFkZXIgPSBjb250ZW50VHlwZS5tYXRjaChib3VuZGFyeUhlYWRlclJlKTtcbiAgdmFyIGJvdW5kYXJ5ID0gJy0tJyArIChib3VuZGFyeUhlYWRlciA/IGJvdW5kYXJ5SGVhZGVyWzFdIDogJy0nKTtcbiAgdmFyIGlzUHJlYW1ibGUgPSB0cnVlO1xuICB2YXIgcGF5bG9hZDtcbiAgZm9yIGF3YWl0ICh2YXIgY2h1bmsgb2Ygc3BsaXQoc3RyZWFtQm9keShyZXNwb25zZSksICdcXHJcXG4nICsgYm91bmRhcnkpKSB7XG4gICAgaWYgKGlzUHJlYW1ibGUpIHtcbiAgICAgIGlzUHJlYW1ibGUgPSBmYWxzZTtcbiAgICAgIHZhciBwcmVhbWJsZUluZGV4ID0gY2h1bmsuaW5kZXhPZihib3VuZGFyeSk7XG4gICAgICBpZiAocHJlYW1ibGVJbmRleCA+IC0xKSB7XG4gICAgICAgIGNodW5rID0gY2h1bmsuc2xpY2UocHJlYW1ibGVJbmRleCArIGJvdW5kYXJ5Lmxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHlpZWxkIHBheWxvYWQgPSBKU09OLnBhcnNlKGNodW5rLnNsaWNlKGNodW5rLmluZGV4T2YoJ1xcclxcblxcclxcbicpICsgNCkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoIXBheWxvYWQpIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBpZiAocGF5bG9hZCAmJiBwYXlsb2FkLmhhc05leHQgPT09IGZhbHNlKSBicmVhaztcbiAgfVxuICBpZiAocGF5bG9hZCAmJiBwYXlsb2FkLmhhc05leHQgIT09IGZhbHNlKSB7XG4gICAgeWllbGQge1xuICAgICAgaGFzTmV4dDogZmFsc2VcbiAgICB9O1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiogZmV0Y2hPcGVyYXRpb24ob3BlcmF0aW9uLCB1cmwsIGZldGNoT3B0aW9ucykge1xuICB2YXIgbmV0d29ya01vZGUgPSB0cnVlO1xuICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgdmFyIHJlc3BvbnNlO1xuICB0cnkge1xuICAgIC8vIERlbGF5IGZvciBhIHRpY2sgdG8gZ2l2ZSB0aGUgQ2xpZW50IGEgY2hhbmNlIHRvIGNhbmNlbCB0aGUgcmVxdWVzdFxuICAgIC8vIGlmIGEgdGVhcmRvd24gY29tZXMgaW4gaW1tZWRpYXRlbHlcbiAgICB5aWVsZCBhd2FpdCBQcm9taXNlLnJlc29sdmUoKTtcbiAgICByZXNwb25zZSA9IGF3YWl0IChvcGVyYXRpb24uY29udGV4dC5mZXRjaCB8fCBmZXRjaCkodXJsLCBmZXRjaE9wdGlvbnMpO1xuICAgIHZhciBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKSB8fCAnJztcbiAgICB2YXIgcmVzdWx0cztcbiAgICBpZiAoL211bHRpcGFydFxcL21peGVkL2kudGVzdChjb250ZW50VHlwZSkpIHtcbiAgICAgIHJlc3VsdHMgPSBwYXJzZU11bHRpcGFydE1peGVkKGNvbnRlbnRUeXBlLCByZXNwb25zZSk7XG4gICAgfSBlbHNlIGlmICgvdGV4dFxcL2V2ZW50LXN0cmVhbS9pLnRlc3QoY29udGVudFR5cGUpKSB7XG4gICAgICByZXN1bHRzID0gcGFyc2VFdmVudFN0cmVhbShyZXNwb25zZSk7XG4gICAgfSBlbHNlIGlmICghL3RleHRcXC8vaS50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgICAgcmVzdWx0cyA9IHBhcnNlSlNPTihyZXNwb25zZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihhd2FpdCByZXNwb25zZS50ZXh0KCkpO1xuICAgIH1cbiAgICBmb3IgYXdhaXQgKHZhciBwYXlsb2FkIG9mIHJlc3VsdHMpIHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCA/IG1lcmdlUmVzdWx0UGF0Y2gocmVzdWx0LCBwYXlsb2FkLCByZXNwb25zZSkgOiBtYWtlUmVzdWx0KG9wZXJhdGlvbiwgcGF5bG9hZCwgcmVzcG9uc2UpO1xuICAgICAgbmV0d29ya01vZGUgPSBmYWxzZTtcbiAgICAgIHlpZWxkIHJlc3VsdDtcbiAgICAgIG5ldHdvcmtNb2RlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHlpZWxkIHJlc3VsdCA9IG1ha2VSZXN1bHQob3BlcmF0aW9uLCB7fSwgcmVzcG9uc2UpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoIW5ldHdvcmtNb2RlKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgeWllbGQgbWFrZUVycm9yUmVzdWx0KG9wZXJhdGlvbiwgcmVzcG9uc2UgJiYgKHJlc3BvbnNlLnN0YXR1cyA8IDIwMCB8fCByZXNwb25zZS5zdGF0dXMgPj0gMzAwKSAmJiByZXNwb25zZS5zdGF0dXNUZXh0ID8gbmV3IEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQpIDogZXJyb3IsIHJlc3BvbnNlKTtcbiAgfVxufVxuXG4vKiogTWFrZXMgYSBHcmFwaFFMIEhUVFAgcmVxdWVzdCB0byBhIGdpdmVuIEFQSSBieSB3cmFwcGluZyBhcm91bmQgdGhlIEZldGNoIEFQSS5cbiAqXG4gKiBAcGFyYW0gb3BlcmF0aW9uIC0gVGhlIHtAbGluayBPcGVyYXRpb259IHRoYXQgc2hvdWxkIGJlIHNlbnQgdmlhIEdyYXBoUUwgb3ZlciBIVFRQLlxuICogQHBhcmFtIHVybCAtIFRoZSBlbmRwb2ludCBVUkwgZm9yIHRoZSBHcmFwaFFMIEhUVFAgQVBJLlxuICogQHBhcmFtIGZldGNoT3B0aW9ucyAtIFRoZSB7QGxpbmsgUmVxdWVzdEluaXR9IGZldGNoIG9wdGlvbnMgZm9yIHRoZSByZXF1ZXN0LlxuICogQHJldHVybnMgQSBXb25rYSB7QGxpbmsgU291cmNlfSBvZiB7QGxpbmsgT3BlcmF0aW9uUmVzdWx0IHwgT3BlcmF0aW9uUmVzdWx0c30uXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgdXRpbGl0eSBkZWZpbmVzIGhvdyBhbGwgYnVpbHQtaW4gZmV0Y2ggZXhjaGFuZ2VzIG1ha2UgR3JhcGhRTCBIVFRQIHJlcXVlc3RzLFxuICogc3VwcG9ydGluZyBtdWx0aXBhcnQgaW5jcmVtZW50YWwgcmVzcG9uc2VzLCBjYW5jZWxsYXRpb24gYW5kIG90aGVyIHNtYWxsZXJcbiAqIGltcGxlbWVudGF0aW9uIGRldGFpbHMuXG4gKlxuICogSWYgeW914oCZcmUgaW1wbGVtZW50aW5nIGEgbW9kaWZpZWQgZmV0Y2ggZXhjaGFuZ2UgZm9yIGEgR3JhcGhRTCBvdmVyIEhUVFAgQVBJXG4gKiBpdOKAmXMgcmVjb21tZW5kZWQgeW91IHVzZSB0aGlzIHV0aWxpdHkuXG4gKlxuICogSGludDogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCB1c2UgdGhlIHBhc3NlZCBgb3BlcmF0aW9uYCB0byBjcmVhdGUgb3IgbW9kaWZ5IHRoZVxuICogYGZldGNoT3B0aW9uc2AgYW5kIGluc3RlYWQgZXhwZWN0cyB0aGF0IHRoZSBvcHRpb25zIGhhdmUgYWxyZWFkeSBiZWVuIGNyZWF0ZWRcbiAqIHVzaW5nIHtAbGluayBtYWtlRmV0Y2hPcHRpb25zfSBhbmQgbW9kaWZpZWQgYXMgbmVlZGVkLlxuICpcbiAqIEB0aHJvd3NcbiAqIElmIHRoZSBgZmV0Y2hgIHBvbHlmaWxsIG9yIGdsb2JhbGx5IGF2YWlsYWJsZSBgZmV0Y2hgIGZ1bmN0aW9uIGRvZXNu4oCZdCBzdXBwb3J0XG4gKiBzdHJlYW1lZCBtdWx0aXBhcnQgcmVzcG9uc2VzIHdoaWxlIHRyeWluZyB0byBoYW5kbGUgYSBgbXVsdGlwYXJ0L21peGVkYCBHcmFwaFFMIHJlc3BvbnNlLFxuICogdGhlIHNvdXJjZSB3aWxsIHRocm93IOKAnFN0cmVhbWluZyByZXF1ZXN0cyB1bnN1cHBvcnRlZOKAnS5cbiAqIFRoaXMgc2hvdWxkbuKAmXQgaGFwcGVuIGluIG1vZGVybiBicm93c2VycyBhbmQgTm9kZS5qcy5cbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmV0Y2hfQVBJfSBmb3IgdGhlIEZldGNoIEFQSSBzcGVjLlxuICovXG5mdW5jdGlvbiBtYWtlRmV0Y2hTb3VyY2Uob3BlcmF0aW9uLCB1cmwsIGZldGNoT3B0aW9ucykge1xuICB2YXIgYWJvcnRDb250cm9sbGVyO1xuICBpZiAodHlwZW9mIEFib3J0Q29udHJvbGxlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBmZXRjaE9wdGlvbnMuc2lnbmFsID0gKGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKSkuc2lnbmFsO1xuICB9XG4gIHJldHVybiB3b25rYS5vbkVuZCgoKSA9PiB7XG4gICAgaWYgKGFib3J0Q29udHJvbGxlcikgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gIH0pKHdvbmthLmZpbHRlcihyZXN1bHQgPT4gISFyZXN1bHQpKHdvbmthLmZyb21Bc3luY0l0ZXJhYmxlKGZldGNoT3BlcmF0aW9uKG9wZXJhdGlvbiwgdXJsLCBmZXRjaE9wdGlvbnMpKSkpO1xufVxuXG5leHBvcnRzLkNvbWJpbmVkRXJyb3IgPSBDb21iaW5lZEVycm9yO1xuZXhwb3J0cy5jcmVhdGVSZXF1ZXN0ID0gY3JlYXRlUmVxdWVzdDtcbmV4cG9ydHMuZ2V0T3BlcmF0aW9uVHlwZSA9IGdldE9wZXJhdGlvblR5cGU7XG5leHBvcnRzLmtleURvY3VtZW50ID0ga2V5RG9jdW1lbnQ7XG5leHBvcnRzLm1ha2VFcnJvclJlc3VsdCA9IG1ha2VFcnJvclJlc3VsdDtcbmV4cG9ydHMubWFrZUZldGNoQm9keSA9IG1ha2VGZXRjaEJvZHk7XG5leHBvcnRzLm1ha2VGZXRjaE9wdGlvbnMgPSBtYWtlRmV0Y2hPcHRpb25zO1xuZXhwb3J0cy5tYWtlRmV0Y2hTb3VyY2UgPSBtYWtlRmV0Y2hTb3VyY2U7XG5leHBvcnRzLm1ha2VGZXRjaFVSTCA9IG1ha2VGZXRjaFVSTDtcbmV4cG9ydHMubWFrZVJlc3VsdCA9IG1ha2VSZXN1bHQ7XG5leHBvcnRzLm1lcmdlUmVzdWx0UGF0Y2ggPSBtZXJnZVJlc3VsdFBhdGNoO1xuZXhwb3J0cy5zdHJpbmdpZnlEb2N1bWVudCA9IHN0cmluZ2lmeURvY3VtZW50O1xuZXhwb3J0cy5zdHJpbmdpZnlWYXJpYWJsZXMgPSBzdHJpbmdpZnlWYXJpYWJsZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cnFsLWNvcmUtY2h1bmsuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../../node_modules/.pnpm/@urql+core@4.0.10_graphql@16.11.0/node_modules/@urql/core/dist/urql-core-chunk.js\n");

/***/ }),

/***/ "(pages-dir-node)/../../node_modules/.pnpm/@urql+core@4.0.10_graphql@16.11.0/node_modules/@urql/core/dist/urql-core-chunk.mjs":
/*!*******************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@urql+core@4.0.10_graphql@16.11.0/node_modules/@urql/core/dist/urql-core-chunk.mjs ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   C: () => (/* binding */ CombinedError),\n/* harmony export */   a: () => (/* binding */ mergeResultPatch),\n/* harmony export */   b: () => (/* binding */ makeResult),\n/* harmony export */   c: () => (/* binding */ makeErrorResult),\n/* harmony export */   d: () => (/* binding */ makeFetchURL),\n/* harmony export */   e: () => (/* binding */ makeFetchOptions),\n/* harmony export */   f: () => (/* binding */ makeFetchSource),\n/* harmony export */   g: () => (/* binding */ getOperationType),\n/* harmony export */   h: () => (/* binding */ createRequest),\n/* harmony export */   i: () => (/* binding */ stringifyVariables),\n/* harmony export */   k: () => (/* binding */ keyDocument),\n/* harmony export */   m: () => (/* binding */ makeFetchBody),\n/* harmony export */   s: () => (/* binding */ stringifyDocument)\n/* harmony export */ });\n/* harmony import */ var _0no_co_graphql_web__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @0no-co/graphql.web */ \"(pages-dir-node)/../../node_modules/.pnpm/@0no-co+graphql.web@1.0.4_graphql@16.11.0/node_modules/@0no-co/graphql.web/dist/graphql.web.mjs\");\n/* harmony import */ var wonka__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! wonka */ \"(pages-dir-node)/../../node_modules/.pnpm/wonka@6.3.2/node_modules/wonka/dist/wonka.mjs\");\n\n\n\n\nvar rehydrateGraphQlError = e => {\n  if (e && e.message && (e.extensions || \"GraphQLError\" === e.name)) {\n    return e;\n  } else if (\"object\" == typeof e && e.message) {\n    return new _0no_co_graphql_web__WEBPACK_IMPORTED_MODULE_0__.GraphQLError(e.message, e.nodes, e.source, e.positions, e.path, e, e.extensions || {});\n  } else {\n    return new _0no_co_graphql_web__WEBPACK_IMPORTED_MODULE_0__.GraphQLError(e);\n  }\n};\n\nclass CombinedError extends Error {\n  constructor(r) {\n    var e = (r.graphQLErrors || []).map(rehydrateGraphQlError);\n    var t = ((r, e) => {\n      var t = \"\";\n      if (r) {\n        return `[Network] ${r.message}`;\n      }\n      if (e) {\n        for (var a of e) {\n          if (t) {\n            t += \"\\n\";\n          }\n          t += `[GraphQL] ${a.message}`;\n        }\n      }\n      return t;\n    })(r.networkError, e);\n    super(t);\n    this.name = \"CombinedError\";\n    this.message = t;\n    this.graphQLErrors = e;\n    this.networkError = r.networkError;\n    this.response = r.response;\n  }\n  toString() {\n    return this.message;\n  }\n}\n\nvar phash = (r, e) => {\n  var t = 0 | (e || 5381);\n  for (var a = 0, o = 0 | r.length; a < o; a++) {\n    t = (t << 5) + t + r.charCodeAt(a);\n  }\n  return t;\n};\n\nvar i = new Set;\n\nvar f = new WeakMap;\n\nvar stringify = r => {\n  if (null === r || i.has(r)) {\n    return \"null\";\n  } else if (\"object\" != typeof r) {\n    return JSON.stringify(r) || \"\";\n  } else if (r.toJSON) {\n    return stringify(r.toJSON());\n  } else if (Array.isArray(r)) {\n    var e = \"[\";\n    for (var t of r) {\n      if (e.length > 1) {\n        e += \",\";\n      }\n      e += stringify(t) || \"null\";\n    }\n    return e += \"]\";\n  } else if (v !== NoopConstructor && r instanceof v || l !== NoopConstructor && r instanceof l) {\n    return \"null\";\n  }\n  var a = Object.keys(r).sort();\n  if (!a.length && r.constructor && r.constructor !== Object) {\n    var o = f.get(r) || Math.random().toString(36).slice(2);\n    f.set(r, o);\n    return stringify({\n      __key: o\n    });\n  }\n  i.add(r);\n  var n = \"{\";\n  for (var s of a) {\n    var c = stringify(r[s]);\n    if (c) {\n      if (n.length > 1) {\n        n += \",\";\n      }\n      n += stringify(s) + \":\" + c;\n    }\n  }\n  i.delete(r);\n  return n += \"}\";\n};\n\nvar extract = (r, e, t) => {\n  if (null == t || \"object\" != typeof t || t.toJSON || i.has(t)) {} else if (Array.isArray(t)) {\n    for (var a = 0, o = t.length; a < o; a++) {\n      extract(r, `${e}.${a}`, t[a]);\n    }\n  } else if (t instanceof v || t instanceof l) {\n    r.set(e, t);\n  } else {\n    i.add(t);\n    for (var n of Object.keys(t)) {\n      extract(r, `${e}.${n}`, t[n]);\n    }\n  }\n};\n\nvar stringifyVariables = r => {\n  i.clear();\n  return stringify(r);\n};\n\nclass NoopConstructor {}\n\nvar v = \"undefined\" != typeof File ? File : NoopConstructor;\n\nvar l = \"undefined\" != typeof Blob ? Blob : NoopConstructor;\n\nvar c = /(\"{3}[\\s\\S]*\"{3}|\"(?:\\\\.|[^\"])*\")/g;\n\nvar d = /(?:#[^\\n\\r]+)?(?:[\\r\\n]+|$)/g;\n\nvar replaceOutsideStrings = (r, e) => e % 2 == 0 ? r.replace(d, \"\\n\") : r;\n\nvar sanitizeDocument = r => r.split(c).map(replaceOutsideStrings).join(\"\").trim();\n\nvar p = new Map;\n\nvar u = new Map;\n\nvar stringifyDocument = r => {\n  var t;\n  if (\"string\" == typeof r) {\n    t = sanitizeDocument(r);\n  } else if (r.loc && u.get(r.__key) === r) {\n    t = r.loc.source.body;\n  } else {\n    t = p.get(r) || sanitizeDocument((0,_0no_co_graphql_web__WEBPACK_IMPORTED_MODULE_0__.print)(r));\n    p.set(r, t);\n  }\n  if (\"string\" != typeof r && !r.loc) {\n    r.loc = {\n      start: 0,\n      end: t.length,\n      source: {\n        body: t,\n        name: \"gql\",\n        locationOffset: {\n          line: 1,\n          column: 1\n        }\n      }\n    };\n  }\n  return t;\n};\n\nvar hashDocument = r => {\n  var e = phash(stringifyDocument(r));\n  if (r.definitions) {\n    var t = getOperationName(r);\n    if (t) {\n      e = phash(`\\n# ${t}`, e);\n    }\n  }\n  return e;\n};\n\nvar keyDocument = r => {\n  var e;\n  var a;\n  if (\"string\" == typeof r) {\n    e = hashDocument(r);\n    a = u.get(e) || (0,_0no_co_graphql_web__WEBPACK_IMPORTED_MODULE_0__.parse)(r, {\n      noLocation: !0\n    });\n  } else {\n    e = r.__key || hashDocument(r);\n    a = u.get(e) || r;\n  }\n  if (!a.loc) {\n    stringifyDocument(a);\n  }\n  a.__key = e;\n  u.set(e, a);\n  return a;\n};\n\nvar createRequest = (r, e, t) => {\n  var a = e || {};\n  var o = keyDocument(r);\n  var n = stringifyVariables(a);\n  var s = o.__key;\n  if (\"{}\" !== n) {\n    s = phash(n, s);\n  }\n  return {\n    key: s,\n    query: o,\n    variables: a,\n    extensions: t\n  };\n};\n\nvar getOperationName = r => {\n  for (var e of r.definitions) {\n    if (e.kind === _0no_co_graphql_web__WEBPACK_IMPORTED_MODULE_0__.Kind.OPERATION_DEFINITION) {\n      return e.name ? e.name.value : void 0;\n    }\n  }\n};\n\nvar getOperationType = r => {\n  for (var e of r.definitions) {\n    if (e.kind === _0no_co_graphql_web__WEBPACK_IMPORTED_MODULE_0__.Kind.OPERATION_DEFINITION) {\n      return e.operation;\n    }\n  }\n};\n\nvar makeResult = (r, e, t) => {\n  if (!(\"data\" in e) && !(\"errors\" in e)) {\n    throw new Error(\"No Content\");\n  }\n  var a = \"subscription\" === r.kind;\n  return {\n    operation: r,\n    data: e.data,\n    error: Array.isArray(e.errors) ? new CombinedError({\n      graphQLErrors: e.errors,\n      response: t\n    }) : void 0,\n    extensions: e.extensions ? {\n      ...e.extensions\n    } : void 0,\n    hasNext: null == e.hasNext ? a : e.hasNext,\n    stale: !1\n  };\n};\n\nvar deepMerge = (r, e) => {\n  if (\"object\" == typeof r && null != r) {\n    if (!r.constructor || r.constructor === Object || Array.isArray(r)) {\n      r = Array.isArray(r) ? [ ...r ] : {\n        ...r\n      };\n      for (var t of Object.keys(e)) {\n        r[t] = deepMerge(r[t], e[t]);\n      }\n      return r;\n    }\n  }\n  return e;\n};\n\nvar mergeResultPatch = (r, e, t) => {\n  var a = r.error ? r.error.graphQLErrors : [];\n  var o = !!r.extensions || !!e.extensions;\n  var n = {\n    ...r.extensions,\n    ...e.extensions\n  };\n  var s = e.incremental;\n  if (\"path\" in e) {\n    s = [ e ];\n  }\n  var i = {\n    data: r.data\n  };\n  if (s) {\n    for (var f of s) {\n      if (Array.isArray(f.errors)) {\n        a.push(...f.errors);\n      }\n      if (f.extensions) {\n        Object.assign(n, f.extensions);\n        o = !0;\n      }\n      var v = \"data\";\n      var l = i;\n      for (var c = 0, d = f.path.length; c < d; v = f.path[c++]) {\n        l = l[v] = Array.isArray(l[v]) ? [ ...l[v] ] : {\n          ...l[v]\n        };\n      }\n      if (f.items) {\n        var p = +v >= 0 ? v : 0;\n        for (var u = 0, y = f.items.length; u < y; u++) {\n          l[p + u] = deepMerge(l[p + u], f.items[u]);\n        }\n      } else if (void 0 !== f.data) {\n        l[v] = deepMerge(l[v], f.data);\n      }\n    }\n  } else {\n    i.data = e.data || r.data;\n    a = e.errors || a;\n  }\n  return {\n    operation: r.operation,\n    data: i.data,\n    error: a.length ? new CombinedError({\n      graphQLErrors: a,\n      response: t\n    }) : void 0,\n    extensions: o ? n : void 0,\n    hasNext: null != e.hasNext ? e.hasNext : r.hasNext,\n    stale: !1\n  };\n};\n\nvar makeErrorResult = (r, e, t) => ({\n  operation: r,\n  data: void 0,\n  error: new CombinedError({\n    networkError: e,\n    response: t\n  }),\n  extensions: void 0,\n  hasNext: !1,\n  stale: !1\n});\n\nfunction makeFetchBody(r) {\n  return {\n    query: r.extensions && r.extensions.persistedQuery && !r.extensions.persistedQuery.miss ? void 0 : stringifyDocument(r.query),\n    operationName: getOperationName(r.query),\n    variables: r.variables || void 0,\n    extensions: r.extensions\n  };\n}\n\nvar makeFetchURL = (r, e) => {\n  var t = \"query\" === r.kind && r.context.preferGetMethod;\n  if (!t || !e) {\n    return r.context.url;\n  }\n  var a = new URL(r.context.url);\n  for (var o in e) {\n    var n = e[o];\n    if (n) {\n      a.searchParams.set(o, \"object\" == typeof n ? stringifyVariables(n) : n);\n    }\n  }\n  var s = a.toString();\n  if (s.length > 2047 && \"force\" !== t) {\n    r.context.preferGetMethod = !1;\n    return r.context.url;\n  }\n  return s;\n};\n\nvar serializeBody = (r, e) => {\n  if (e && !(\"query\" === r.kind && !!r.context.preferGetMethod)) {\n    var t = stringifyVariables(e);\n    var a = (r => {\n      var e = new Map;\n      if (v !== NoopConstructor || l !== NoopConstructor) {\n        i.clear();\n        extract(e, \"variables\", r);\n      }\n      return e;\n    })(e.variables);\n    if (a.size) {\n      var o = new FormData;\n      o.append(\"operations\", t);\n      o.append(\"map\", stringifyVariables({\n        ...[ ...a.keys() ].map((r => [ r ]))\n      }));\n      var n = 0;\n      for (var s of a.values()) {\n        o.append(\"\" + n++, s);\n      }\n      return o;\n    }\n    return t;\n  }\n};\n\nvar makeFetchOptions = (r, e) => {\n  var t = {\n    accept: \"subscription\" === r.kind ? \"text/event-stream, multipart/mixed\" : \"application/graphql-response+json, application/graphql+json, application/json, text/event-stream, multipart/mixed\"\n  };\n  var a = (\"function\" == typeof r.context.fetchOptions ? r.context.fetchOptions() : r.context.fetchOptions) || {};\n  if (a.headers) {\n    for (var o in a.headers) {\n      t[o.toLowerCase()] = a.headers[o];\n    }\n  }\n  var n = serializeBody(r, e);\n  if (\"string\" == typeof n && !t[\"content-type\"]) {\n    t[\"content-type\"] = \"application/json\";\n  }\n  return {\n    ...a,\n    method: n ? \"POST\" : \"GET\",\n    body: n,\n    headers: t\n  };\n};\n\nvar y = \"undefined\" != typeof TextDecoder ? new TextDecoder : null;\n\nvar h = /boundary=\"?([^=\";]+)\"?/i;\n\nvar x = /data: ?([^\\n]+)/;\n\nvar toString = r => \"Buffer\" === r.constructor.name ? r.toString() : y.decode(r);\n\nasync function* streamBody(r) {\n  if (r.body[Symbol.asyncIterator]) {\n    for await (var e of r.body) {\n      yield toString(e);\n    }\n  } else {\n    var t = r.body.getReader();\n    var a;\n    try {\n      while (!(a = await t.read()).done) {\n        yield toString(a.value);\n      }\n    } finally {\n      t.cancel();\n    }\n  }\n}\n\nasync function* split(r, e) {\n  var t = \"\";\n  var a;\n  for await (var o of r) {\n    t += o;\n    while ((a = t.indexOf(e)) > -1) {\n      yield t.slice(0, a);\n      t = t.slice(a + e.length);\n    }\n  }\n}\n\nasync function* fetchOperation(r, e, t) {\n  var a = !0;\n  var o = null;\n  var n;\n  try {\n    yield await Promise.resolve();\n    var s = (n = await (r.context.fetch || fetch)(e, t)).headers.get(\"Content-Type\") || \"\";\n    var i;\n    if (/multipart\\/mixed/i.test(s)) {\n      i = async function* parseMultipartMixed(r, e) {\n        var t = r.match(h);\n        var a = \"--\" + (t ? t[1] : \"-\");\n        var o = !0;\n        var n;\n        for await (var s of split(streamBody(e), \"\\r\\n\" + a)) {\n          if (o) {\n            o = !1;\n            var i = s.indexOf(a);\n            if (i > -1) {\n              s = s.slice(i + a.length);\n            } else {\n              continue;\n            }\n          }\n          try {\n            yield n = JSON.parse(s.slice(s.indexOf(\"\\r\\n\\r\\n\") + 4));\n          } catch (r) {\n            if (!n) {\n              throw r;\n            }\n          }\n          if (n && !1 === n.hasNext) {\n            break;\n          }\n        }\n        if (n && !1 !== n.hasNext) {\n          yield {\n            hasNext: !1\n          };\n        }\n      }(s, n);\n    } else if (/text\\/event-stream/i.test(s)) {\n      i = async function* parseEventStream(r) {\n        var e;\n        for await (var t of split(streamBody(r), \"\\n\\n\")) {\n          var a = t.match(x);\n          if (a) {\n            var o = a[1];\n            try {\n              yield e = JSON.parse(o);\n            } catch (r) {\n              if (!e) {\n                throw r;\n              }\n            }\n            if (e && !1 === e.hasNext) {\n              break;\n            }\n          }\n        }\n        if (e && !1 !== e.hasNext) {\n          yield {\n            hasNext: !1\n          };\n        }\n      }(n);\n    } else if (!/text\\//i.test(s)) {\n      i = async function* parseJSON(r) {\n        yield JSON.parse(await r.text());\n      }(n);\n    } else {\n      throw new Error(await n.text());\n    }\n    for await (var f of i) {\n      o = o ? mergeResultPatch(o, f, n) : makeResult(r, f, n);\n      a = !1;\n      yield o;\n      a = !0;\n    }\n    if (!o) {\n      yield o = makeResult(r, {}, n);\n    }\n  } catch (e) {\n    if (!a) {\n      throw e;\n    }\n    yield makeErrorResult(r, n && (n.status < 200 || n.status >= 300) && n.statusText ? new Error(n.statusText) : e, n);\n  }\n}\n\nfunction makeFetchSource(r, e, t) {\n  var a;\n  if (\"undefined\" != typeof AbortController) {\n    t.signal = (a = new AbortController).signal;\n  }\n  return (0,wonka__WEBPACK_IMPORTED_MODULE_1__.onEnd)((() => {\n    if (a) {\n      a.abort();\n    }\n  }))((0,wonka__WEBPACK_IMPORTED_MODULE_1__.filter)((r => !!r))((0,wonka__WEBPACK_IMPORTED_MODULE_1__.fromAsyncIterable)(fetchOperation(r, e, t))));\n}\n\n\n//# sourceMappingURL=urql-core-chunk.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHVycWwrY29yZUA0LjAuMTBfZ3JhcGhxbEAxNi4xMS4wL25vZGVfbW9kdWxlcy9AdXJxbC9jb3JlL2Rpc3QvdXJxbC1jb3JlLWNodW5rLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMkY7O0FBRW5COztBQUV4RTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osZUFBZSw2REFBQyx5RUFBeUU7QUFDekYsSUFBSTtBQUNKLGVBQWUsNkRBQUM7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0Esb0VBQW9FO0FBQ3BFLGtDQUFrQyxPQUFPO0FBQ3pDLG9CQUFvQixFQUFFLEdBQUcsRUFBRTtBQUMzQjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esb0JBQW9CLEVBQUUsR0FBRyxFQUFFO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxZQUFZLEVBQUUsU0FBUyxFQUFFOztBQUV6Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSixxQ0FBcUMsMERBQUM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsRUFBRTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBEQUFDO0FBQ3JCO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLHFEQUFDO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIscURBQUM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQkFBMEI7O0FBRTFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNENBQUM7QUFDVjtBQUNBO0FBQ0E7QUFDQSxHQUFHLEdBQUcsNkNBQUMsYUFBYSx3REFBQztBQUNyQjs7QUFFOFI7QUFDOVIiLCJzb3VyY2VzIjpbIi9ob21lL21pY2hhZWwvc2FsZW9yLXBsYXRmb3JtL3NhbGVvci1hcHBzL25vZGVfbW9kdWxlcy8ucG5wbS9AdXJxbCtjb3JlQDQuMC4xMF9ncmFwaHFsQDE2LjExLjAvbm9kZV9tb2R1bGVzL0B1cnFsL2NvcmUvZGlzdC91cnFsLWNvcmUtY2h1bmsubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEdyYXBoUUxFcnJvciBhcyByLCBwcmludCBhcyBlLCBwYXJzZSBhcyB0LCBLaW5kIGFzIGEgfSBmcm9tIFwiQDBuby1jby9ncmFwaHFsLndlYlwiO1xuXG5pbXBvcnQgeyBvbkVuZCBhcyBvLCBmaWx0ZXIgYXMgbiwgZnJvbUFzeW5jSXRlcmFibGUgYXMgcyB9IGZyb20gXCJ3b25rYVwiO1xuXG52YXIgcmVoeWRyYXRlR3JhcGhRbEVycm9yID0gZSA9PiB7XG4gIGlmIChlICYmIGUubWVzc2FnZSAmJiAoZS5leHRlbnNpb25zIHx8IFwiR3JhcGhRTEVycm9yXCIgPT09IGUubmFtZSkpIHtcbiAgICByZXR1cm4gZTtcbiAgfSBlbHNlIGlmIChcIm9iamVjdFwiID09IHR5cGVvZiBlICYmIGUubWVzc2FnZSkge1xuICAgIHJldHVybiBuZXcgcihlLm1lc3NhZ2UsIGUubm9kZXMsIGUuc291cmNlLCBlLnBvc2l0aW9ucywgZS5wYXRoLCBlLCBlLmV4dGVuc2lvbnMgfHwge30pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgcihlKTtcbiAgfVxufTtcblxuY2xhc3MgQ29tYmluZWRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Iocikge1xuICAgIHZhciBlID0gKHIuZ3JhcGhRTEVycm9ycyB8fCBbXSkubWFwKHJlaHlkcmF0ZUdyYXBoUWxFcnJvcik7XG4gICAgdmFyIHQgPSAoKHIsIGUpID0+IHtcbiAgICAgIHZhciB0ID0gXCJcIjtcbiAgICAgIGlmIChyKSB7XG4gICAgICAgIHJldHVybiBgW05ldHdvcmtdICR7ci5tZXNzYWdlfWA7XG4gICAgICB9XG4gICAgICBpZiAoZSkge1xuICAgICAgICBmb3IgKHZhciBhIG9mIGUpIHtcbiAgICAgICAgICBpZiAodCkge1xuICAgICAgICAgICAgdCArPSBcIlxcblwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0ICs9IGBbR3JhcGhRTF0gJHthLm1lc3NhZ2V9YDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHQ7XG4gICAgfSkoci5uZXR3b3JrRXJyb3IsIGUpO1xuICAgIHN1cGVyKHQpO1xuICAgIHRoaXMubmFtZSA9IFwiQ29tYmluZWRFcnJvclwiO1xuICAgIHRoaXMubWVzc2FnZSA9IHQ7XG4gICAgdGhpcy5ncmFwaFFMRXJyb3JzID0gZTtcbiAgICB0aGlzLm5ldHdvcmtFcnJvciA9IHIubmV0d29ya0Vycm9yO1xuICAgIHRoaXMucmVzcG9uc2UgPSByLnJlc3BvbnNlO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gIH1cbn1cblxudmFyIHBoYXNoID0gKHIsIGUpID0+IHtcbiAgdmFyIHQgPSAwIHwgKGUgfHwgNTM4MSk7XG4gIGZvciAodmFyIGEgPSAwLCBvID0gMCB8IHIubGVuZ3RoOyBhIDwgbzsgYSsrKSB7XG4gICAgdCA9ICh0IDw8IDUpICsgdCArIHIuY2hhckNvZGVBdChhKTtcbiAgfVxuICByZXR1cm4gdDtcbn07XG5cbnZhciBpID0gbmV3IFNldDtcblxudmFyIGYgPSBuZXcgV2Vha01hcDtcblxudmFyIHN0cmluZ2lmeSA9IHIgPT4ge1xuICBpZiAobnVsbCA9PT0gciB8fCBpLmhhcyhyKSkge1xuICAgIHJldHVybiBcIm51bGxcIjtcbiAgfSBlbHNlIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiByKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHIpIHx8IFwiXCI7XG4gIH0gZWxzZSBpZiAoci50b0pTT04pIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5KHIudG9KU09OKCkpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocikpIHtcbiAgICB2YXIgZSA9IFwiW1wiO1xuICAgIGZvciAodmFyIHQgb2Ygcikge1xuICAgICAgaWYgKGUubGVuZ3RoID4gMSkge1xuICAgICAgICBlICs9IFwiLFwiO1xuICAgICAgfVxuICAgICAgZSArPSBzdHJpbmdpZnkodCkgfHwgXCJudWxsXCI7XG4gICAgfVxuICAgIHJldHVybiBlICs9IFwiXVwiO1xuICB9IGVsc2UgaWYgKHYgIT09IE5vb3BDb25zdHJ1Y3RvciAmJiByIGluc3RhbmNlb2YgdiB8fCBsICE9PSBOb29wQ29uc3RydWN0b3IgJiYgciBpbnN0YW5jZW9mIGwpIHtcbiAgICByZXR1cm4gXCJudWxsXCI7XG4gIH1cbiAgdmFyIGEgPSBPYmplY3Qua2V5cyhyKS5zb3J0KCk7XG4gIGlmICghYS5sZW5ndGggJiYgci5jb25zdHJ1Y3RvciAmJiByLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHtcbiAgICB2YXIgbyA9IGYuZ2V0KHIpIHx8IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuICAgIGYuc2V0KHIsIG8pO1xuICAgIHJldHVybiBzdHJpbmdpZnkoe1xuICAgICAgX19rZXk6IG9cbiAgICB9KTtcbiAgfVxuICBpLmFkZChyKTtcbiAgdmFyIG4gPSBcIntcIjtcbiAgZm9yICh2YXIgcyBvZiBhKSB7XG4gICAgdmFyIGMgPSBzdHJpbmdpZnkocltzXSk7XG4gICAgaWYgKGMpIHtcbiAgICAgIGlmIChuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbiArPSBcIixcIjtcbiAgICAgIH1cbiAgICAgIG4gKz0gc3RyaW5naWZ5KHMpICsgXCI6XCIgKyBjO1xuICAgIH1cbiAgfVxuICBpLmRlbGV0ZShyKTtcbiAgcmV0dXJuIG4gKz0gXCJ9XCI7XG59O1xuXG52YXIgZXh0cmFjdCA9IChyLCBlLCB0KSA9PiB7XG4gIGlmIChudWxsID09IHQgfHwgXCJvYmplY3RcIiAhPSB0eXBlb2YgdCB8fCB0LnRvSlNPTiB8fCBpLmhhcyh0KSkge30gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0KSkge1xuICAgIGZvciAodmFyIGEgPSAwLCBvID0gdC5sZW5ndGg7IGEgPCBvOyBhKyspIHtcbiAgICAgIGV4dHJhY3QociwgYCR7ZX0uJHthfWAsIHRbYV0pO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0IGluc3RhbmNlb2YgdiB8fCB0IGluc3RhbmNlb2YgbCkge1xuICAgIHIuc2V0KGUsIHQpO1xuICB9IGVsc2Uge1xuICAgIGkuYWRkKHQpO1xuICAgIGZvciAodmFyIG4gb2YgT2JqZWN0LmtleXModCkpIHtcbiAgICAgIGV4dHJhY3QociwgYCR7ZX0uJHtufWAsIHRbbl0pO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHN0cmluZ2lmeVZhcmlhYmxlcyA9IHIgPT4ge1xuICBpLmNsZWFyKCk7XG4gIHJldHVybiBzdHJpbmdpZnkocik7XG59O1xuXG5jbGFzcyBOb29wQ29uc3RydWN0b3Ige31cblxudmFyIHYgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBGaWxlID8gRmlsZSA6IE5vb3BDb25zdHJ1Y3RvcjtcblxudmFyIGwgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBCbG9iID8gQmxvYiA6IE5vb3BDb25zdHJ1Y3RvcjtcblxudmFyIGMgPSAvKFwiezN9W1xcc1xcU10qXCJ7M318XCIoPzpcXFxcLnxbXlwiXSkqXCIpL2c7XG5cbnZhciBkID0gLyg/OiNbXlxcblxccl0rKT8oPzpbXFxyXFxuXSt8JCkvZztcblxudmFyIHJlcGxhY2VPdXRzaWRlU3RyaW5ncyA9IChyLCBlKSA9PiBlICUgMiA9PSAwID8gci5yZXBsYWNlKGQsIFwiXFxuXCIpIDogcjtcblxudmFyIHNhbml0aXplRG9jdW1lbnQgPSByID0+IHIuc3BsaXQoYykubWFwKHJlcGxhY2VPdXRzaWRlU3RyaW5ncykuam9pbihcIlwiKS50cmltKCk7XG5cbnZhciBwID0gbmV3IE1hcDtcblxudmFyIHUgPSBuZXcgTWFwO1xuXG52YXIgc3RyaW5naWZ5RG9jdW1lbnQgPSByID0+IHtcbiAgdmFyIHQ7XG4gIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSB7XG4gICAgdCA9IHNhbml0aXplRG9jdW1lbnQocik7XG4gIH0gZWxzZSBpZiAoci5sb2MgJiYgdS5nZXQoci5fX2tleSkgPT09IHIpIHtcbiAgICB0ID0gci5sb2Muc291cmNlLmJvZHk7XG4gIH0gZWxzZSB7XG4gICAgdCA9IHAuZ2V0KHIpIHx8IHNhbml0aXplRG9jdW1lbnQoZShyKSk7XG4gICAgcC5zZXQociwgdCk7XG4gIH1cbiAgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIHIgJiYgIXIubG9jKSB7XG4gICAgci5sb2MgPSB7XG4gICAgICBzdGFydDogMCxcbiAgICAgIGVuZDogdC5sZW5ndGgsXG4gICAgICBzb3VyY2U6IHtcbiAgICAgICAgYm9keTogdCxcbiAgICAgICAgbmFtZTogXCJncWxcIixcbiAgICAgICAgbG9jYXRpb25PZmZzZXQ6IHtcbiAgICAgICAgICBsaW5lOiAxLFxuICAgICAgICAgIGNvbHVtbjogMVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4gdDtcbn07XG5cbnZhciBoYXNoRG9jdW1lbnQgPSByID0+IHtcbiAgdmFyIGUgPSBwaGFzaChzdHJpbmdpZnlEb2N1bWVudChyKSk7XG4gIGlmIChyLmRlZmluaXRpb25zKSB7XG4gICAgdmFyIHQgPSBnZXRPcGVyYXRpb25OYW1lKHIpO1xuICAgIGlmICh0KSB7XG4gICAgICBlID0gcGhhc2goYFxcbiMgJHt0fWAsIGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZTtcbn07XG5cbnZhciBrZXlEb2N1bWVudCA9IHIgPT4ge1xuICB2YXIgZTtcbiAgdmFyIGE7XG4gIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSB7XG4gICAgZSA9IGhhc2hEb2N1bWVudChyKTtcbiAgICBhID0gdS5nZXQoZSkgfHwgdChyLCB7XG4gICAgICBub0xvY2F0aW9uOiAhMFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGUgPSByLl9fa2V5IHx8IGhhc2hEb2N1bWVudChyKTtcbiAgICBhID0gdS5nZXQoZSkgfHwgcjtcbiAgfVxuICBpZiAoIWEubG9jKSB7XG4gICAgc3RyaW5naWZ5RG9jdW1lbnQoYSk7XG4gIH1cbiAgYS5fX2tleSA9IGU7XG4gIHUuc2V0KGUsIGEpO1xuICByZXR1cm4gYTtcbn07XG5cbnZhciBjcmVhdGVSZXF1ZXN0ID0gKHIsIGUsIHQpID0+IHtcbiAgdmFyIGEgPSBlIHx8IHt9O1xuICB2YXIgbyA9IGtleURvY3VtZW50KHIpO1xuICB2YXIgbiA9IHN0cmluZ2lmeVZhcmlhYmxlcyhhKTtcbiAgdmFyIHMgPSBvLl9fa2V5O1xuICBpZiAoXCJ7fVwiICE9PSBuKSB7XG4gICAgcyA9IHBoYXNoKG4sIHMpO1xuICB9XG4gIHJldHVybiB7XG4gICAga2V5OiBzLFxuICAgIHF1ZXJ5OiBvLFxuICAgIHZhcmlhYmxlczogYSxcbiAgICBleHRlbnNpb25zOiB0XG4gIH07XG59O1xuXG52YXIgZ2V0T3BlcmF0aW9uTmFtZSA9IHIgPT4ge1xuICBmb3IgKHZhciBlIG9mIHIuZGVmaW5pdGlvbnMpIHtcbiAgICBpZiAoZS5raW5kID09PSBhLk9QRVJBVElPTl9ERUZJTklUSU9OKSB7XG4gICAgICByZXR1cm4gZS5uYW1lID8gZS5uYW1lLnZhbHVlIDogdm9pZCAwO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGdldE9wZXJhdGlvblR5cGUgPSByID0+IHtcbiAgZm9yICh2YXIgZSBvZiByLmRlZmluaXRpb25zKSB7XG4gICAgaWYgKGUua2luZCA9PT0gYS5PUEVSQVRJT05fREVGSU5JVElPTikge1xuICAgICAgcmV0dXJuIGUub3BlcmF0aW9uO1xuICAgIH1cbiAgfVxufTtcblxudmFyIG1ha2VSZXN1bHQgPSAociwgZSwgdCkgPT4ge1xuICBpZiAoIShcImRhdGFcIiBpbiBlKSAmJiAhKFwiZXJyb3JzXCIgaW4gZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBDb250ZW50XCIpO1xuICB9XG4gIHZhciBhID0gXCJzdWJzY3JpcHRpb25cIiA9PT0gci5raW5kO1xuICByZXR1cm4ge1xuICAgIG9wZXJhdGlvbjogcixcbiAgICBkYXRhOiBlLmRhdGEsXG4gICAgZXJyb3I6IEFycmF5LmlzQXJyYXkoZS5lcnJvcnMpID8gbmV3IENvbWJpbmVkRXJyb3Ioe1xuICAgICAgZ3JhcGhRTEVycm9yczogZS5lcnJvcnMsXG4gICAgICByZXNwb25zZTogdFxuICAgIH0pIDogdm9pZCAwLFxuICAgIGV4dGVuc2lvbnM6IGUuZXh0ZW5zaW9ucyA/IHtcbiAgICAgIC4uLmUuZXh0ZW5zaW9uc1xuICAgIH0gOiB2b2lkIDAsXG4gICAgaGFzTmV4dDogbnVsbCA9PSBlLmhhc05leHQgPyBhIDogZS5oYXNOZXh0LFxuICAgIHN0YWxlOiAhMVxuICB9O1xufTtcblxudmFyIGRlZXBNZXJnZSA9IChyLCBlKSA9PiB7XG4gIGlmIChcIm9iamVjdFwiID09IHR5cGVvZiByICYmIG51bGwgIT0gcikge1xuICAgIGlmICghci5jb25zdHJ1Y3RvciB8fCByLmNvbnN0cnVjdG9yID09PSBPYmplY3QgfHwgQXJyYXkuaXNBcnJheShyKSkge1xuICAgICAgciA9IEFycmF5LmlzQXJyYXkocikgPyBbIC4uLnIgXSA6IHtcbiAgICAgICAgLi4uclxuICAgICAgfTtcbiAgICAgIGZvciAodmFyIHQgb2YgT2JqZWN0LmtleXMoZSkpIHtcbiAgICAgICAgclt0XSA9IGRlZXBNZXJnZShyW3RdLCBlW3RdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZTtcbn07XG5cbnZhciBtZXJnZVJlc3VsdFBhdGNoID0gKHIsIGUsIHQpID0+IHtcbiAgdmFyIGEgPSByLmVycm9yID8gci5lcnJvci5ncmFwaFFMRXJyb3JzIDogW107XG4gIHZhciBvID0gISFyLmV4dGVuc2lvbnMgfHwgISFlLmV4dGVuc2lvbnM7XG4gIHZhciBuID0ge1xuICAgIC4uLnIuZXh0ZW5zaW9ucyxcbiAgICAuLi5lLmV4dGVuc2lvbnNcbiAgfTtcbiAgdmFyIHMgPSBlLmluY3JlbWVudGFsO1xuICBpZiAoXCJwYXRoXCIgaW4gZSkge1xuICAgIHMgPSBbIGUgXTtcbiAgfVxuICB2YXIgaSA9IHtcbiAgICBkYXRhOiByLmRhdGFcbiAgfTtcbiAgaWYgKHMpIHtcbiAgICBmb3IgKHZhciBmIG9mIHMpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGYuZXJyb3JzKSkge1xuICAgICAgICBhLnB1c2goLi4uZi5lcnJvcnMpO1xuICAgICAgfVxuICAgICAgaWYgKGYuZXh0ZW5zaW9ucykge1xuICAgICAgICBPYmplY3QuYXNzaWduKG4sIGYuZXh0ZW5zaW9ucyk7XG4gICAgICAgIG8gPSAhMDtcbiAgICAgIH1cbiAgICAgIHZhciB2ID0gXCJkYXRhXCI7XG4gICAgICB2YXIgbCA9IGk7XG4gICAgICBmb3IgKHZhciBjID0gMCwgZCA9IGYucGF0aC5sZW5ndGg7IGMgPCBkOyB2ID0gZi5wYXRoW2MrK10pIHtcbiAgICAgICAgbCA9IGxbdl0gPSBBcnJheS5pc0FycmF5KGxbdl0pID8gWyAuLi5sW3ZdIF0gOiB7XG4gICAgICAgICAgLi4ubFt2XVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGYuaXRlbXMpIHtcbiAgICAgICAgdmFyIHAgPSArdiA+PSAwID8gdiA6IDA7XG4gICAgICAgIGZvciAodmFyIHUgPSAwLCB5ID0gZi5pdGVtcy5sZW5ndGg7IHUgPCB5OyB1KyspIHtcbiAgICAgICAgICBsW3AgKyB1XSA9IGRlZXBNZXJnZShsW3AgKyB1XSwgZi5pdGVtc1t1XSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodm9pZCAwICE9PSBmLmRhdGEpIHtcbiAgICAgICAgbFt2XSA9IGRlZXBNZXJnZShsW3ZdLCBmLmRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpLmRhdGEgPSBlLmRhdGEgfHwgci5kYXRhO1xuICAgIGEgPSBlLmVycm9ycyB8fCBhO1xuICB9XG4gIHJldHVybiB7XG4gICAgb3BlcmF0aW9uOiByLm9wZXJhdGlvbixcbiAgICBkYXRhOiBpLmRhdGEsXG4gICAgZXJyb3I6IGEubGVuZ3RoID8gbmV3IENvbWJpbmVkRXJyb3Ioe1xuICAgICAgZ3JhcGhRTEVycm9yczogYSxcbiAgICAgIHJlc3BvbnNlOiB0XG4gICAgfSkgOiB2b2lkIDAsXG4gICAgZXh0ZW5zaW9uczogbyA/IG4gOiB2b2lkIDAsXG4gICAgaGFzTmV4dDogbnVsbCAhPSBlLmhhc05leHQgPyBlLmhhc05leHQgOiByLmhhc05leHQsXG4gICAgc3RhbGU6ICExXG4gIH07XG59O1xuXG52YXIgbWFrZUVycm9yUmVzdWx0ID0gKHIsIGUsIHQpID0+ICh7XG4gIG9wZXJhdGlvbjogcixcbiAgZGF0YTogdm9pZCAwLFxuICBlcnJvcjogbmV3IENvbWJpbmVkRXJyb3Ioe1xuICAgIG5ldHdvcmtFcnJvcjogZSxcbiAgICByZXNwb25zZTogdFxuICB9KSxcbiAgZXh0ZW5zaW9uczogdm9pZCAwLFxuICBoYXNOZXh0OiAhMSxcbiAgc3RhbGU6ICExXG59KTtcblxuZnVuY3Rpb24gbWFrZUZldGNoQm9keShyKSB7XG4gIHJldHVybiB7XG4gICAgcXVlcnk6IHIuZXh0ZW5zaW9ucyAmJiByLmV4dGVuc2lvbnMucGVyc2lzdGVkUXVlcnkgJiYgIXIuZXh0ZW5zaW9ucy5wZXJzaXN0ZWRRdWVyeS5taXNzID8gdm9pZCAwIDogc3RyaW5naWZ5RG9jdW1lbnQoci5xdWVyeSksXG4gICAgb3BlcmF0aW9uTmFtZTogZ2V0T3BlcmF0aW9uTmFtZShyLnF1ZXJ5KSxcbiAgICB2YXJpYWJsZXM6IHIudmFyaWFibGVzIHx8IHZvaWQgMCxcbiAgICBleHRlbnNpb25zOiByLmV4dGVuc2lvbnNcbiAgfTtcbn1cblxudmFyIG1ha2VGZXRjaFVSTCA9IChyLCBlKSA9PiB7XG4gIHZhciB0ID0gXCJxdWVyeVwiID09PSByLmtpbmQgJiYgci5jb250ZXh0LnByZWZlckdldE1ldGhvZDtcbiAgaWYgKCF0IHx8ICFlKSB7XG4gICAgcmV0dXJuIHIuY29udGV4dC51cmw7XG4gIH1cbiAgdmFyIGEgPSBuZXcgVVJMKHIuY29udGV4dC51cmwpO1xuICBmb3IgKHZhciBvIGluIGUpIHtcbiAgICB2YXIgbiA9IGVbb107XG4gICAgaWYgKG4pIHtcbiAgICAgIGEuc2VhcmNoUGFyYW1zLnNldChvLCBcIm9iamVjdFwiID09IHR5cGVvZiBuID8gc3RyaW5naWZ5VmFyaWFibGVzKG4pIDogbik7XG4gICAgfVxuICB9XG4gIHZhciBzID0gYS50b1N0cmluZygpO1xuICBpZiAocy5sZW5ndGggPiAyMDQ3ICYmIFwiZm9yY2VcIiAhPT0gdCkge1xuICAgIHIuY29udGV4dC5wcmVmZXJHZXRNZXRob2QgPSAhMTtcbiAgICByZXR1cm4gci5jb250ZXh0LnVybDtcbiAgfVxuICByZXR1cm4gcztcbn07XG5cbnZhciBzZXJpYWxpemVCb2R5ID0gKHIsIGUpID0+IHtcbiAgaWYgKGUgJiYgIShcInF1ZXJ5XCIgPT09IHIua2luZCAmJiAhIXIuY29udGV4dC5wcmVmZXJHZXRNZXRob2QpKSB7XG4gICAgdmFyIHQgPSBzdHJpbmdpZnlWYXJpYWJsZXMoZSk7XG4gICAgdmFyIGEgPSAociA9PiB7XG4gICAgICB2YXIgZSA9IG5ldyBNYXA7XG4gICAgICBpZiAodiAhPT0gTm9vcENvbnN0cnVjdG9yIHx8IGwgIT09IE5vb3BDb25zdHJ1Y3Rvcikge1xuICAgICAgICBpLmNsZWFyKCk7XG4gICAgICAgIGV4dHJhY3QoZSwgXCJ2YXJpYWJsZXNcIiwgcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZTtcbiAgICB9KShlLnZhcmlhYmxlcyk7XG4gICAgaWYgKGEuc2l6ZSkge1xuICAgICAgdmFyIG8gPSBuZXcgRm9ybURhdGE7XG4gICAgICBvLmFwcGVuZChcIm9wZXJhdGlvbnNcIiwgdCk7XG4gICAgICBvLmFwcGVuZChcIm1hcFwiLCBzdHJpbmdpZnlWYXJpYWJsZXMoe1xuICAgICAgICAuLi5bIC4uLmEua2V5cygpIF0ubWFwKChyID0+IFsgciBdKSlcbiAgICAgIH0pKTtcbiAgICAgIHZhciBuID0gMDtcbiAgICAgIGZvciAodmFyIHMgb2YgYS52YWx1ZXMoKSkge1xuICAgICAgICBvLmFwcGVuZChcIlwiICsgbisrLCBzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfVxufTtcblxudmFyIG1ha2VGZXRjaE9wdGlvbnMgPSAociwgZSkgPT4ge1xuICB2YXIgdCA9IHtcbiAgICBhY2NlcHQ6IFwic3Vic2NyaXB0aW9uXCIgPT09IHIua2luZCA/IFwidGV4dC9ldmVudC1zdHJlYW0sIG11bHRpcGFydC9taXhlZFwiIDogXCJhcHBsaWNhdGlvbi9ncmFwaHFsLXJlc3BvbnNlK2pzb24sIGFwcGxpY2F0aW9uL2dyYXBocWwranNvbiwgYXBwbGljYXRpb24vanNvbiwgdGV4dC9ldmVudC1zdHJlYW0sIG11bHRpcGFydC9taXhlZFwiXG4gIH07XG4gIHZhciBhID0gKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2Ygci5jb250ZXh0LmZldGNoT3B0aW9ucyA/IHIuY29udGV4dC5mZXRjaE9wdGlvbnMoKSA6IHIuY29udGV4dC5mZXRjaE9wdGlvbnMpIHx8IHt9O1xuICBpZiAoYS5oZWFkZXJzKSB7XG4gICAgZm9yICh2YXIgbyBpbiBhLmhlYWRlcnMpIHtcbiAgICAgIHRbby50b0xvd2VyQ2FzZSgpXSA9IGEuaGVhZGVyc1tvXTtcbiAgICB9XG4gIH1cbiAgdmFyIG4gPSBzZXJpYWxpemVCb2R5KHIsIGUpO1xuICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgbiAmJiAhdFtcImNvbnRlbnQtdHlwZVwiXSkge1xuICAgIHRbXCJjb250ZW50LXR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIjtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLmEsXG4gICAgbWV0aG9kOiBuID8gXCJQT1NUXCIgOiBcIkdFVFwiLFxuICAgIGJvZHk6IG4sXG4gICAgaGVhZGVyczogdFxuICB9O1xufTtcblxudmFyIHkgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBUZXh0RGVjb2RlciA/IG5ldyBUZXh0RGVjb2RlciA6IG51bGw7XG5cbnZhciBoID0gL2JvdW5kYXJ5PVwiPyhbXj1cIjtdKylcIj8vaTtcblxudmFyIHggPSAvZGF0YTogPyhbXlxcbl0rKS87XG5cbnZhciB0b1N0cmluZyA9IHIgPT4gXCJCdWZmZXJcIiA9PT0gci5jb25zdHJ1Y3Rvci5uYW1lID8gci50b1N0cmluZygpIDogeS5kZWNvZGUocik7XG5cbmFzeW5jIGZ1bmN0aW9uKiBzdHJlYW1Cb2R5KHIpIHtcbiAgaWYgKHIuYm9keVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0pIHtcbiAgICBmb3IgYXdhaXQgKHZhciBlIG9mIHIuYm9keSkge1xuICAgICAgeWllbGQgdG9TdHJpbmcoZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciB0ID0gci5ib2R5LmdldFJlYWRlcigpO1xuICAgIHZhciBhO1xuICAgIHRyeSB7XG4gICAgICB3aGlsZSAoIShhID0gYXdhaXQgdC5yZWFkKCkpLmRvbmUpIHtcbiAgICAgICAgeWllbGQgdG9TdHJpbmcoYS52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHQuY2FuY2VsKCk7XG4gICAgfVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uKiBzcGxpdChyLCBlKSB7XG4gIHZhciB0ID0gXCJcIjtcbiAgdmFyIGE7XG4gIGZvciBhd2FpdCAodmFyIG8gb2Ygcikge1xuICAgIHQgKz0gbztcbiAgICB3aGlsZSAoKGEgPSB0LmluZGV4T2YoZSkpID4gLTEpIHtcbiAgICAgIHlpZWxkIHQuc2xpY2UoMCwgYSk7XG4gICAgICB0ID0gdC5zbGljZShhICsgZS5sZW5ndGgpO1xuICAgIH1cbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiogZmV0Y2hPcGVyYXRpb24ociwgZSwgdCkge1xuICB2YXIgYSA9ICEwO1xuICB2YXIgbyA9IG51bGw7XG4gIHZhciBuO1xuICB0cnkge1xuICAgIHlpZWxkIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHZhciBzID0gKG4gPSBhd2FpdCAoci5jb250ZXh0LmZldGNoIHx8IGZldGNoKShlLCB0KSkuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIikgfHwgXCJcIjtcbiAgICB2YXIgaTtcbiAgICBpZiAoL211bHRpcGFydFxcL21peGVkL2kudGVzdChzKSkge1xuICAgICAgaSA9IGFzeW5jIGZ1bmN0aW9uKiBwYXJzZU11bHRpcGFydE1peGVkKHIsIGUpIHtcbiAgICAgICAgdmFyIHQgPSByLm1hdGNoKGgpO1xuICAgICAgICB2YXIgYSA9IFwiLS1cIiArICh0ID8gdFsxXSA6IFwiLVwiKTtcbiAgICAgICAgdmFyIG8gPSAhMDtcbiAgICAgICAgdmFyIG47XG4gICAgICAgIGZvciBhd2FpdCAodmFyIHMgb2Ygc3BsaXQoc3RyZWFtQm9keShlKSwgXCJcXHJcXG5cIiArIGEpKSB7XG4gICAgICAgICAgaWYgKG8pIHtcbiAgICAgICAgICAgIG8gPSAhMTtcbiAgICAgICAgICAgIHZhciBpID0gcy5pbmRleE9mKGEpO1xuICAgICAgICAgICAgaWYgKGkgPiAtMSkge1xuICAgICAgICAgICAgICBzID0gcy5zbGljZShpICsgYS5sZW5ndGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB5aWVsZCBuID0gSlNPTi5wYXJzZShzLnNsaWNlKHMuaW5kZXhPZihcIlxcclxcblxcclxcblwiKSArIDQpKTtcbiAgICAgICAgICB9IGNhdGNoIChyKSB7XG4gICAgICAgICAgICBpZiAoIW4pIHtcbiAgICAgICAgICAgICAgdGhyb3cgcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG4gJiYgITEgPT09IG4uaGFzTmV4dCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuICYmICExICE9PSBuLmhhc05leHQpIHtcbiAgICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgICBoYXNOZXh0OiAhMVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0ocywgbik7XG4gICAgfSBlbHNlIGlmICgvdGV4dFxcL2V2ZW50LXN0cmVhbS9pLnRlc3QocykpIHtcbiAgICAgIGkgPSBhc3luYyBmdW5jdGlvbiogcGFyc2VFdmVudFN0cmVhbShyKSB7XG4gICAgICAgIHZhciBlO1xuICAgICAgICBmb3IgYXdhaXQgKHZhciB0IG9mIHNwbGl0KHN0cmVhbUJvZHkociksIFwiXFxuXFxuXCIpKSB7XG4gICAgICAgICAgdmFyIGEgPSB0Lm1hdGNoKHgpO1xuICAgICAgICAgIGlmIChhKSB7XG4gICAgICAgICAgICB2YXIgbyA9IGFbMV07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB5aWVsZCBlID0gSlNPTi5wYXJzZShvKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgICAgICAgICAgaWYgKCFlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUgJiYgITEgPT09IGUuaGFzTmV4dCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUgJiYgITEgIT09IGUuaGFzTmV4dCkge1xuICAgICAgICAgIHlpZWxkIHtcbiAgICAgICAgICAgIGhhc05leHQ6ICExXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfShuKTtcbiAgICB9IGVsc2UgaWYgKCEvdGV4dFxcLy9pLnRlc3QocykpIHtcbiAgICAgIGkgPSBhc3luYyBmdW5jdGlvbiogcGFyc2VKU09OKHIpIHtcbiAgICAgICAgeWllbGQgSlNPTi5wYXJzZShhd2FpdCByLnRleHQoKSk7XG4gICAgICB9KG4pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYXdhaXQgbi50ZXh0KCkpO1xuICAgIH1cbiAgICBmb3IgYXdhaXQgKHZhciBmIG9mIGkpIHtcbiAgICAgIG8gPSBvID8gbWVyZ2VSZXN1bHRQYXRjaChvLCBmLCBuKSA6IG1ha2VSZXN1bHQociwgZiwgbik7XG4gICAgICBhID0gITE7XG4gICAgICB5aWVsZCBvO1xuICAgICAgYSA9ICEwO1xuICAgIH1cbiAgICBpZiAoIW8pIHtcbiAgICAgIHlpZWxkIG8gPSBtYWtlUmVzdWx0KHIsIHt9LCBuKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoIWEpIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIHlpZWxkIG1ha2VFcnJvclJlc3VsdChyLCBuICYmIChuLnN0YXR1cyA8IDIwMCB8fCBuLnN0YXR1cyA+PSAzMDApICYmIG4uc3RhdHVzVGV4dCA/IG5ldyBFcnJvcihuLnN0YXR1c1RleHQpIDogZSwgbik7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUZldGNoU291cmNlKHIsIGUsIHQpIHtcbiAgdmFyIGE7XG4gIGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBBYm9ydENvbnRyb2xsZXIpIHtcbiAgICB0LnNpZ25hbCA9IChhID0gbmV3IEFib3J0Q29udHJvbGxlcikuc2lnbmFsO1xuICB9XG4gIHJldHVybiBvKCgoKSA9PiB7XG4gICAgaWYgKGEpIHtcbiAgICAgIGEuYWJvcnQoKTtcbiAgICB9XG4gIH0pKShuKChyID0+ICEhcikpKHMoZmV0Y2hPcGVyYXRpb24ociwgZSwgdCkpKSk7XG59XG5cbmV4cG9ydCB7IENvbWJpbmVkRXJyb3IgYXMgQywgbWVyZ2VSZXN1bHRQYXRjaCBhcyBhLCBtYWtlUmVzdWx0IGFzIGIsIG1ha2VFcnJvclJlc3VsdCBhcyBjLCBtYWtlRmV0Y2hVUkwgYXMgZCwgbWFrZUZldGNoT3B0aW9ucyBhcyBlLCBtYWtlRmV0Y2hTb3VyY2UgYXMgZiwgZ2V0T3BlcmF0aW9uVHlwZSBhcyBnLCBjcmVhdGVSZXF1ZXN0IGFzIGgsIHN0cmluZ2lmeVZhcmlhYmxlcyBhcyBpLCBrZXlEb2N1bWVudCBhcyBrLCBtYWtlRmV0Y2hCb2R5IGFzIG0sIHN0cmluZ2lmeURvY3VtZW50IGFzIHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVycWwtY29yZS1jaHVuay5tanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../../node_modules/.pnpm/@urql+core@4.0.10_graphql@16.11.0/node_modules/@urql/core/dist/urql-core-chunk.mjs\n");

/***/ }),

/***/ "(pages-dir-node)/../../node_modules/.pnpm/@urql+core@4.0.10_graphql@16.11.0/node_modules/@urql/core/dist/urql-core.js":
/*!************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@urql+core@4.0.10_graphql@16.11.0/node_modules/@urql/core/dist/urql-core.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("Object.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar graphql_web = __webpack_require__(/*! @0no-co/graphql.web */ \"(pages-dir-node)/../../node_modules/.pnpm/@0no-co+graphql.web@1.0.4_graphql@16.11.0/node_modules/@0no-co/graphql.web/dist/graphql.web.js\");\nvar fetchSource = __webpack_require__(/*! ./urql-core-chunk.js */ \"(pages-dir-node)/../../node_modules/.pnpm/@urql+core@4.0.10_graphql@16.11.0/node_modules/@urql/core/dist/urql-core-chunk.js\");\nvar wonka = __webpack_require__(/*! wonka */ \"(pages-dir-node)/../../node_modules/.pnpm/wonka@6.3.2/node_modules/wonka/dist/wonka.js\");\n\nvar collectTypes = (obj, types) => {\n  if (Array.isArray(obj)) {\n    for (var item of obj) collectTypes(item, types);\n  } else if (typeof obj === 'object' && obj !== null) {\n    for (var _key in obj) {\n      if (_key === '__typename' && typeof obj[_key] === 'string') {\n        types.add(obj[_key]);\n      } else {\n        collectTypes(obj[_key], types);\n      }\n    }\n  }\n  return types;\n};\n\n/** Finds and returns a list of `__typename` fields found in response data.\n *\n * @privateRemarks\n * This is used by `@urql/core`’s document `cacheExchange` to find typenames\n * in a given GraphQL response’s data.\n */\nvar collectTypesFromResponse = response => [...collectTypes(response, new Set())];\nvar formatNode = node => {\n  var hasChanged = false;\n  if ('definitions' in node) {\n    var definitions = [];\n    for (var definition of node.definitions) {\n      var newDefinition = formatNode(definition);\n      hasChanged = hasChanged || newDefinition !== definition;\n      definitions.push(newDefinition);\n    }\n    if (hasChanged) return {\n      ...node,\n      definitions\n    };\n  } else if ('selectionSet' in node) {\n    var selections = [];\n    var hasTypename = node.kind === graphql_web.Kind.OPERATION_DEFINITION;\n    if (node.selectionSet) {\n      for (var selection of node.selectionSet.selections || []) {\n        hasTypename = hasTypename || selection.kind === graphql_web.Kind.FIELD && selection.name.value === '__typename' && !selection.alias;\n        var newSelection = formatNode(selection);\n        hasChanged = hasChanged || newSelection !== selection;\n        selections.push(newSelection);\n      }\n      if (!hasTypename) {\n        hasChanged = true;\n        selections.push({\n          kind: graphql_web.Kind.FIELD,\n          name: {\n            kind: graphql_web.Kind.NAME,\n            value: '__typename'\n          }\n        });\n      }\n      if (hasChanged) return {\n        ...node,\n        selectionSet: {\n          ...node.selectionSet,\n          selections\n        }\n      };\n    }\n  }\n  return node;\n};\nvar formattedDocs = new Map();\n\n/** Adds `__typename` fields to a GraphQL `DocumentNode`.\n *\n * @param node - a {@link DocumentNode}.\n * @returns a copy of the passed {@link DocumentNode} with added `__typename` introspection fields.\n *\n * @remarks\n * Cache {@link Exchange | Exchanges} will require typename introspection to\n * recognize types in a GraphQL response. To retrieve these typenames,\n * this function is used to add the `__typename` fields to non-root\n * selection sets of a GraphQL document.\n *\n * This utility also preserves the internally computed key of the\n * document as created by {@link createRequest} to avoid any\n * formatting from being duplicated.\n *\n * @see {@link https://spec.graphql.org/October2021/#sec-Type-Name-Introspection} for more information\n * on typename introspection via the `__typename` field.\n */\nvar formatDocument = node => {\n  var query = fetchSource.keyDocument(node);\n  var result = formattedDocs.get(query.__key);\n  if (!result) {\n    formattedDocs.set(query.__key, result = formatNode(query));\n    // Ensure that the hash of the resulting document won't suddenly change\n    // we are marking __key as non-enumerable so when external exchanges use visit\n    // to manipulate a document we won't restore the previous query due to the __key\n    // property.\n    Object.defineProperty(result, '__key', {\n      value: query.__key,\n      enumerable: false\n    });\n  }\n  return result;\n};\n\n/** Used to recursively mark `__typename` fields in data as non-enumerable.\n *\n * @remarks\n * This utility can be used to recursively copy GraphQl response data and hide\n * all `__typename` fields present on it.\n *\n * Hint: It’s not recommended to do this, unless it's absolutely necessary as\n * cloning and modifying all data of a response can be unnecessarily slow, when\n * a manual and more specific copy/mask is more efficient.\n *\n * @see {@link ClientOptions.maskTypename} for a description of how the `Client` uses this utility.\n */\nvar maskTypename = (data, isRoot) => {\n  if (!data || typeof data !== 'object') {\n    return data;\n  } else if (Array.isArray(data)) {\n    return data.map(d => maskTypename(d));\n  } else if (data && typeof data === 'object' && (isRoot || '__typename' in data)) {\n    var acc = {};\n    for (var key in data) {\n      if (key === '__typename') {\n        Object.defineProperty(acc, '__typename', {\n          enumerable: false,\n          value: data.__typename\n        });\n      } else {\n        acc[key] = maskTypename(data[key]);\n      }\n    }\n    return acc;\n  } else {\n    return data;\n  }\n};\n\n/** Patches a `toPromise` method onto the `Source` passed to it.\n * @param source$ - the Wonka {@link Source} to patch.\n * @returns The passed `source$` with a patched `toPromise` method as a {@link PromisifiedSource}.\n * @internal\n */\nfunction withPromise(_source$) {\n  var source$ = sink => _source$(sink);\n  source$.toPromise = () => wonka.toPromise(wonka.take(1)(wonka.filter(result => !result.stale && !result.hasNext)(source$)));\n  source$.then = (onResolve, onReject) => source$.toPromise().then(onResolve, onReject);\n  source$.subscribe = onResult => wonka.subscribe(onResult)(source$);\n  return source$;\n}\n\n/** Creates a {@link Operation} from the given parameters.\n *\n * @param kind - The {@link OperationType} of GraphQL operation, i.e. `query`, `mutation`, or `subscription`.\n * @param request - The {@link GraphQLRequest} or {@link Operation} used as a template for the new `Operation`.\n * @param context - The {@link OperationContext} `context` data for the `Operation`.\n * @returns A new {@link Operation}.\n *\n * @remarks\n * This method is both used to create new {@link Operation | Operations} as well as copy and modify existing\n * operations. While it’s not required to use this function to copy an `Operation`, it is recommended, in case\n * additional dynamic logic is added to them in the future.\n *\n * Hint: When an {@link Operation} is passed to the `request` argument, the `context` argument does not have to be\n * a complete {@link OperationContext} and will instead be combined with passed {@link Operation.context}.\n *\n * @example\n * An example of copying an existing `Operation` to modify its `context`:\n *\n * ```ts\n * makeOperation(\n *   operation.kind,\n *   operation,\n *   { requestPolicy: 'cache-first' },\n * );\n * ```\n */\n\nfunction makeOperation(kind, request, context) {\n  return {\n    ...request,\n    kind,\n    context: request.context ? {\n      ...request.context,\n      ...context\n    } : context || request.context\n  };\n}\n\n/** Adds additional metadata to an `Operation`'s `context.meta` property while copying it.\n * @see {@link OperationDebugMeta} for more information on the {@link OperationContext.meta} property.\n */\nvar addMetadata = (operation, meta) => {\n  return makeOperation(operation.kind, operation, {\n    meta: {\n      ...operation.context.meta,\n      ...meta\n    }\n  });\n};\n\nvar noop = () => {\n  /* noop */\n};\n\n/* eslint-disable prefer-rest-params */\n\n/** A GraphQL parse function, which may be called as a tagged template literal, returning a parsed {@link DocumentNode}.\n *\n * @remarks\n * The `gql` tag or function is used to parse a GraphQL query document into a {@link DocumentNode}.\n *\n * When used as a tagged template, `gql` will automatically merge fragment definitions into the resulting\n * document and deduplicate them.\n *\n * It enforces that all fragments have a unique name. When fragments with different definitions share a name,\n * it will log a warning in development.\n *\n * Hint: It’s recommended to use this `gql` function over other GraphQL parse functions, since it puts the parsed\n * results directly into `@urql/core`’s internal caches and prevents further unnecessary work.\n *\n * @example\n * ```ts\n * const AuthorFragment = gql`\n *   fragment AuthorDisplayComponent on Author {\n *     id\n *     name\n *   }\n * `;\n *\n * const BookFragment = gql`\n *   fragment ListBookComponent on Book {\n *     id\n *     title\n *     author {\n *       ...AuthorDisplayComponent\n *     }\n *   }\n *\n *   ${AuthorFragment}\n * `;\n *\n * const BookQuery = gql`\n *   query Book($id: ID!) {\n *     book(id: $id) {\n *       ...BookFragment\n *     }\n *   }\n *\n *   ${BookFragment}\n * `;\n * ```\n */\n\nfunction gql(parts) {\n  var fragmentNames = new Map();\n  var definitions = [];\n  var source = [];\n\n  // Apply the entire tagged template body's definitions\n  var body = Array.isArray(parts) ? parts[0] : parts || '';\n  for (var i = 1; i < arguments.length; i++) {\n    var value = arguments[i];\n    if (value && value.definitions) {\n      source.push(value);\n    } else {\n      body += value;\n    }\n    body += arguments[0][i];\n  }\n  source.unshift(fetchSource.keyDocument(body));\n  for (var document of source) {\n    for (var definition of document.definitions) {\n      if (definition.kind === graphql_web.Kind.FRAGMENT_DEFINITION) {\n        var name = definition.name.value;\n        var _value = fetchSource.stringifyDocument(definition);\n        // Fragments will be deduplicated according to this Map\n        if (!fragmentNames.has(name)) {\n          fragmentNames.set(name, _value);\n          definitions.push(definition);\n        } else if ( true && fragmentNames.get(name) !== _value) {\n          // Fragments with the same names is expected to have the same contents\n          console.warn('[WARNING: Duplicate Fragment] A fragment with name `' + name + '` already exists in this document.\\n' + 'While fragment names may not be unique across your source, each name must be unique per document.');\n        }\n      } else {\n        definitions.push(definition);\n      }\n    }\n  }\n  return fetchSource.keyDocument({\n    kind: graphql_web.Kind.DOCUMENT,\n    definitions\n  });\n}\n\n/* eslint-disable @typescript-eslint/no-use-before-define */\nvar shouldSkip = ({\n  kind\n}) => kind !== 'mutation' && kind !== 'query';\n\n/** Default document cache exchange.\n *\n * @remarks\n * The default document cache in `urql` avoids sending the same GraphQL request\n * multiple times by caching it using the {@link Operation.key}. It will invalidate\n * query results automatically whenever it sees a mutation responses with matching\n * `__typename`s in their responses.\n *\n * The document cache will get the introspected `__typename` fields by modifying\n * your GraphQL operation documents using the {@link formatDocument} utility.\n *\n * This automatic invalidation strategy can fail if your query or mutation don’t\n * contain matching typenames, for instance, because the query contained an\n * empty list.\n * You can manually add hints for this exchange by specifying a list of\n * {@link OperationContext.additionalTypenames} for queries and mutations that\n * should invalidate one another.\n *\n * @see {@link https://urql.dev/goto/docs/basics/document-caching} for more information on this cache.\n */\nvar cacheExchange = ({\n  forward,\n  client,\n  dispatchDebug\n}) => {\n  var resultCache = new Map();\n  var operationCache = new Map();\n\n  // Adds unique typenames to query (for invalidating cache entries)\n  var mapTypeNames = operation => {\n    var formattedOperation = makeOperation(operation.kind, operation);\n    formattedOperation.query = formatDocument(operation.query);\n    return formattedOperation;\n  };\n  var isOperationCached = operation => operation.kind === 'query' && operation.context.requestPolicy !== 'network-only' && (operation.context.requestPolicy === 'cache-only' || resultCache.has(operation.key));\n  return ops$ => {\n    var cachedOps$ = wonka.map(operation => {\n      var cachedResult = resultCache.get(operation.key);\n       true ? dispatchDebug({\n        operation,\n        ...(cachedResult ? {\n          type: 'cacheHit',\n          message: 'The result was successfully retried from the cache'\n        } : {\n          type: 'cacheMiss',\n          message: 'The result could not be retrieved from the cache'\n        }),\n        \"source\": \"cacheExchange\"\n      }) : 0;\n      var result = cachedResult;\n      if (true) {\n        result = {\n          ...result,\n          operation:  true ? addMetadata(operation, {\n            cacheOutcome: cachedResult ? 'hit' : 'miss'\n          }) : 0\n        };\n      }\n      if (operation.context.requestPolicy === 'cache-and-network') {\n        result.stale = true;\n        reexecuteOperation(client, operation);\n      }\n      return result;\n    })(wonka.filter(op => !shouldSkip(op) && isOperationCached(op))(ops$));\n    var forwardedOps$ = wonka.tap(response => {\n      var {\n        operation\n      } = response;\n      if (!operation) return;\n      var typenames = operation.context.additionalTypenames || [];\n      // NOTE: For now, we only respect `additionalTypenames` from subscriptions to\n      // avoid unexpected breaking changes\n      // We'd expect live queries or other update mechanisms to be more suitable rather\n      // than using subscriptions as “signals” to reexecute queries. However, if they’re\n      // just used as signals, it’s intuitive to hook them up using `additionalTypenames`\n      if (response.operation.kind !== 'subscription') {\n        typenames = collectTypesFromResponse(response.data).concat(typenames);\n      }\n\n      // Invalidates the cache given a mutation's response\n      if (response.operation.kind === 'mutation' || response.operation.kind === 'subscription') {\n        var pendingOperations = new Set();\n         true ? dispatchDebug({\n          type: 'cacheInvalidation',\n          message: `The following typenames have been invalidated: ${typenames}`,\n          operation,\n          data: {\n            typenames,\n            response\n          },\n          \"source\": \"cacheExchange\"\n        }) : 0;\n        for (var i = 0; i < typenames.length; i++) {\n          var typeName = typenames[i];\n          var operations = operationCache.get(typeName);\n          if (!operations) operationCache.set(typeName, operations = new Set());\n          for (var key of operations.values()) pendingOperations.add(key);\n          operations.clear();\n        }\n        for (var _key of pendingOperations.values()) {\n          if (resultCache.has(_key)) {\n            operation = resultCache.get(_key).operation;\n            resultCache.delete(_key);\n            reexecuteOperation(client, operation);\n          }\n        }\n      } else if (operation.kind === 'query' && response.data) {\n        resultCache.set(operation.key, response);\n        for (var _i = 0; _i < typenames.length; _i++) {\n          var _typeName = typenames[_i];\n          var _operations = operationCache.get(_typeName);\n          if (!_operations) operationCache.set(_typeName, _operations = new Set());\n          _operations.add(operation.key);\n        }\n      }\n    })(forward(wonka.filter(op => op.kind !== 'query' || op.context.requestPolicy !== 'cache-only')(wonka.map(op =>  true ? addMetadata(op, {\n      cacheOutcome: 'miss'\n    }) : 0)(wonka.merge([wonka.map(mapTypeNames)(wonka.filter(op => !shouldSkip(op) && !isOperationCached(op))(ops$)), wonka.filter(op => shouldSkip(op))(ops$)])))));\n    return wonka.merge([cachedOps$, forwardedOps$]);\n  };\n};\n\n/** Reexecutes an `Operation` with the `network-only` request policy.\n * @internal\n */\nvar reexecuteOperation = (client, operation) => {\n  return client.reexecuteOperation(makeOperation(operation.kind, operation, {\n    requestPolicy: 'network-only'\n  }));\n};\n\n/** A serialized version of an {@link OperationResult}.\n *\n * @remarks\n * All properties are serialized separately as JSON strings, except for the\n * {@link CombinedError} to speed up JS parsing speed, even if a result doesn’t\n * end up being used.\n *\n * @internal\n */\n\n/** A dictionary of {@link Operation.key} keys to serializable {@link SerializedResult} objects.\n *\n * @remarks\n * It’s not recommended to modify the serialized data manually, however, multiple payloads of\n * this dictionary may safely be merged and combined.\n */\n\n/** Options for the `ssrExchange` allowing it to either operate on the server- or client-side. */\n\n/** An `SSRExchange` either in server-side mode, serializing results, or client-side mode, deserializing and replaying results..\n *\n * @remarks\n * This same {@link Exchange} is used in your code both for the client-side and server-side as it’s “universal”\n * and can be put into either client-side or server-side mode using the {@link SSRExchangeParams.isClient} flag.\n *\n * In server-side mode, the `ssrExchange` will “record” results it sees from your API and provide them for you\n * to send to the client-side using the {@link SSRExchange.extractData} method.\n *\n * In client-side mode, the `ssrExchange` will use these serialized results, rehydrated either using\n * {@link SSRExchange.restoreData} or {@link SSRexchangeParams.initialState}, to replay results the\n * server-side has seen and sent before.\n *\n * Each serialized result will only be replayed once, as it’s assumed that your cache exchange will have the\n * results cached afterwards.\n */\n\n/** Serialize an OperationResult to plain JSON */\nvar serializeResult = (result, includeExtensions) => {\n  var serialized = {\n    data: JSON.stringify(result.data),\n    hasNext: result.hasNext\n  };\n  if (result.data !== undefined) {\n    serialized.data = JSON.stringify(result.data);\n  }\n  if (includeExtensions && result.extensions !== undefined) {\n    serialized.extensions = JSON.stringify(result.extensions);\n  }\n  if (result.error) {\n    serialized.error = {\n      graphQLErrors: result.error.graphQLErrors.map(error => {\n        if (!error.path && !error.extensions) return error.message;\n        return {\n          message: error.message,\n          path: error.path,\n          extensions: error.extensions\n        };\n      })\n    };\n    if (result.error.networkError) {\n      serialized.error.networkError = '' + result.error.networkError;\n    }\n  }\n  return serialized;\n};\n\n/** Deserialize plain JSON to an OperationResult\n * @internal\n */\nvar deserializeResult = (operation, result, includeExtensions) => ({\n  operation,\n  data: result.data ? JSON.parse(result.data) : undefined,\n  extensions: includeExtensions && result.extensions ? JSON.parse(result.extensions) : undefined,\n  error: result.error ? new fetchSource.CombinedError({\n    networkError: result.error.networkError ? new Error(result.error.networkError) : undefined,\n    graphQLErrors: result.error.graphQLErrors\n  }) : undefined,\n  stale: false,\n  hasNext: !!result.hasNext\n});\nvar revalidated = new Set();\n\n/** Creates a server-side rendering `Exchange` that either captures responses on the server-side or replays them on the client-side.\n *\n * @param params - An {@link SSRExchangeParams} configuration object.\n * @returns the created {@link SSRExchange}\n *\n * @remarks\n * When dealing with server-side rendering, we essentially have two {@link Client | Clients} making requests,\n * the server-side client, and the client-side one. The `ssrExchange` helps implementing a tiny cache on both\n * sides that:\n *\n * - captures results on the server-side which it can serialize,\n * - replays results on the client-side that it deserialized from the server-side.\n *\n * Hint: The `ssrExchange` is basically an exchange that acts like a replacement for any fetch exchange\n * temporarily. As such, you should place it after your cache exchange but in front of any fetch exchange.\n */\nvar ssrExchange = (params = {}) => {\n  var staleWhileRevalidate = !!params.staleWhileRevalidate;\n  var includeExtensions = !!params.includeExtensions;\n  var data = {};\n\n  // On the client-side, we delete results from the cache as they're resolved\n  // this is delayed so that concurrent queries don't delete each other's data\n  var invalidateQueue = [];\n  var invalidate = result => {\n    invalidateQueue.push(result.operation.key);\n    if (invalidateQueue.length === 1) {\n      Promise.resolve().then(() => {\n        var key;\n        while (key = invalidateQueue.shift()) {\n          data[key] = null;\n        }\n      });\n    }\n  };\n\n  // The SSR Exchange is a temporary cache that can populate results into data for suspense\n  // On the client it can be used to retrieve these temporary results from a rehydrated cache\n  var ssr = ({\n    client,\n    forward\n  }) => ops$ => {\n    // params.isClient tells us whether we're on the client-side\n    // By default we assume that we're on the client if suspense-mode is disabled\n    var isClient = params && typeof params.isClient === 'boolean' ? !!params.isClient : !client.suspense;\n    var forwardedOps$ = forward(wonka.filter(operation => !data[operation.key] || !!data[operation.key].hasNext || operation.context.requestPolicy === 'network-only')(ops$));\n\n    // NOTE: Since below we might delete the cached entry after accessing\n    // it once, cachedOps$ needs to be merged after forwardedOps$\n    var cachedOps$ = wonka.map(op => {\n      var serialized = data[op.key];\n      var cachedResult = deserializeResult(op, serialized, includeExtensions);\n      if (staleWhileRevalidate && !revalidated.has(op.key)) {\n        cachedResult.stale = true;\n        revalidated.add(op.key);\n        reexecuteOperation(client, op);\n      }\n      var result = {\n        ...cachedResult,\n        operation:  true ? addMetadata(op, {\n          cacheOutcome: 'hit'\n        }) : 0\n      };\n      return result;\n    })(wonka.filter(operation => !!data[operation.key] && operation.context.requestPolicy !== 'network-only')(ops$));\n    if (!isClient) {\n      // On the server we cache results in the cache as they're resolved\n      forwardedOps$ = wonka.tap(result => {\n        var {\n          operation\n        } = result;\n        if (operation.kind !== 'mutation') {\n          var serialized = serializeResult(result, includeExtensions);\n          data[operation.key] = serialized;\n        }\n      })(forwardedOps$);\n    } else {\n      // On the client we delete results from the cache as they're resolved\n      cachedOps$ = wonka.tap(invalidate)(cachedOps$);\n    }\n    return wonka.merge([forwardedOps$, cachedOps$]);\n  };\n  ssr.restoreData = restore => {\n    for (var _key in restore) {\n      // We only restore data that hasn't been previously invalidated\n      if (data[_key] !== null) {\n        data[_key] = restore[_key];\n      }\n    }\n  };\n  ssr.extractData = () => {\n    var result = {};\n    for (var _key2 in data) if (data[_key2] != null) result[_key2] = data[_key2];\n    return result;\n  };\n  if (params && params.initialState) {\n    ssr.restoreData(params.initialState);\n  }\n  return ssr;\n};\n\n/** An abstract observer-like interface.\n *\n * @remarks\n * Observer-like interfaces are passed to {@link ObservableLike.subscribe} to provide them\n * with callbacks for their events.\n *\n * @see {@link https://github.com/tc39/proposal-observable} for the full TC39 Observable proposal.\n */\n\n/** An abstract observable-like interface.\n *\n * @remarks\n * Observable, or Observable-like interfaces, are often used by GraphQL transports to abstract\n * how they send {@link ExecutionResult | ExecutionResults} to consumers. These generally contain\n * a `subscribe` method accepting an {@link ObserverLike} structure.\n *\n * @see {@link https://github.com/tc39/proposal-observable} for the full TC39 Observable proposal.\n */\n\n/** A more cross-compatible version of the {@link GraphQLRequest} structure.\n * {@link FetchBody} for more details\n */\n\n/** A subscription forwarding function, which must accept a {@link SubscriptionOperation}.\n *\n * @param operation - A {@link SubscriptionOperation}\n * @returns An {@link ObservableLike} object issuing {@link ExecutionResult | ExecutionResults}.\n */\n\n/** This is called to create a subscription and needs to be hooked up to a transport client. */\n\n/** Generic subscription exchange factory used to either create an exchange handling just subscriptions or all operation kinds.\n *\n * @remarks\n * `subscriptionExchange` can be used to create an {@link Exchange} that either\n * handles just GraphQL subscription operations, or optionally all operations,\n * when the {@link SubscriptionExchangeOpts.enableAllOperations} flag is passed.\n *\n * The {@link SubscriptionExchangeOpts.forwardSubscription} function must\n * be provided and provides a generic input that's based on {@link Operation}\n * but is compatible with many libraries implementing GraphQL request or\n * subscription interfaces.\n */\nvar subscriptionExchange = ({\n  forwardSubscription,\n  enableAllOperations,\n  isSubscriptionOperation\n}) => ({\n  client,\n  forward\n}) => {\n  var createSubscriptionSource = operation => {\n    var observableish = forwardSubscription(fetchSource.makeFetchBody(operation), operation);\n    return wonka.make(({\n      next,\n      complete\n    }) => {\n      var isComplete = false;\n      var sub;\n      var result;\n      Promise.resolve().then(() => {\n        if (isComplete) return;\n        sub = observableish.subscribe({\n          next(nextResult) {\n            next(result = result ? fetchSource.mergeResultPatch(result, nextResult) : fetchSource.makeResult(operation, nextResult));\n          },\n          error(error) {\n            next(fetchSource.makeErrorResult(operation, error));\n          },\n          complete() {\n            if (!isComplete) {\n              isComplete = true;\n              if (operation.kind === 'subscription') {\n                client.reexecuteOperation(makeOperation('teardown', operation, operation.context));\n              }\n              if (result && result.hasNext) next(fetchSource.mergeResultPatch(result, {\n                hasNext: false\n              }));\n              complete();\n            }\n          }\n        });\n      });\n      return () => {\n        isComplete = true;\n        if (sub) sub.unsubscribe();\n      };\n    });\n  };\n  var isSubscriptionOperationFn = isSubscriptionOperation || (operation => operation.kind === 'subscription' || !!enableAllOperations && (operation.kind === 'query' || operation.kind === 'mutation'));\n  return ops$ => {\n    var subscriptionResults$ = wonka.mergeMap(operation => {\n      var {\n        key\n      } = operation;\n      var teardown$ = wonka.filter(op => op.kind === 'teardown' && op.key === key)(ops$);\n      return wonka.takeUntil(teardown$)(createSubscriptionSource(operation));\n    })(wonka.filter(operation => operation.kind !== 'teardown' && isSubscriptionOperationFn(operation))(ops$));\n    var forward$ = forward(wonka.filter(operation => operation.kind === 'teardown' || !isSubscriptionOperationFn(operation))(ops$));\n    return wonka.merge([subscriptionResults$, forward$]);\n  };\n};\n\n/** Simple log debugger exchange.\n *\n * @remarks\n * An exchange that logs incoming {@link Operation | Operations} and\n * {@link OperationResult | OperationResults} in development.\n *\n * This exchange is a no-op in production and often used in issue reporting\n * to understand certain usage patterns of `urql` without having access to\n * the original source code.\n *\n * Hint: When you report an issue you’re having with `urql`, adding\n * this as your first exchange and posting its output can speed up\n * issue triaging a lot!\n */\nvar debugExchange = ({\n  forward\n}) => {\n  if (false) {} else {\n    return ops$ => wonka.tap(result =>\n    // eslint-disable-next-line no-console\n    console.log('[Exchange debug]: Completed operation: ', result))(forward(\n    // eslint-disable-next-line no-console\n    wonka.tap(op => console.log('[Exchange debug]: Incoming operation: ', op))(ops$)));\n  }\n};\n\n/** Default deduplication exchange.\n * @deprecated\n * This exchange's functionality is now built into the {@link Client}.\n */\nvar dedupExchange = ({\n  forward\n}) => ops$ => forward(ops$);\n\n/* eslint-disable @typescript-eslint/no-use-before-define */\n\n/** Default GraphQL over HTTP fetch exchange.\n *\n * @remarks\n * The default fetch exchange in `urql` supports sending GraphQL over HTTP\n * requests, can optionally send GraphQL queries as GET requests, and\n * handles incremental multipart responses.\n *\n * This exchange does not handle persisted queries or multipart uploads.\n * Support for the former can be added using `@urql/exchange-persisted-fetch`\n * and the latter using `@urql/exchange-multipart-fetch`.\n *\n * Hint: The `fetchExchange` and the two other exchanges all use the built-in fetch\n * utilities in `@urql/core/internal`, which you can also use to implement\n * a customized fetch exchange.\n *\n * @see {@link makeFetchSource} for the shared utility calling the Fetch API.\n */\nvar fetchExchange = ({\n  forward,\n  dispatchDebug\n}) => {\n  return ops$ => {\n    var fetchResults$ = wonka.mergeMap(operation => {\n      var body = fetchSource.makeFetchBody(operation);\n      var url = fetchSource.makeFetchURL(operation, body);\n      var fetchOptions = fetchSource.makeFetchOptions(operation, body);\n       true ? dispatchDebug({\n        type: 'fetchRequest',\n        message: 'A fetch request is being executed.',\n        operation,\n        data: {\n          url,\n          fetchOptions\n        },\n        \"source\": \"fetchExchange\"\n      }) : 0;\n      var source = wonka.takeUntil(wonka.filter(op => op.kind === 'teardown' && op.key === operation.key)(ops$))(fetchSource.makeFetchSource(operation, url, fetchOptions));\n      if (true) {\n        return wonka.onPush(result => {\n          var error = !result.data ? result.error : undefined;\n           true ? dispatchDebug({\n            type: error ? 'fetchError' : 'fetchSuccess',\n            message: `A ${error ? 'failed' : 'successful'} fetch response has been returned.`,\n            operation,\n            data: {\n              url,\n              fetchOptions,\n              value: error || result\n            },\n            \"source\": \"fetchExchange\"\n          }) : 0;\n        })(source);\n      }\n      return source;\n    })(wonka.filter(operation => {\n      return operation.kind !== 'teardown' && (operation.kind !== 'subscription' || !!operation.context.fetchSubscriptions);\n    })(ops$));\n    var forward$ = forward(wonka.filter(operation => {\n      return operation.kind === 'teardown' || operation.kind === 'subscription' && !operation.context.fetchSubscriptions;\n    })(ops$));\n    return wonka.merge([fetchResults$, forward$]);\n  };\n};\n\n/** Composes an array of Exchanges into a single one.\n *\n * @param exchanges - An array of {@link Exchange | Exchanges}.\n * @returns - A composed {@link Exchange}.\n *\n * @remarks\n * `composeExchanges` returns an {@link Exchange} that when instantiated\n * composes the array of passed `Exchange`s into one, calling them from\n * right to left, with the prior `Exchange`’s {@link ExchangeIO} function\n * as the {@link ExchangeInput.forward} input.\n *\n * This simply merges all exchanges into one and is used by the {@link Client}\n * to merge the `exchanges` option it receives.\n *\n * @throws\n * In development, if {@link ExchangeInput.forward} is called repeatedly\n * by an {@link Exchange} an error is thrown, since `forward()` must only\n * be called once per `Exchange`.\n */\nvar composeExchanges = exchanges => ({\n  client,\n  forward,\n  dispatchDebug\n}) => exchanges.reduceRight((forward, exchange) => {\n  var forwarded = false;\n  return exchange({\n    client,\n    forward(operations$) {\n      if (true) {\n        if (forwarded) throw new Error('forward() must only be called once in each Exchange.');\n        forwarded = true;\n      }\n      return wonka.share(forward(wonka.share(operations$)));\n    },\n    dispatchDebug(event) {\n       true ? dispatchDebug({\n        timestamp: Date.now(),\n        source: exchange.name,\n        ...event\n      }) : 0;\n    }\n  });\n}, forward);\n\n/** Options for the `mapExchange` allowing it to react to incoming operations, results, or errors. */\n\n/** Creates an `Exchange` mapping over incoming operations, results, and/or errors.\n *\n * @param opts - A {@link MapExchangeOpts} configuration object, containing the callbacks the `mapExchange` will use.\n * @returns the created {@link Exchange}\n *\n * @remarks\n * The `mapExchange` may be used to react to or modify incoming {@link Operation | Operations}\n * and {@link OperationResult | OperationResults}. Optionally, it can also modify these\n * asynchronously, when a promise is returned from the callbacks.\n *\n * This is useful to, for instance, add an authentication token to a given request, when\n * the `@urql/exchange-auth` package would be overkill.\n *\n * It can also accept an `onError` callback, which can be used to react to incoming\n * {@link CombinedError | CombinedErrors} on results, and trigger side-effects.\n *\n */\nvar mapExchange = ({\n  onOperation,\n  onResult,\n  onError\n}) => {\n  return ({\n    forward\n  }) => ops$ => {\n    return wonka.mergeMap(result => {\n      if (onError && result.error) onError(result.error, result.operation);\n      var newResult = onResult && onResult(result) || result;\n      return 'then' in newResult ? wonka.fromPromise(newResult) : wonka.fromValue(newResult);\n    })(forward(wonka.mergeMap(operation => {\n      var newOperation = onOperation && onOperation(operation) || operation;\n      return 'then' in newOperation ? wonka.fromPromise(newOperation) : wonka.fromValue(newOperation);\n    })(ops$)));\n  };\n};\n\n/** Used by the `Client` as the last exchange to warn about unhandled operations.\n *\n * @remarks\n * In a normal setup, some operations may go unhandled when a {@link Client} isn’t set up\n * with the right exchanges.\n * For instance, a `Client` may be missing a fetch exchange, or an exchange handling subscriptions.\n * This {@link Exchange} is added by the `Client` automatically to log warnings about unhandled\n * {@link Operaiton | Operations} in development.\n */\nvar fallbackExchange = ({\n  dispatchDebug\n}) => ops$ => {\n  if (true) {\n    ops$ = wonka.tap(operation => {\n      if (operation.kind !== 'teardown' && \"development\" !== 'production') {\n        var message = `No exchange has handled operations of kind \"${operation.kind}\". Check whether you've added an exchange responsible for these operations.`;\n         true ? dispatchDebug({\n          type: 'fallbackCatch',\n          message,\n          operation,\n          \"source\": \"fallbackExchange\"\n        }) : 0;\n        console.warn(message);\n      }\n    })(ops$);\n  }\n\n  // All operations that skipped through the entire exchange chain should be filtered from the output\n  return wonka.filter(_x => false)(ops$);\n};\n\n/* eslint-disable @typescript-eslint/no-use-before-define */\n\n/** Configuration options passed when creating a new {@link Client}.\n *\n * @remarks\n * The `ClientOptions` are passed when creating a new {@link Client}, and\n * are used to instantiate the pipeline of {@link Exchange | Exchanges}, configure\n * options used to initialize {@link OperationContext | OperationContexts}, or to\n * change the general behaviour of the {@link Client}.\n */\n\n/** The `Client` is the central hub for your GraphQL operations and holds `urql`'s state.\n *\n * @remarks\n * The `Client` manages your active GraphQL operations and their state, and contains the\n * {@link Exchange} pipeline to execute your GraphQL operations.\n *\n * It contains methods that allow you to execute GraphQL operations manually, but the `Client`\n * is also interacted with by bindings (for React, Preact, Vue, Svelte, etc) to execute GraphQL\n * operations.\n *\n * While {@link Exchange | Exchanges} are ultimately responsible for the control flow of operations,\n * sending API requests, and caching, the `Client` still has the important responsibility for\n * creating operations, managing consumers of active operations, sharing results for operations,\n * and more tasks as a “central hub”.\n *\n * @see {@link https://urql.dev/goto/docs/architecture/#requests-and-operations-on-the-client} for more information\n * on what the `Client` is and does.\n */\n\nvar Client = function Client(opts) {\n  if ( true && !opts.url) {\n    throw new Error('You are creating an urql-client without a url.');\n  }\n  var ids = 0;\n  var replays = new Map();\n  var active = new Map();\n  var dispatched = new Set();\n  var queue = [];\n  var baseOpts = {\n    url: opts.url,\n    fetchSubscriptions: opts.fetchSubscriptions,\n    fetchOptions: opts.fetchOptions,\n    fetch: opts.fetch,\n    preferGetMethod: !!opts.preferGetMethod,\n    requestPolicy: opts.requestPolicy || 'cache-first'\n  };\n\n  // This subject forms the input of operations; executeOperation may be\n  // called to dispatch a new operation on the subject\n  var operations = wonka.makeSubject();\n  function nextOperation(operation) {\n    if (operation.kind === 'mutation' || operation.kind === 'teardown' || !dispatched.has(operation.key)) {\n      if (operation.kind === 'teardown') {\n        dispatched.delete(operation.key);\n      } else if (operation.kind !== 'mutation') {\n        dispatched.add(operation.key);\n      }\n      operations.next(operation);\n    }\n  }\n\n  // We define a queued dispatcher on the subject, which empties the queue when it's\n  // activated to allow `reexecuteOperation` to be trampoline-scheduled\n  var isOperationBatchActive = false;\n  function dispatchOperation(operation) {\n    if (operation) nextOperation(operation);\n    if (!isOperationBatchActive) {\n      isOperationBatchActive = true;\n      while (isOperationBatchActive && (operation = queue.shift())) nextOperation(operation);\n      isOperationBatchActive = false;\n    }\n  }\n\n  /** Defines how result streams are created */\n  var makeResultSource = operation => {\n    var result$ =\n    // End the results stream when an active teardown event is sent\n    wonka.takeUntil(wonka.filter(op => op.kind === 'teardown' && op.key === operation.key)(operations.source))(\n    // Filter by matching key (or _instance if it’s set)\n    wonka.filter(res => res.operation.kind === operation.kind && res.operation.key === operation.key && (!res.operation.context._instance || res.operation.context._instance === operation.context._instance))(results$));\n    if (operation.kind !== 'query') {\n      // Interrupt subscriptions and mutations when they have no more results\n      result$ = wonka.takeWhile(result => !!result.hasNext, true)(result$);\n    } else {\n      result$ =\n      // Add `stale: true` flag when a new operation is sent for queries\n      wonka.switchMap(result => {\n        var value$ = wonka.fromValue(result);\n        return result.stale || result.hasNext ? value$ : wonka.merge([value$, wonka.map(() => {\n          result.stale = true;\n          return result;\n        })(wonka.take(1)(wonka.filter(op => op.key === operation.key)(operations.source)))]);\n      })(result$);\n    }\n    if (operation.kind !== 'mutation') {\n      result$ =\n      // Cleanup active states on end of source\n      wonka.onEnd(() => {\n        // Delete the active operation handle\n        dispatched.delete(operation.key);\n        replays.delete(operation.key);\n        active.delete(operation.key);\n        // Interrupt active queue\n        isOperationBatchActive = false;\n        // Delete all queued up operations of the same key on end\n        for (var i = queue.length - 1; i >= 0; i--) if (queue[i].key === operation.key) queue.splice(i, 1);\n        // Dispatch a teardown signal for the stopped operation\n        nextOperation(makeOperation('teardown', operation, operation.context));\n      })(\n      // Store replay result\n      wonka.onPush(result => {\n        if (result.stale) {\n          // If the current result has queued up an operation of the same\n          // key, then `stale` refers to it\n          for (var _operation of queue) {\n            if (_operation.key === result.operation.key) {\n              dispatched.delete(_operation.key);\n              break;\n            }\n          }\n        } else if (!result.hasNext) {\n          dispatched.delete(operation.key);\n        }\n        replays.set(operation.key, result);\n      })(result$));\n    } else {\n      result$ =\n      // Send mutation operation on start\n      wonka.onStart(() => {\n        nextOperation(operation);\n      })(result$);\n    }\n\n    // Mask typename properties if the option for it is turned on\n    if (opts.maskTypename) {\n      result$ = wonka.map(res => ({\n        ...res,\n        data: maskTypename(res.data, true)\n      }))(result$);\n    }\n    return wonka.share(result$);\n  };\n  var instance = this instanceof Client ? this : Object.create(Client.prototype);\n  var client = Object.assign(instance, {\n    suspense: !!opts.suspense,\n    operations$: operations.source,\n    reexecuteOperation(operation) {\n      // Reexecute operation only if any subscribers are still subscribed to the\n      // operation's exchange results\n      if (operation.kind === 'teardown') {\n        dispatchOperation(operation);\n      } else if (operation.kind === 'mutation' || active.has(operation.key)) {\n        queue.push(operation);\n        Promise.resolve().then(dispatchOperation);\n      }\n    },\n    createRequestOperation(kind, request, opts) {\n      if (!opts) opts = {};\n      var requestOperationType;\n      if ( true && kind !== 'teardown' && (requestOperationType = fetchSource.getOperationType(request.query)) !== kind) {\n        throw new Error(`Expected operation of type \"${kind}\" but found \"${requestOperationType}\"`);\n      }\n      return makeOperation(kind, request, {\n        _instance: kind === 'mutation' ? ids = ids + 1 | 0 : undefined,\n        ...baseOpts,\n        ...opts,\n        requestPolicy: opts.requestPolicy || baseOpts.requestPolicy,\n        suspense: opts.suspense || opts.suspense !== false && client.suspense\n      });\n    },\n    executeRequestOperation(operation) {\n      if (operation.kind === 'mutation') {\n        return withPromise(makeResultSource(operation));\n      }\n      return withPromise(wonka.lazy(() => {\n        var source = active.get(operation.key);\n        if (!source) {\n          active.set(operation.key, source = makeResultSource(operation));\n        }\n        source = wonka.onStart(() => {\n          dispatchOperation(operation);\n        })(source);\n        var replay = replays.get(operation.key);\n        if (operation.kind === 'query' && replay && (replay.stale || replay.hasNext)) {\n          return wonka.switchMap(wonka.fromValue)(wonka.merge([source, wonka.filter(replay => replay === replays.get(operation.key))(wonka.fromValue(replay))]));\n        } else {\n          return source;\n        }\n      }));\n    },\n    executeQuery(query, opts) {\n      var operation = client.createRequestOperation('query', query, opts);\n      return client.executeRequestOperation(operation);\n    },\n    executeSubscription(query, opts) {\n      var operation = client.createRequestOperation('subscription', query, opts);\n      return client.executeRequestOperation(operation);\n    },\n    executeMutation(query, opts) {\n      var operation = client.createRequestOperation('mutation', query, opts);\n      return client.executeRequestOperation(operation);\n    },\n    readQuery(query, variables, context) {\n      var result = null;\n      wonka.subscribe(res => {\n        result = res;\n      })(client.query(query, variables, context)).unsubscribe();\n      return result;\n    },\n    query(query, variables, context) {\n      return client.executeQuery(fetchSource.createRequest(query, variables), context);\n    },\n    subscription(query, variables, context) {\n      return client.executeSubscription(fetchSource.createRequest(query, variables), context);\n    },\n    mutation(query, variables, context) {\n      return client.executeMutation(fetchSource.createRequest(query, variables), context);\n    }\n  });\n  var dispatchDebug = noop;\n  if (true) {\n    var {\n      next,\n      source\n    } = wonka.makeSubject();\n    client.subscribeToDebugTarget = onEvent => wonka.subscribe(onEvent)(source);\n    dispatchDebug = next;\n  }\n\n  // All exchange are composed into a single one and are called using the constructed client\n  // and the fallback exchange stream\n  var composedExchange = composeExchanges(opts.exchanges);\n\n  // All exchanges receive inputs using which they can forward operations to the next exchange\n  // and receive a stream of results in return, access the client, or dispatch debugging events\n  // All operations then run through the Exchange IOs in a pipeline-like fashion\n  var results$ = wonka.share(composedExchange({\n    client,\n    dispatchDebug,\n    forward: fallbackExchange({\n      dispatchDebug\n    })\n  })(operations.source));\n\n  // Prevent the `results$` exchange pipeline from being closed by active\n  // cancellations cascading up from components\n  wonka.publish(results$);\n  return client;\n};\n\n/** Accepts `ClientOptions` and creates a `Client`.\n * @param opts - A {@link ClientOptions} objects with options for the `Client`.\n * @returns A {@link Client} instantiated with `opts`.\n */\nvar createClient = Client;\n\nexports.CombinedError = fetchSource.CombinedError;\nexports.createRequest = fetchSource.createRequest;\nexports.makeErrorResult = fetchSource.makeErrorResult;\nexports.makeResult = fetchSource.makeResult;\nexports.mergeResultPatch = fetchSource.mergeResultPatch;\nexports.stringifyDocument = fetchSource.stringifyDocument;\nexports.stringifyVariables = fetchSource.stringifyVariables;\nexports.Client = Client;\nexports.cacheExchange = cacheExchange;\nexports.composeExchanges = composeExchanges;\nexports.createClient = createClient;\nexports.debugExchange = debugExchange;\nexports.dedupExchange = dedupExchange;\nexports.errorExchange = mapExchange;\nexports.fetchExchange = fetchExchange;\nexports.formatDocument = formatDocument;\nexports.gql = gql;\nexports.makeOperation = makeOperation;\nexports.mapExchange = mapExchange;\nexports.maskTypename = maskTypename;\nexports.ssrExchange = ssrExchange;\nexports.subscriptionExchange = subscriptionExchange;\n//# sourceMappingURL=urql-core.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHVycWwrY29yZUA0LjAuMTBfZ3JhcGhxbEAxNi4xMS4wL25vZGVfbW9kdWxlcy9AdXJxbC9jb3JlL2Rpc3QvdXJxbC1jb3JlLmpzIiwibWFwcGluZ3MiOiJBQUFBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0Qsa0JBQWtCLG1CQUFPLENBQUMscUtBQXFCO0FBQy9DLGtCQUFrQixtQkFBTyxDQUFDLHlKQUFzQjtBQUNoRCxZQUFZLG1CQUFPLENBQUMscUdBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QyxrQ0FBa0Msb0JBQW9CO0FBQ3REO0FBQ0E7QUFDQSxVQUFVLDRCQUE0QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0EsU0FBUyx5RUFBeUU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QkFBcUI7QUFDekMsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQix1QkFBdUI7QUFDdkIsa0JBQWtCO0FBQ2xCLHdCQUF3QjtBQUN4Qix5QkFBeUI7QUFDekIsMEJBQTBCO0FBQzFCLGNBQWM7QUFDZCxxQkFBcUI7QUFDckIsd0JBQXdCO0FBQ3hCLG9CQUFvQjtBQUNwQixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCLFdBQVc7QUFDWCxxQkFBcUI7QUFDckIsbUJBQW1CO0FBQ25CLG9CQUFvQjtBQUNwQixtQkFBbUI7QUFDbkIsNEJBQTRCO0FBQzVCIiwic291cmNlcyI6WyIvaG9tZS9taWNoYWVsL3NhbGVvci1wbGF0Zm9ybS9zYWxlb3ItYXBwcy9ub2RlX21vZHVsZXMvLnBucG0vQHVycWwrY29yZUA0LjAuMTBfZ3JhcGhxbEAxNi4xMS4wL25vZGVfbW9kdWxlcy9AdXJxbC9jb3JlL2Rpc3QvdXJxbC1jb3JlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBncmFwaHFsX3dlYiA9IHJlcXVpcmUoJ0Awbm8tY28vZ3JhcGhxbC53ZWInKTtcbnZhciBmZXRjaFNvdXJjZSA9IHJlcXVpcmUoJy4vdXJxbC1jb3JlLWNodW5rLmpzJyk7XG52YXIgd29ua2EgPSByZXF1aXJlKCd3b25rYScpO1xuXG52YXIgY29sbGVjdFR5cGVzID0gKG9iaiwgdHlwZXMpID0+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIGZvciAodmFyIGl0ZW0gb2Ygb2JqKSBjb2xsZWN0VHlwZXMoaXRlbSwgdHlwZXMpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCkge1xuICAgIGZvciAodmFyIF9rZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoX2tleSA9PT0gJ19fdHlwZW5hbWUnICYmIHR5cGVvZiBvYmpbX2tleV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHR5cGVzLmFkZChvYmpbX2tleV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sbGVjdFR5cGVzKG9ialtfa2V5XSwgdHlwZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHlwZXM7XG59O1xuXG4vKiogRmluZHMgYW5kIHJldHVybnMgYSBsaXN0IG9mIGBfX3R5cGVuYW1lYCBmaWVsZHMgZm91bmQgaW4gcmVzcG9uc2UgZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVJlbWFya3NcbiAqIFRoaXMgaXMgdXNlZCBieSBgQHVycWwvY29yZWDigJlzIGRvY3VtZW50IGBjYWNoZUV4Y2hhbmdlYCB0byBmaW5kIHR5cGVuYW1lc1xuICogaW4gYSBnaXZlbiBHcmFwaFFMIHJlc3BvbnNl4oCZcyBkYXRhLlxuICovXG52YXIgY29sbGVjdFR5cGVzRnJvbVJlc3BvbnNlID0gcmVzcG9uc2UgPT4gWy4uLmNvbGxlY3RUeXBlcyhyZXNwb25zZSwgbmV3IFNldCgpKV07XG52YXIgZm9ybWF0Tm9kZSA9IG5vZGUgPT4ge1xuICB2YXIgaGFzQ2hhbmdlZCA9IGZhbHNlO1xuICBpZiAoJ2RlZmluaXRpb25zJyBpbiBub2RlKSB7XG4gICAgdmFyIGRlZmluaXRpb25zID0gW107XG4gICAgZm9yICh2YXIgZGVmaW5pdGlvbiBvZiBub2RlLmRlZmluaXRpb25zKSB7XG4gICAgICB2YXIgbmV3RGVmaW5pdGlvbiA9IGZvcm1hdE5vZGUoZGVmaW5pdGlvbik7XG4gICAgICBoYXNDaGFuZ2VkID0gaGFzQ2hhbmdlZCB8fCBuZXdEZWZpbml0aW9uICE9PSBkZWZpbml0aW9uO1xuICAgICAgZGVmaW5pdGlvbnMucHVzaChuZXdEZWZpbml0aW9uKTtcbiAgICB9XG4gICAgaWYgKGhhc0NoYW5nZWQpIHJldHVybiB7XG4gICAgICAuLi5ub2RlLFxuICAgICAgZGVmaW5pdGlvbnNcbiAgICB9O1xuICB9IGVsc2UgaWYgKCdzZWxlY3Rpb25TZXQnIGluIG5vZGUpIHtcbiAgICB2YXIgc2VsZWN0aW9ucyA9IFtdO1xuICAgIHZhciBoYXNUeXBlbmFtZSA9IG5vZGUua2luZCA9PT0gZ3JhcGhxbF93ZWIuS2luZC5PUEVSQVRJT05fREVGSU5JVElPTjtcbiAgICBpZiAobm9kZS5zZWxlY3Rpb25TZXQpIHtcbiAgICAgIGZvciAodmFyIHNlbGVjdGlvbiBvZiBub2RlLnNlbGVjdGlvblNldC5zZWxlY3Rpb25zIHx8IFtdKSB7XG4gICAgICAgIGhhc1R5cGVuYW1lID0gaGFzVHlwZW5hbWUgfHwgc2VsZWN0aW9uLmtpbmQgPT09IGdyYXBocWxfd2ViLktpbmQuRklFTEQgJiYgc2VsZWN0aW9uLm5hbWUudmFsdWUgPT09ICdfX3R5cGVuYW1lJyAmJiAhc2VsZWN0aW9uLmFsaWFzO1xuICAgICAgICB2YXIgbmV3U2VsZWN0aW9uID0gZm9ybWF0Tm9kZShzZWxlY3Rpb24pO1xuICAgICAgICBoYXNDaGFuZ2VkID0gaGFzQ2hhbmdlZCB8fCBuZXdTZWxlY3Rpb24gIT09IHNlbGVjdGlvbjtcbiAgICAgICAgc2VsZWN0aW9ucy5wdXNoKG5ld1NlbGVjdGlvbik7XG4gICAgICB9XG4gICAgICBpZiAoIWhhc1R5cGVuYW1lKSB7XG4gICAgICAgIGhhc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICBzZWxlY3Rpb25zLnB1c2goe1xuICAgICAgICAgIGtpbmQ6IGdyYXBocWxfd2ViLktpbmQuRklFTEQsXG4gICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAga2luZDogZ3JhcGhxbF93ZWIuS2luZC5OQU1FLFxuICAgICAgICAgICAgdmFsdWU6ICdfX3R5cGVuYW1lJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoaGFzQ2hhbmdlZCkgcmV0dXJuIHtcbiAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgc2VsZWN0aW9uU2V0OiB7XG4gICAgICAgICAgLi4ubm9kZS5zZWxlY3Rpb25TZXQsXG4gICAgICAgICAgc2VsZWN0aW9uc1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9kZTtcbn07XG52YXIgZm9ybWF0dGVkRG9jcyA9IG5ldyBNYXAoKTtcblxuLyoqIEFkZHMgYF9fdHlwZW5hbWVgIGZpZWxkcyB0byBhIEdyYXBoUUwgYERvY3VtZW50Tm9kZWAuXG4gKlxuICogQHBhcmFtIG5vZGUgLSBhIHtAbGluayBEb2N1bWVudE5vZGV9LlxuICogQHJldHVybnMgYSBjb3B5IG9mIHRoZSBwYXNzZWQge0BsaW5rIERvY3VtZW50Tm9kZX0gd2l0aCBhZGRlZCBgX190eXBlbmFtZWAgaW50cm9zcGVjdGlvbiBmaWVsZHMuXG4gKlxuICogQHJlbWFya3NcbiAqIENhY2hlIHtAbGluayBFeGNoYW5nZSB8IEV4Y2hhbmdlc30gd2lsbCByZXF1aXJlIHR5cGVuYW1lIGludHJvc3BlY3Rpb24gdG9cbiAqIHJlY29nbml6ZSB0eXBlcyBpbiBhIEdyYXBoUUwgcmVzcG9uc2UuIFRvIHJldHJpZXZlIHRoZXNlIHR5cGVuYW1lcyxcbiAqIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBhZGQgdGhlIGBfX3R5cGVuYW1lYCBmaWVsZHMgdG8gbm9uLXJvb3RcbiAqIHNlbGVjdGlvbiBzZXRzIG9mIGEgR3JhcGhRTCBkb2N1bWVudC5cbiAqXG4gKiBUaGlzIHV0aWxpdHkgYWxzbyBwcmVzZXJ2ZXMgdGhlIGludGVybmFsbHkgY29tcHV0ZWQga2V5IG9mIHRoZVxuICogZG9jdW1lbnQgYXMgY3JlYXRlZCBieSB7QGxpbmsgY3JlYXRlUmVxdWVzdH0gdG8gYXZvaWQgYW55XG4gKiBmb3JtYXR0aW5nIGZyb20gYmVpbmcgZHVwbGljYXRlZC5cbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL3NwZWMuZ3JhcGhxbC5vcmcvT2N0b2JlcjIwMjEvI3NlYy1UeXBlLU5hbWUtSW50cm9zcGVjdGlvbn0gZm9yIG1vcmUgaW5mb3JtYXRpb25cbiAqIG9uIHR5cGVuYW1lIGludHJvc3BlY3Rpb24gdmlhIHRoZSBgX190eXBlbmFtZWAgZmllbGQuXG4gKi9cbnZhciBmb3JtYXREb2N1bWVudCA9IG5vZGUgPT4ge1xuICB2YXIgcXVlcnkgPSBmZXRjaFNvdXJjZS5rZXlEb2N1bWVudChub2RlKTtcbiAgdmFyIHJlc3VsdCA9IGZvcm1hdHRlZERvY3MuZ2V0KHF1ZXJ5Ll9fa2V5KTtcbiAgaWYgKCFyZXN1bHQpIHtcbiAgICBmb3JtYXR0ZWREb2NzLnNldChxdWVyeS5fX2tleSwgcmVzdWx0ID0gZm9ybWF0Tm9kZShxdWVyeSkpO1xuICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBoYXNoIG9mIHRoZSByZXN1bHRpbmcgZG9jdW1lbnQgd29uJ3Qgc3VkZGVubHkgY2hhbmdlXG4gICAgLy8gd2UgYXJlIG1hcmtpbmcgX19rZXkgYXMgbm9uLWVudW1lcmFibGUgc28gd2hlbiBleHRlcm5hbCBleGNoYW5nZXMgdXNlIHZpc2l0XG4gICAgLy8gdG8gbWFuaXB1bGF0ZSBhIGRvY3VtZW50IHdlIHdvbid0IHJlc3RvcmUgdGhlIHByZXZpb3VzIHF1ZXJ5IGR1ZSB0byB0aGUgX19rZXlcbiAgICAvLyBwcm9wZXJ0eS5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCAnX19rZXknLCB7XG4gICAgICB2YWx1ZTogcXVlcnkuX19rZXksXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKiogVXNlZCB0byByZWN1cnNpdmVseSBtYXJrIGBfX3R5cGVuYW1lYCBmaWVsZHMgaW4gZGF0YSBhcyBub24tZW51bWVyYWJsZS5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyB1dGlsaXR5IGNhbiBiZSB1c2VkIHRvIHJlY3Vyc2l2ZWx5IGNvcHkgR3JhcGhRbCByZXNwb25zZSBkYXRhIGFuZCBoaWRlXG4gKiBhbGwgYF9fdHlwZW5hbWVgIGZpZWxkcyBwcmVzZW50IG9uIGl0LlxuICpcbiAqIEhpbnQ6IEl04oCZcyBub3QgcmVjb21tZW5kZWQgdG8gZG8gdGhpcywgdW5sZXNzIGl0J3MgYWJzb2x1dGVseSBuZWNlc3NhcnkgYXNcbiAqIGNsb25pbmcgYW5kIG1vZGlmeWluZyBhbGwgZGF0YSBvZiBhIHJlc3BvbnNlIGNhbiBiZSB1bm5lY2Vzc2FyaWx5IHNsb3csIHdoZW5cbiAqIGEgbWFudWFsIGFuZCBtb3JlIHNwZWNpZmljIGNvcHkvbWFzayBpcyBtb3JlIGVmZmljaWVudC5cbiAqXG4gKiBAc2VlIHtAbGluayBDbGllbnRPcHRpb25zLm1hc2tUeXBlbmFtZX0gZm9yIGEgZGVzY3JpcHRpb24gb2YgaG93IHRoZSBgQ2xpZW50YCB1c2VzIHRoaXMgdXRpbGl0eS5cbiAqL1xudmFyIG1hc2tUeXBlbmFtZSA9IChkYXRhLCBpc1Jvb3QpID0+IHtcbiAgaWYgKCFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBkYXRhO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICByZXR1cm4gZGF0YS5tYXAoZCA9PiBtYXNrVHlwZW5hbWUoZCkpO1xuICB9IGVsc2UgaWYgKGRhdGEgJiYgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmIChpc1Jvb3QgfHwgJ19fdHlwZW5hbWUnIGluIGRhdGEpKSB7XG4gICAgdmFyIGFjYyA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICBpZiAoa2V5ID09PSAnX190eXBlbmFtZScpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFjYywgJ19fdHlwZW5hbWUnLCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgdmFsdWU6IGRhdGEuX190eXBlbmFtZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjY1trZXldID0gbWFza1R5cGVuYW1lKGRhdGFba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhY2M7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbn07XG5cbi8qKiBQYXRjaGVzIGEgYHRvUHJvbWlzZWAgbWV0aG9kIG9udG8gdGhlIGBTb3VyY2VgIHBhc3NlZCB0byBpdC5cbiAqIEBwYXJhbSBzb3VyY2UkIC0gdGhlIFdvbmthIHtAbGluayBTb3VyY2V9IHRvIHBhdGNoLlxuICogQHJldHVybnMgVGhlIHBhc3NlZCBgc291cmNlJGAgd2l0aCBhIHBhdGNoZWQgYHRvUHJvbWlzZWAgbWV0aG9kIGFzIGEge0BsaW5rIFByb21pc2lmaWVkU291cmNlfS5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB3aXRoUHJvbWlzZShfc291cmNlJCkge1xuICB2YXIgc291cmNlJCA9IHNpbmsgPT4gX3NvdXJjZSQoc2luayk7XG4gIHNvdXJjZSQudG9Qcm9taXNlID0gKCkgPT4gd29ua2EudG9Qcm9taXNlKHdvbmthLnRha2UoMSkod29ua2EuZmlsdGVyKHJlc3VsdCA9PiAhcmVzdWx0LnN0YWxlICYmICFyZXN1bHQuaGFzTmV4dCkoc291cmNlJCkpKTtcbiAgc291cmNlJC50aGVuID0gKG9uUmVzb2x2ZSwgb25SZWplY3QpID0+IHNvdXJjZSQudG9Qcm9taXNlKCkudGhlbihvblJlc29sdmUsIG9uUmVqZWN0KTtcbiAgc291cmNlJC5zdWJzY3JpYmUgPSBvblJlc3VsdCA9PiB3b25rYS5zdWJzY3JpYmUob25SZXN1bHQpKHNvdXJjZSQpO1xuICByZXR1cm4gc291cmNlJDtcbn1cblxuLyoqIENyZWF0ZXMgYSB7QGxpbmsgT3BlcmF0aW9ufSBmcm9tIHRoZSBnaXZlbiBwYXJhbWV0ZXJzLlxuICpcbiAqIEBwYXJhbSBraW5kIC0gVGhlIHtAbGluayBPcGVyYXRpb25UeXBlfSBvZiBHcmFwaFFMIG9wZXJhdGlvbiwgaS5lLiBgcXVlcnlgLCBgbXV0YXRpb25gLCBvciBgc3Vic2NyaXB0aW9uYC5cbiAqIEBwYXJhbSByZXF1ZXN0IC0gVGhlIHtAbGluayBHcmFwaFFMUmVxdWVzdH0gb3Ige0BsaW5rIE9wZXJhdGlvbn0gdXNlZCBhcyBhIHRlbXBsYXRlIGZvciB0aGUgbmV3IGBPcGVyYXRpb25gLlxuICogQHBhcmFtIGNvbnRleHQgLSBUaGUge0BsaW5rIE9wZXJhdGlvbkNvbnRleHR9IGBjb250ZXh0YCBkYXRhIGZvciB0aGUgYE9wZXJhdGlvbmAuXG4gKiBAcmV0dXJucyBBIG5ldyB7QGxpbmsgT3BlcmF0aW9ufS5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyBtZXRob2QgaXMgYm90aCB1c2VkIHRvIGNyZWF0ZSBuZXcge0BsaW5rIE9wZXJhdGlvbiB8IE9wZXJhdGlvbnN9IGFzIHdlbGwgYXMgY29weSBhbmQgbW9kaWZ5IGV4aXN0aW5nXG4gKiBvcGVyYXRpb25zLiBXaGlsZSBpdOKAmXMgbm90IHJlcXVpcmVkIHRvIHVzZSB0aGlzIGZ1bmN0aW9uIHRvIGNvcHkgYW4gYE9wZXJhdGlvbmAsIGl0IGlzIHJlY29tbWVuZGVkLCBpbiBjYXNlXG4gKiBhZGRpdGlvbmFsIGR5bmFtaWMgbG9naWMgaXMgYWRkZWQgdG8gdGhlbSBpbiB0aGUgZnV0dXJlLlxuICpcbiAqIEhpbnQ6IFdoZW4gYW4ge0BsaW5rIE9wZXJhdGlvbn0gaXMgcGFzc2VkIHRvIHRoZSBgcmVxdWVzdGAgYXJndW1lbnQsIHRoZSBgY29udGV4dGAgYXJndW1lbnQgZG9lcyBub3QgaGF2ZSB0byBiZVxuICogYSBjb21wbGV0ZSB7QGxpbmsgT3BlcmF0aW9uQ29udGV4dH0gYW5kIHdpbGwgaW5zdGVhZCBiZSBjb21iaW5lZCB3aXRoIHBhc3NlZCB7QGxpbmsgT3BlcmF0aW9uLmNvbnRleHR9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBBbiBleGFtcGxlIG9mIGNvcHlpbmcgYW4gZXhpc3RpbmcgYE9wZXJhdGlvbmAgdG8gbW9kaWZ5IGl0cyBgY29udGV4dGA6XG4gKlxuICogYGBgdHNcbiAqIG1ha2VPcGVyYXRpb24oXG4gKiAgIG9wZXJhdGlvbi5raW5kLFxuICogICBvcGVyYXRpb24sXG4gKiAgIHsgcmVxdWVzdFBvbGljeTogJ2NhY2hlLWZpcnN0JyB9LFxuICogKTtcbiAqIGBgYFxuICovXG5cbmZ1bmN0aW9uIG1ha2VPcGVyYXRpb24oa2luZCwgcmVxdWVzdCwgY29udGV4dCkge1xuICByZXR1cm4ge1xuICAgIC4uLnJlcXVlc3QsXG4gICAga2luZCxcbiAgICBjb250ZXh0OiByZXF1ZXN0LmNvbnRleHQgPyB7XG4gICAgICAuLi5yZXF1ZXN0LmNvbnRleHQsXG4gICAgICAuLi5jb250ZXh0XG4gICAgfSA6IGNvbnRleHQgfHwgcmVxdWVzdC5jb250ZXh0XG4gIH07XG59XG5cbi8qKiBBZGRzIGFkZGl0aW9uYWwgbWV0YWRhdGEgdG8gYW4gYE9wZXJhdGlvbmAncyBgY29udGV4dC5tZXRhYCBwcm9wZXJ0eSB3aGlsZSBjb3B5aW5nIGl0LlxuICogQHNlZSB7QGxpbmsgT3BlcmF0aW9uRGVidWdNZXRhfSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGUge0BsaW5rIE9wZXJhdGlvbkNvbnRleHQubWV0YX0gcHJvcGVydHkuXG4gKi9cbnZhciBhZGRNZXRhZGF0YSA9IChvcGVyYXRpb24sIG1ldGEpID0+IHtcbiAgcmV0dXJuIG1ha2VPcGVyYXRpb24ob3BlcmF0aW9uLmtpbmQsIG9wZXJhdGlvbiwge1xuICAgIG1ldGE6IHtcbiAgICAgIC4uLm9wZXJhdGlvbi5jb250ZXh0Lm1ldGEsXG4gICAgICAuLi5tZXRhXG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBub29wID0gKCkgPT4ge1xuICAvKiBub29wICovXG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItcmVzdC1wYXJhbXMgKi9cblxuLyoqIEEgR3JhcGhRTCBwYXJzZSBmdW5jdGlvbiwgd2hpY2ggbWF5IGJlIGNhbGxlZCBhcyBhIHRhZ2dlZCB0ZW1wbGF0ZSBsaXRlcmFsLCByZXR1cm5pbmcgYSBwYXJzZWQge0BsaW5rIERvY3VtZW50Tm9kZX0uXG4gKlxuICogQHJlbWFya3NcbiAqIFRoZSBgZ3FsYCB0YWcgb3IgZnVuY3Rpb24gaXMgdXNlZCB0byBwYXJzZSBhIEdyYXBoUUwgcXVlcnkgZG9jdW1lbnQgaW50byBhIHtAbGluayBEb2N1bWVudE5vZGV9LlxuICpcbiAqIFdoZW4gdXNlZCBhcyBhIHRhZ2dlZCB0ZW1wbGF0ZSwgYGdxbGAgd2lsbCBhdXRvbWF0aWNhbGx5IG1lcmdlIGZyYWdtZW50IGRlZmluaXRpb25zIGludG8gdGhlIHJlc3VsdGluZ1xuICogZG9jdW1lbnQgYW5kIGRlZHVwbGljYXRlIHRoZW0uXG4gKlxuICogSXQgZW5mb3JjZXMgdGhhdCBhbGwgZnJhZ21lbnRzIGhhdmUgYSB1bmlxdWUgbmFtZS4gV2hlbiBmcmFnbWVudHMgd2l0aCBkaWZmZXJlbnQgZGVmaW5pdGlvbnMgc2hhcmUgYSBuYW1lLFxuICogaXQgd2lsbCBsb2cgYSB3YXJuaW5nIGluIGRldmVsb3BtZW50LlxuICpcbiAqIEhpbnQ6IEl04oCZcyByZWNvbW1lbmRlZCB0byB1c2UgdGhpcyBgZ3FsYCBmdW5jdGlvbiBvdmVyIG90aGVyIEdyYXBoUUwgcGFyc2UgZnVuY3Rpb25zLCBzaW5jZSBpdCBwdXRzIHRoZSBwYXJzZWRcbiAqIHJlc3VsdHMgZGlyZWN0bHkgaW50byBgQHVycWwvY29yZWDigJlzIGludGVybmFsIGNhY2hlcyBhbmQgcHJldmVudHMgZnVydGhlciB1bm5lY2Vzc2FyeSB3b3JrLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogY29uc3QgQXV0aG9yRnJhZ21lbnQgPSBncWxgXG4gKiAgIGZyYWdtZW50IEF1dGhvckRpc3BsYXlDb21wb25lbnQgb24gQXV0aG9yIHtcbiAqICAgICBpZFxuICogICAgIG5hbWVcbiAqICAgfVxuICogYDtcbiAqXG4gKiBjb25zdCBCb29rRnJhZ21lbnQgPSBncWxgXG4gKiAgIGZyYWdtZW50IExpc3RCb29rQ29tcG9uZW50IG9uIEJvb2sge1xuICogICAgIGlkXG4gKiAgICAgdGl0bGVcbiAqICAgICBhdXRob3Ige1xuICogICAgICAgLi4uQXV0aG9yRGlzcGxheUNvbXBvbmVudFxuICogICAgIH1cbiAqICAgfVxuICpcbiAqICAgJHtBdXRob3JGcmFnbWVudH1cbiAqIGA7XG4gKlxuICogY29uc3QgQm9va1F1ZXJ5ID0gZ3FsYFxuICogICBxdWVyeSBCb29rKCRpZDogSUQhKSB7XG4gKiAgICAgYm9vayhpZDogJGlkKSB7XG4gKiAgICAgICAuLi5Cb29rRnJhZ21lbnRcbiAqICAgICB9XG4gKiAgIH1cbiAqXG4gKiAgICR7Qm9va0ZyYWdtZW50fVxuICogYDtcbiAqIGBgYFxuICovXG5cbmZ1bmN0aW9uIGdxbChwYXJ0cykge1xuICB2YXIgZnJhZ21lbnROYW1lcyA9IG5ldyBNYXAoKTtcbiAgdmFyIGRlZmluaXRpb25zID0gW107XG4gIHZhciBzb3VyY2UgPSBbXTtcblxuICAvLyBBcHBseSB0aGUgZW50aXJlIHRhZ2dlZCB0ZW1wbGF0ZSBib2R5J3MgZGVmaW5pdGlvbnNcbiAgdmFyIGJvZHkgPSBBcnJheS5pc0FycmF5KHBhcnRzKSA/IHBhcnRzWzBdIDogcGFydHMgfHwgJyc7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHZhbHVlID0gYXJndW1lbnRzW2ldO1xuICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5kZWZpbml0aW9ucykge1xuICAgICAgc291cmNlLnB1c2godmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBib2R5ICs9IHZhbHVlO1xuICAgIH1cbiAgICBib2R5ICs9IGFyZ3VtZW50c1swXVtpXTtcbiAgfVxuICBzb3VyY2UudW5zaGlmdChmZXRjaFNvdXJjZS5rZXlEb2N1bWVudChib2R5KSk7XG4gIGZvciAodmFyIGRvY3VtZW50IG9mIHNvdXJjZSkge1xuICAgIGZvciAodmFyIGRlZmluaXRpb24gb2YgZG9jdW1lbnQuZGVmaW5pdGlvbnMpIHtcbiAgICAgIGlmIChkZWZpbml0aW9uLmtpbmQgPT09IGdyYXBocWxfd2ViLktpbmQuRlJBR01FTlRfREVGSU5JVElPTikge1xuICAgICAgICB2YXIgbmFtZSA9IGRlZmluaXRpb24ubmFtZS52YWx1ZTtcbiAgICAgICAgdmFyIF92YWx1ZSA9IGZldGNoU291cmNlLnN0cmluZ2lmeURvY3VtZW50KGRlZmluaXRpb24pO1xuICAgICAgICAvLyBGcmFnbWVudHMgd2lsbCBiZSBkZWR1cGxpY2F0ZWQgYWNjb3JkaW5nIHRvIHRoaXMgTWFwXG4gICAgICAgIGlmICghZnJhZ21lbnROYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICBmcmFnbWVudE5hbWVzLnNldChuYW1lLCBfdmFsdWUpO1xuICAgICAgICAgIGRlZmluaXRpb25zLnB1c2goZGVmaW5pdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBmcmFnbWVudE5hbWVzLmdldChuYW1lKSAhPT0gX3ZhbHVlKSB7XG4gICAgICAgICAgLy8gRnJhZ21lbnRzIHdpdGggdGhlIHNhbWUgbmFtZXMgaXMgZXhwZWN0ZWQgdG8gaGF2ZSB0aGUgc2FtZSBjb250ZW50c1xuICAgICAgICAgIGNvbnNvbGUud2FybignW1dBUk5JTkc6IER1cGxpY2F0ZSBGcmFnbWVudF0gQSBmcmFnbWVudCB3aXRoIG5hbWUgYCcgKyBuYW1lICsgJ2AgYWxyZWFkeSBleGlzdHMgaW4gdGhpcyBkb2N1bWVudC5cXG4nICsgJ1doaWxlIGZyYWdtZW50IG5hbWVzIG1heSBub3QgYmUgdW5pcXVlIGFjcm9zcyB5b3VyIHNvdXJjZSwgZWFjaCBuYW1lIG11c3QgYmUgdW5pcXVlIHBlciBkb2N1bWVudC4nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmaW5pdGlvbnMucHVzaChkZWZpbml0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZldGNoU291cmNlLmtleURvY3VtZW50KHtcbiAgICBraW5kOiBncmFwaHFsX3dlYi5LaW5kLkRPQ1VNRU5ULFxuICAgIGRlZmluaXRpb25zXG4gIH0pO1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmUgKi9cbnZhciBzaG91bGRTa2lwID0gKHtcbiAga2luZFxufSkgPT4ga2luZCAhPT0gJ211dGF0aW9uJyAmJiBraW5kICE9PSAncXVlcnknO1xuXG4vKiogRGVmYXVsdCBkb2N1bWVudCBjYWNoZSBleGNoYW5nZS5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhlIGRlZmF1bHQgZG9jdW1lbnQgY2FjaGUgaW4gYHVycWxgIGF2b2lkcyBzZW5kaW5nIHRoZSBzYW1lIEdyYXBoUUwgcmVxdWVzdFxuICogbXVsdGlwbGUgdGltZXMgYnkgY2FjaGluZyBpdCB1c2luZyB0aGUge0BsaW5rIE9wZXJhdGlvbi5rZXl9LiBJdCB3aWxsIGludmFsaWRhdGVcbiAqIHF1ZXJ5IHJlc3VsdHMgYXV0b21hdGljYWxseSB3aGVuZXZlciBpdCBzZWVzIGEgbXV0YXRpb24gcmVzcG9uc2VzIHdpdGggbWF0Y2hpbmdcbiAqIGBfX3R5cGVuYW1lYHMgaW4gdGhlaXIgcmVzcG9uc2VzLlxuICpcbiAqIFRoZSBkb2N1bWVudCBjYWNoZSB3aWxsIGdldCB0aGUgaW50cm9zcGVjdGVkIGBfX3R5cGVuYW1lYCBmaWVsZHMgYnkgbW9kaWZ5aW5nXG4gKiB5b3VyIEdyYXBoUUwgb3BlcmF0aW9uIGRvY3VtZW50cyB1c2luZyB0aGUge0BsaW5rIGZvcm1hdERvY3VtZW50fSB1dGlsaXR5LlxuICpcbiAqIFRoaXMgYXV0b21hdGljIGludmFsaWRhdGlvbiBzdHJhdGVneSBjYW4gZmFpbCBpZiB5b3VyIHF1ZXJ5IG9yIG11dGF0aW9uIGRvbuKAmXRcbiAqIGNvbnRhaW4gbWF0Y2hpbmcgdHlwZW5hbWVzLCBmb3IgaW5zdGFuY2UsIGJlY2F1c2UgdGhlIHF1ZXJ5IGNvbnRhaW5lZCBhblxuICogZW1wdHkgbGlzdC5cbiAqIFlvdSBjYW4gbWFudWFsbHkgYWRkIGhpbnRzIGZvciB0aGlzIGV4Y2hhbmdlIGJ5IHNwZWNpZnlpbmcgYSBsaXN0IG9mXG4gKiB7QGxpbmsgT3BlcmF0aW9uQ29udGV4dC5hZGRpdGlvbmFsVHlwZW5hbWVzfSBmb3IgcXVlcmllcyBhbmQgbXV0YXRpb25zIHRoYXRcbiAqIHNob3VsZCBpbnZhbGlkYXRlIG9uZSBhbm90aGVyLlxuICpcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdXJxbC5kZXYvZ290by9kb2NzL2Jhc2ljcy9kb2N1bWVudC1jYWNoaW5nfSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGlzIGNhY2hlLlxuICovXG52YXIgY2FjaGVFeGNoYW5nZSA9ICh7XG4gIGZvcndhcmQsXG4gIGNsaWVudCxcbiAgZGlzcGF0Y2hEZWJ1Z1xufSkgPT4ge1xuICB2YXIgcmVzdWx0Q2FjaGUgPSBuZXcgTWFwKCk7XG4gIHZhciBvcGVyYXRpb25DYWNoZSA9IG5ldyBNYXAoKTtcblxuICAvLyBBZGRzIHVuaXF1ZSB0eXBlbmFtZXMgdG8gcXVlcnkgKGZvciBpbnZhbGlkYXRpbmcgY2FjaGUgZW50cmllcylcbiAgdmFyIG1hcFR5cGVOYW1lcyA9IG9wZXJhdGlvbiA9PiB7XG4gICAgdmFyIGZvcm1hdHRlZE9wZXJhdGlvbiA9IG1ha2VPcGVyYXRpb24ob3BlcmF0aW9uLmtpbmQsIG9wZXJhdGlvbik7XG4gICAgZm9ybWF0dGVkT3BlcmF0aW9uLnF1ZXJ5ID0gZm9ybWF0RG9jdW1lbnQob3BlcmF0aW9uLnF1ZXJ5KTtcbiAgICByZXR1cm4gZm9ybWF0dGVkT3BlcmF0aW9uO1xuICB9O1xuICB2YXIgaXNPcGVyYXRpb25DYWNoZWQgPSBvcGVyYXRpb24gPT4gb3BlcmF0aW9uLmtpbmQgPT09ICdxdWVyeScgJiYgb3BlcmF0aW9uLmNvbnRleHQucmVxdWVzdFBvbGljeSAhPT0gJ25ldHdvcmstb25seScgJiYgKG9wZXJhdGlvbi5jb250ZXh0LnJlcXVlc3RQb2xpY3kgPT09ICdjYWNoZS1vbmx5JyB8fCByZXN1bHRDYWNoZS5oYXMob3BlcmF0aW9uLmtleSkpO1xuICByZXR1cm4gb3BzJCA9PiB7XG4gICAgdmFyIGNhY2hlZE9wcyQgPSB3b25rYS5tYXAob3BlcmF0aW9uID0+IHtcbiAgICAgIHZhciBjYWNoZWRSZXN1bHQgPSByZXN1bHRDYWNoZS5nZXQob3BlcmF0aW9uLmtleSk7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gZGlzcGF0Y2hEZWJ1Zyh7XG4gICAgICAgIG9wZXJhdGlvbixcbiAgICAgICAgLi4uKGNhY2hlZFJlc3VsdCA/IHtcbiAgICAgICAgICB0eXBlOiAnY2FjaGVIaXQnLFxuICAgICAgICAgIG1lc3NhZ2U6ICdUaGUgcmVzdWx0IHdhcyBzdWNjZXNzZnVsbHkgcmV0cmllZCBmcm9tIHRoZSBjYWNoZSdcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICB0eXBlOiAnY2FjaGVNaXNzJyxcbiAgICAgICAgICBtZXNzYWdlOiAnVGhlIHJlc3VsdCBjb3VsZCBub3QgYmUgcmV0cmlldmVkIGZyb20gdGhlIGNhY2hlJ1xuICAgICAgICB9KSxcbiAgICAgICAgXCJzb3VyY2VcIjogXCJjYWNoZUV4Y2hhbmdlXCJcbiAgICAgIH0pIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIHJlc3VsdCA9IGNhY2hlZFJlc3VsdDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgICAgb3BlcmF0aW9uOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gYWRkTWV0YWRhdGEob3BlcmF0aW9uLCB7XG4gICAgICAgICAgICBjYWNoZU91dGNvbWU6IGNhY2hlZFJlc3VsdCA/ICdoaXQnIDogJ21pc3MnXG4gICAgICAgICAgfSkgOiBvcGVyYXRpb25cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChvcGVyYXRpb24uY29udGV4dC5yZXF1ZXN0UG9saWN5ID09PSAnY2FjaGUtYW5kLW5ldHdvcmsnKSB7XG4gICAgICAgIHJlc3VsdC5zdGFsZSA9IHRydWU7XG4gICAgICAgIHJlZXhlY3V0ZU9wZXJhdGlvbihjbGllbnQsIG9wZXJhdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pKHdvbmthLmZpbHRlcihvcCA9PiAhc2hvdWxkU2tpcChvcCkgJiYgaXNPcGVyYXRpb25DYWNoZWQob3ApKShvcHMkKSk7XG4gICAgdmFyIGZvcndhcmRlZE9wcyQgPSB3b25rYS50YXAocmVzcG9uc2UgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgb3BlcmF0aW9uXG4gICAgICB9ID0gcmVzcG9uc2U7XG4gICAgICBpZiAoIW9wZXJhdGlvbikgcmV0dXJuO1xuICAgICAgdmFyIHR5cGVuYW1lcyA9IG9wZXJhdGlvbi5jb250ZXh0LmFkZGl0aW9uYWxUeXBlbmFtZXMgfHwgW107XG4gICAgICAvLyBOT1RFOiBGb3Igbm93LCB3ZSBvbmx5IHJlc3BlY3QgYGFkZGl0aW9uYWxUeXBlbmFtZXNgIGZyb20gc3Vic2NyaXB0aW9ucyB0b1xuICAgICAgLy8gYXZvaWQgdW5leHBlY3RlZCBicmVha2luZyBjaGFuZ2VzXG4gICAgICAvLyBXZSdkIGV4cGVjdCBsaXZlIHF1ZXJpZXMgb3Igb3RoZXIgdXBkYXRlIG1lY2hhbmlzbXMgdG8gYmUgbW9yZSBzdWl0YWJsZSByYXRoZXJcbiAgICAgIC8vIHRoYW4gdXNpbmcgc3Vic2NyaXB0aW9ucyBhcyDigJxzaWduYWxz4oCdIHRvIHJlZXhlY3V0ZSBxdWVyaWVzLiBIb3dldmVyLCBpZiB0aGV54oCZcmVcbiAgICAgIC8vIGp1c3QgdXNlZCBhcyBzaWduYWxzLCBpdOKAmXMgaW50dWl0aXZlIHRvIGhvb2sgdGhlbSB1cCB1c2luZyBgYWRkaXRpb25hbFR5cGVuYW1lc2BcbiAgICAgIGlmIChyZXNwb25zZS5vcGVyYXRpb24ua2luZCAhPT0gJ3N1YnNjcmlwdGlvbicpIHtcbiAgICAgICAgdHlwZW5hbWVzID0gY29sbGVjdFR5cGVzRnJvbVJlc3BvbnNlKHJlc3BvbnNlLmRhdGEpLmNvbmNhdCh0eXBlbmFtZXMpO1xuICAgICAgfVxuXG4gICAgICAvLyBJbnZhbGlkYXRlcyB0aGUgY2FjaGUgZ2l2ZW4gYSBtdXRhdGlvbidzIHJlc3BvbnNlXG4gICAgICBpZiAocmVzcG9uc2Uub3BlcmF0aW9uLmtpbmQgPT09ICdtdXRhdGlvbicgfHwgcmVzcG9uc2Uub3BlcmF0aW9uLmtpbmQgPT09ICdzdWJzY3JpcHRpb24nKSB7XG4gICAgICAgIHZhciBwZW5kaW5nT3BlcmF0aW9ucyA9IG5ldyBTZXQoKTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGRpc3BhdGNoRGVidWcoe1xuICAgICAgICAgIHR5cGU6ICdjYWNoZUludmFsaWRhdGlvbicsXG4gICAgICAgICAgbWVzc2FnZTogYFRoZSBmb2xsb3dpbmcgdHlwZW5hbWVzIGhhdmUgYmVlbiBpbnZhbGlkYXRlZDogJHt0eXBlbmFtZXN9YCxcbiAgICAgICAgICBvcGVyYXRpb24sXG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgdHlwZW5hbWVzLFxuICAgICAgICAgICAgcmVzcG9uc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic291cmNlXCI6IFwiY2FjaGVFeGNoYW5nZVwiXG4gICAgICAgIH0pIDogdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciB0eXBlTmFtZSA9IHR5cGVuYW1lc1tpXTtcbiAgICAgICAgICB2YXIgb3BlcmF0aW9ucyA9IG9wZXJhdGlvbkNhY2hlLmdldCh0eXBlTmFtZSk7XG4gICAgICAgICAgaWYgKCFvcGVyYXRpb25zKSBvcGVyYXRpb25DYWNoZS5zZXQodHlwZU5hbWUsIG9wZXJhdGlvbnMgPSBuZXcgU2V0KCkpO1xuICAgICAgICAgIGZvciAodmFyIGtleSBvZiBvcGVyYXRpb25zLnZhbHVlcygpKSBwZW5kaW5nT3BlcmF0aW9ucy5hZGQoa2V5KTtcbiAgICAgICAgICBvcGVyYXRpb25zLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2tleSBvZiBwZW5kaW5nT3BlcmF0aW9ucy52YWx1ZXMoKSkge1xuICAgICAgICAgIGlmIChyZXN1bHRDYWNoZS5oYXMoX2tleSkpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IHJlc3VsdENhY2hlLmdldChfa2V5KS5vcGVyYXRpb247XG4gICAgICAgICAgICByZXN1bHRDYWNoZS5kZWxldGUoX2tleSk7XG4gICAgICAgICAgICByZWV4ZWN1dGVPcGVyYXRpb24oY2xpZW50LCBvcGVyYXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24ua2luZCA9PT0gJ3F1ZXJ5JyAmJiByZXNwb25zZS5kYXRhKSB7XG4gICAgICAgIHJlc3VsdENhY2hlLnNldChvcGVyYXRpb24ua2V5LCByZXNwb25zZSk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0eXBlbmFtZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgdmFyIF90eXBlTmFtZSA9IHR5cGVuYW1lc1tfaV07XG4gICAgICAgICAgdmFyIF9vcGVyYXRpb25zID0gb3BlcmF0aW9uQ2FjaGUuZ2V0KF90eXBlTmFtZSk7XG4gICAgICAgICAgaWYgKCFfb3BlcmF0aW9ucykgb3BlcmF0aW9uQ2FjaGUuc2V0KF90eXBlTmFtZSwgX29wZXJhdGlvbnMgPSBuZXcgU2V0KCkpO1xuICAgICAgICAgIF9vcGVyYXRpb25zLmFkZChvcGVyYXRpb24ua2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKGZvcndhcmQod29ua2EuZmlsdGVyKG9wID0+IG9wLmtpbmQgIT09ICdxdWVyeScgfHwgb3AuY29udGV4dC5yZXF1ZXN0UG9saWN5ICE9PSAnY2FjaGUtb25seScpKHdvbmthLm1hcChvcCA9PiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gYWRkTWV0YWRhdGEob3AsIHtcbiAgICAgIGNhY2hlT3V0Y29tZTogJ21pc3MnXG4gICAgfSkgOiBvcCkod29ua2EubWVyZ2UoW3dvbmthLm1hcChtYXBUeXBlTmFtZXMpKHdvbmthLmZpbHRlcihvcCA9PiAhc2hvdWxkU2tpcChvcCkgJiYgIWlzT3BlcmF0aW9uQ2FjaGVkKG9wKSkob3BzJCkpLCB3b25rYS5maWx0ZXIob3AgPT4gc2hvdWxkU2tpcChvcCkpKG9wcyQpXSkpKSkpO1xuICAgIHJldHVybiB3b25rYS5tZXJnZShbY2FjaGVkT3BzJCwgZm9yd2FyZGVkT3BzJF0pO1xuICB9O1xufTtcblxuLyoqIFJlZXhlY3V0ZXMgYW4gYE9wZXJhdGlvbmAgd2l0aCB0aGUgYG5ldHdvcmstb25seWAgcmVxdWVzdCBwb2xpY3kuXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIHJlZXhlY3V0ZU9wZXJhdGlvbiA9IChjbGllbnQsIG9wZXJhdGlvbikgPT4ge1xuICByZXR1cm4gY2xpZW50LnJlZXhlY3V0ZU9wZXJhdGlvbihtYWtlT3BlcmF0aW9uKG9wZXJhdGlvbi5raW5kLCBvcGVyYXRpb24sIHtcbiAgICByZXF1ZXN0UG9saWN5OiAnbmV0d29yay1vbmx5J1xuICB9KSk7XG59O1xuXG4vKiogQSBzZXJpYWxpemVkIHZlcnNpb24gb2YgYW4ge0BsaW5rIE9wZXJhdGlvblJlc3VsdH0uXG4gKlxuICogQHJlbWFya3NcbiAqIEFsbCBwcm9wZXJ0aWVzIGFyZSBzZXJpYWxpemVkIHNlcGFyYXRlbHkgYXMgSlNPTiBzdHJpbmdzLCBleGNlcHQgZm9yIHRoZVxuICoge0BsaW5rIENvbWJpbmVkRXJyb3J9IHRvIHNwZWVkIHVwIEpTIHBhcnNpbmcgc3BlZWQsIGV2ZW4gaWYgYSByZXN1bHQgZG9lc27igJl0XG4gKiBlbmQgdXAgYmVpbmcgdXNlZC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG4vKiogQSBkaWN0aW9uYXJ5IG9mIHtAbGluayBPcGVyYXRpb24ua2V5fSBrZXlzIHRvIHNlcmlhbGl6YWJsZSB7QGxpbmsgU2VyaWFsaXplZFJlc3VsdH0gb2JqZWN0cy5cbiAqXG4gKiBAcmVtYXJrc1xuICogSXTigJlzIG5vdCByZWNvbW1lbmRlZCB0byBtb2RpZnkgdGhlIHNlcmlhbGl6ZWQgZGF0YSBtYW51YWxseSwgaG93ZXZlciwgbXVsdGlwbGUgcGF5bG9hZHMgb2ZcbiAqIHRoaXMgZGljdGlvbmFyeSBtYXkgc2FmZWx5IGJlIG1lcmdlZCBhbmQgY29tYmluZWQuXG4gKi9cblxuLyoqIE9wdGlvbnMgZm9yIHRoZSBgc3NyRXhjaGFuZ2VgIGFsbG93aW5nIGl0IHRvIGVpdGhlciBvcGVyYXRlIG9uIHRoZSBzZXJ2ZXItIG9yIGNsaWVudC1zaWRlLiAqL1xuXG4vKiogQW4gYFNTUkV4Y2hhbmdlYCBlaXRoZXIgaW4gc2VydmVyLXNpZGUgbW9kZSwgc2VyaWFsaXppbmcgcmVzdWx0cywgb3IgY2xpZW50LXNpZGUgbW9kZSwgZGVzZXJpYWxpemluZyBhbmQgcmVwbGF5aW5nIHJlc3VsdHMuLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIHNhbWUge0BsaW5rIEV4Y2hhbmdlfSBpcyB1c2VkIGluIHlvdXIgY29kZSBib3RoIGZvciB0aGUgY2xpZW50LXNpZGUgYW5kIHNlcnZlci1zaWRlIGFzIGl04oCZcyDigJx1bml2ZXJzYWzigJ1cbiAqIGFuZCBjYW4gYmUgcHV0IGludG8gZWl0aGVyIGNsaWVudC1zaWRlIG9yIHNlcnZlci1zaWRlIG1vZGUgdXNpbmcgdGhlIHtAbGluayBTU1JFeGNoYW5nZVBhcmFtcy5pc0NsaWVudH0gZmxhZy5cbiAqXG4gKiBJbiBzZXJ2ZXItc2lkZSBtb2RlLCB0aGUgYHNzckV4Y2hhbmdlYCB3aWxsIOKAnHJlY29yZOKAnSByZXN1bHRzIGl0IHNlZXMgZnJvbSB5b3VyIEFQSSBhbmQgcHJvdmlkZSB0aGVtIGZvciB5b3VcbiAqIHRvIHNlbmQgdG8gdGhlIGNsaWVudC1zaWRlIHVzaW5nIHRoZSB7QGxpbmsgU1NSRXhjaGFuZ2UuZXh0cmFjdERhdGF9IG1ldGhvZC5cbiAqXG4gKiBJbiBjbGllbnQtc2lkZSBtb2RlLCB0aGUgYHNzckV4Y2hhbmdlYCB3aWxsIHVzZSB0aGVzZSBzZXJpYWxpemVkIHJlc3VsdHMsIHJlaHlkcmF0ZWQgZWl0aGVyIHVzaW5nXG4gKiB7QGxpbmsgU1NSRXhjaGFuZ2UucmVzdG9yZURhdGF9IG9yIHtAbGluayBTU1JleGNoYW5nZVBhcmFtcy5pbml0aWFsU3RhdGV9LCB0byByZXBsYXkgcmVzdWx0cyB0aGVcbiAqIHNlcnZlci1zaWRlIGhhcyBzZWVuIGFuZCBzZW50IGJlZm9yZS5cbiAqXG4gKiBFYWNoIHNlcmlhbGl6ZWQgcmVzdWx0IHdpbGwgb25seSBiZSByZXBsYXllZCBvbmNlLCBhcyBpdOKAmXMgYXNzdW1lZCB0aGF0IHlvdXIgY2FjaGUgZXhjaGFuZ2Ugd2lsbCBoYXZlIHRoZVxuICogcmVzdWx0cyBjYWNoZWQgYWZ0ZXJ3YXJkcy5cbiAqL1xuXG4vKiogU2VyaWFsaXplIGFuIE9wZXJhdGlvblJlc3VsdCB0byBwbGFpbiBKU09OICovXG52YXIgc2VyaWFsaXplUmVzdWx0ID0gKHJlc3VsdCwgaW5jbHVkZUV4dGVuc2lvbnMpID0+IHtcbiAgdmFyIHNlcmlhbGl6ZWQgPSB7XG4gICAgZGF0YTogSlNPTi5zdHJpbmdpZnkocmVzdWx0LmRhdGEpLFxuICAgIGhhc05leHQ6IHJlc3VsdC5oYXNOZXh0XG4gIH07XG4gIGlmIChyZXN1bHQuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2VyaWFsaXplZC5kYXRhID0gSlNPTi5zdHJpbmdpZnkocmVzdWx0LmRhdGEpO1xuICB9XG4gIGlmIChpbmNsdWRlRXh0ZW5zaW9ucyAmJiByZXN1bHQuZXh0ZW5zaW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2VyaWFsaXplZC5leHRlbnNpb25zID0gSlNPTi5zdHJpbmdpZnkocmVzdWx0LmV4dGVuc2lvbnMpO1xuICB9XG4gIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICBzZXJpYWxpemVkLmVycm9yID0ge1xuICAgICAgZ3JhcGhRTEVycm9yczogcmVzdWx0LmVycm9yLmdyYXBoUUxFcnJvcnMubWFwKGVycm9yID0+IHtcbiAgICAgICAgaWYgKCFlcnJvci5wYXRoICYmICFlcnJvci5leHRlbnNpb25zKSByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgIHBhdGg6IGVycm9yLnBhdGgsXG4gICAgICAgICAgZXh0ZW5zaW9uczogZXJyb3IuZXh0ZW5zaW9uc1xuICAgICAgICB9O1xuICAgICAgfSlcbiAgICB9O1xuICAgIGlmIChyZXN1bHQuZXJyb3IubmV0d29ya0Vycm9yKSB7XG4gICAgICBzZXJpYWxpemVkLmVycm9yLm5ldHdvcmtFcnJvciA9ICcnICsgcmVzdWx0LmVycm9yLm5ldHdvcmtFcnJvcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59O1xuXG4vKiogRGVzZXJpYWxpemUgcGxhaW4gSlNPTiB0byBhbiBPcGVyYXRpb25SZXN1bHRcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgZGVzZXJpYWxpemVSZXN1bHQgPSAob3BlcmF0aW9uLCByZXN1bHQsIGluY2x1ZGVFeHRlbnNpb25zKSA9PiAoe1xuICBvcGVyYXRpb24sXG4gIGRhdGE6IHJlc3VsdC5kYXRhID8gSlNPTi5wYXJzZShyZXN1bHQuZGF0YSkgOiB1bmRlZmluZWQsXG4gIGV4dGVuc2lvbnM6IGluY2x1ZGVFeHRlbnNpb25zICYmIHJlc3VsdC5leHRlbnNpb25zID8gSlNPTi5wYXJzZShyZXN1bHQuZXh0ZW5zaW9ucykgOiB1bmRlZmluZWQsXG4gIGVycm9yOiByZXN1bHQuZXJyb3IgPyBuZXcgZmV0Y2hTb3VyY2UuQ29tYmluZWRFcnJvcih7XG4gICAgbmV0d29ya0Vycm9yOiByZXN1bHQuZXJyb3IubmV0d29ya0Vycm9yID8gbmV3IEVycm9yKHJlc3VsdC5lcnJvci5uZXR3b3JrRXJyb3IpIDogdW5kZWZpbmVkLFxuICAgIGdyYXBoUUxFcnJvcnM6IHJlc3VsdC5lcnJvci5ncmFwaFFMRXJyb3JzXG4gIH0pIDogdW5kZWZpbmVkLFxuICBzdGFsZTogZmFsc2UsXG4gIGhhc05leHQ6ICEhcmVzdWx0Lmhhc05leHRcbn0pO1xudmFyIHJldmFsaWRhdGVkID0gbmV3IFNldCgpO1xuXG4vKiogQ3JlYXRlcyBhIHNlcnZlci1zaWRlIHJlbmRlcmluZyBgRXhjaGFuZ2VgIHRoYXQgZWl0aGVyIGNhcHR1cmVzIHJlc3BvbnNlcyBvbiB0aGUgc2VydmVyLXNpZGUgb3IgcmVwbGF5cyB0aGVtIG9uIHRoZSBjbGllbnQtc2lkZS5cbiAqXG4gKiBAcGFyYW0gcGFyYW1zIC0gQW4ge0BsaW5rIFNTUkV4Y2hhbmdlUGFyYW1zfSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAqIEByZXR1cm5zIHRoZSBjcmVhdGVkIHtAbGluayBTU1JFeGNoYW5nZX1cbiAqXG4gKiBAcmVtYXJrc1xuICogV2hlbiBkZWFsaW5nIHdpdGggc2VydmVyLXNpZGUgcmVuZGVyaW5nLCB3ZSBlc3NlbnRpYWxseSBoYXZlIHR3byB7QGxpbmsgQ2xpZW50IHwgQ2xpZW50c30gbWFraW5nIHJlcXVlc3RzLFxuICogdGhlIHNlcnZlci1zaWRlIGNsaWVudCwgYW5kIHRoZSBjbGllbnQtc2lkZSBvbmUuIFRoZSBgc3NyRXhjaGFuZ2VgIGhlbHBzIGltcGxlbWVudGluZyBhIHRpbnkgY2FjaGUgb24gYm90aFxuICogc2lkZXMgdGhhdDpcbiAqXG4gKiAtIGNhcHR1cmVzIHJlc3VsdHMgb24gdGhlIHNlcnZlci1zaWRlIHdoaWNoIGl0IGNhbiBzZXJpYWxpemUsXG4gKiAtIHJlcGxheXMgcmVzdWx0cyBvbiB0aGUgY2xpZW50LXNpZGUgdGhhdCBpdCBkZXNlcmlhbGl6ZWQgZnJvbSB0aGUgc2VydmVyLXNpZGUuXG4gKlxuICogSGludDogVGhlIGBzc3JFeGNoYW5nZWAgaXMgYmFzaWNhbGx5IGFuIGV4Y2hhbmdlIHRoYXQgYWN0cyBsaWtlIGEgcmVwbGFjZW1lbnQgZm9yIGFueSBmZXRjaCBleGNoYW5nZVxuICogdGVtcG9yYXJpbHkuIEFzIHN1Y2gsIHlvdSBzaG91bGQgcGxhY2UgaXQgYWZ0ZXIgeW91ciBjYWNoZSBleGNoYW5nZSBidXQgaW4gZnJvbnQgb2YgYW55IGZldGNoIGV4Y2hhbmdlLlxuICovXG52YXIgc3NyRXhjaGFuZ2UgPSAocGFyYW1zID0ge30pID0+IHtcbiAgdmFyIHN0YWxlV2hpbGVSZXZhbGlkYXRlID0gISFwYXJhbXMuc3RhbGVXaGlsZVJldmFsaWRhdGU7XG4gIHZhciBpbmNsdWRlRXh0ZW5zaW9ucyA9ICEhcGFyYW1zLmluY2x1ZGVFeHRlbnNpb25zO1xuICB2YXIgZGF0YSA9IHt9O1xuXG4gIC8vIE9uIHRoZSBjbGllbnQtc2lkZSwgd2UgZGVsZXRlIHJlc3VsdHMgZnJvbSB0aGUgY2FjaGUgYXMgdGhleSdyZSByZXNvbHZlZFxuICAvLyB0aGlzIGlzIGRlbGF5ZWQgc28gdGhhdCBjb25jdXJyZW50IHF1ZXJpZXMgZG9uJ3QgZGVsZXRlIGVhY2ggb3RoZXIncyBkYXRhXG4gIHZhciBpbnZhbGlkYXRlUXVldWUgPSBbXTtcbiAgdmFyIGludmFsaWRhdGUgPSByZXN1bHQgPT4ge1xuICAgIGludmFsaWRhdGVRdWV1ZS5wdXNoKHJlc3VsdC5vcGVyYXRpb24ua2V5KTtcbiAgICBpZiAoaW52YWxpZGF0ZVF1ZXVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIHdoaWxlIChrZXkgPSBpbnZhbGlkYXRlUXVldWUuc2hpZnQoKSkge1xuICAgICAgICAgIGRhdGFba2V5XSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBUaGUgU1NSIEV4Y2hhbmdlIGlzIGEgdGVtcG9yYXJ5IGNhY2hlIHRoYXQgY2FuIHBvcHVsYXRlIHJlc3VsdHMgaW50byBkYXRhIGZvciBzdXNwZW5zZVxuICAvLyBPbiB0aGUgY2xpZW50IGl0IGNhbiBiZSB1c2VkIHRvIHJldHJpZXZlIHRoZXNlIHRlbXBvcmFyeSByZXN1bHRzIGZyb20gYSByZWh5ZHJhdGVkIGNhY2hlXG4gIHZhciBzc3IgPSAoe1xuICAgIGNsaWVudCxcbiAgICBmb3J3YXJkXG4gIH0pID0+IG9wcyQgPT4ge1xuICAgIC8vIHBhcmFtcy5pc0NsaWVudCB0ZWxscyB1cyB3aGV0aGVyIHdlJ3JlIG9uIHRoZSBjbGllbnQtc2lkZVxuICAgIC8vIEJ5IGRlZmF1bHQgd2UgYXNzdW1lIHRoYXQgd2UncmUgb24gdGhlIGNsaWVudCBpZiBzdXNwZW5zZS1tb2RlIGlzIGRpc2FibGVkXG4gICAgdmFyIGlzQ2xpZW50ID0gcGFyYW1zICYmIHR5cGVvZiBwYXJhbXMuaXNDbGllbnQgPT09ICdib29sZWFuJyA/ICEhcGFyYW1zLmlzQ2xpZW50IDogIWNsaWVudC5zdXNwZW5zZTtcbiAgICB2YXIgZm9yd2FyZGVkT3BzJCA9IGZvcndhcmQod29ua2EuZmlsdGVyKG9wZXJhdGlvbiA9PiAhZGF0YVtvcGVyYXRpb24ua2V5XSB8fCAhIWRhdGFbb3BlcmF0aW9uLmtleV0uaGFzTmV4dCB8fCBvcGVyYXRpb24uY29udGV4dC5yZXF1ZXN0UG9saWN5ID09PSAnbmV0d29yay1vbmx5Jykob3BzJCkpO1xuXG4gICAgLy8gTk9URTogU2luY2UgYmVsb3cgd2UgbWlnaHQgZGVsZXRlIHRoZSBjYWNoZWQgZW50cnkgYWZ0ZXIgYWNjZXNzaW5nXG4gICAgLy8gaXQgb25jZSwgY2FjaGVkT3BzJCBuZWVkcyB0byBiZSBtZXJnZWQgYWZ0ZXIgZm9yd2FyZGVkT3BzJFxuICAgIHZhciBjYWNoZWRPcHMkID0gd29ua2EubWFwKG9wID0+IHtcbiAgICAgIHZhciBzZXJpYWxpemVkID0gZGF0YVtvcC5rZXldO1xuICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IGRlc2VyaWFsaXplUmVzdWx0KG9wLCBzZXJpYWxpemVkLCBpbmNsdWRlRXh0ZW5zaW9ucyk7XG4gICAgICBpZiAoc3RhbGVXaGlsZVJldmFsaWRhdGUgJiYgIXJldmFsaWRhdGVkLmhhcyhvcC5rZXkpKSB7XG4gICAgICAgIGNhY2hlZFJlc3VsdC5zdGFsZSA9IHRydWU7XG4gICAgICAgIHJldmFsaWRhdGVkLmFkZChvcC5rZXkpO1xuICAgICAgICByZWV4ZWN1dGVPcGVyYXRpb24oY2xpZW50LCBvcCk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAuLi5jYWNoZWRSZXN1bHQsXG4gICAgICAgIG9wZXJhdGlvbjogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGFkZE1ldGFkYXRhKG9wLCB7XG4gICAgICAgICAgY2FjaGVPdXRjb21lOiAnaGl0J1xuICAgICAgICB9KSA6IG9wXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KSh3b25rYS5maWx0ZXIob3BlcmF0aW9uID0+ICEhZGF0YVtvcGVyYXRpb24ua2V5XSAmJiBvcGVyYXRpb24uY29udGV4dC5yZXF1ZXN0UG9saWN5ICE9PSAnbmV0d29yay1vbmx5Jykob3BzJCkpO1xuICAgIGlmICghaXNDbGllbnQpIHtcbiAgICAgIC8vIE9uIHRoZSBzZXJ2ZXIgd2UgY2FjaGUgcmVzdWx0cyBpbiB0aGUgY2FjaGUgYXMgdGhleSdyZSByZXNvbHZlZFxuICAgICAgZm9yd2FyZGVkT3BzJCA9IHdvbmthLnRhcChyZXN1bHQgPT4ge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIG9wZXJhdGlvblxuICAgICAgICB9ID0gcmVzdWx0O1xuICAgICAgICBpZiAob3BlcmF0aW9uLmtpbmQgIT09ICdtdXRhdGlvbicpIHtcbiAgICAgICAgICB2YXIgc2VyaWFsaXplZCA9IHNlcmlhbGl6ZVJlc3VsdChyZXN1bHQsIGluY2x1ZGVFeHRlbnNpb25zKTtcbiAgICAgICAgICBkYXRhW29wZXJhdGlvbi5rZXldID0gc2VyaWFsaXplZDtcbiAgICAgICAgfVxuICAgICAgfSkoZm9yd2FyZGVkT3BzJCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9uIHRoZSBjbGllbnQgd2UgZGVsZXRlIHJlc3VsdHMgZnJvbSB0aGUgY2FjaGUgYXMgdGhleSdyZSByZXNvbHZlZFxuICAgICAgY2FjaGVkT3BzJCA9IHdvbmthLnRhcChpbnZhbGlkYXRlKShjYWNoZWRPcHMkKTtcbiAgICB9XG4gICAgcmV0dXJuIHdvbmthLm1lcmdlKFtmb3J3YXJkZWRPcHMkLCBjYWNoZWRPcHMkXSk7XG4gIH07XG4gIHNzci5yZXN0b3JlRGF0YSA9IHJlc3RvcmUgPT4ge1xuICAgIGZvciAodmFyIF9rZXkgaW4gcmVzdG9yZSkge1xuICAgICAgLy8gV2Ugb25seSByZXN0b3JlIGRhdGEgdGhhdCBoYXNuJ3QgYmVlbiBwcmV2aW91c2x5IGludmFsaWRhdGVkXG4gICAgICBpZiAoZGF0YVtfa2V5XSAhPT0gbnVsbCkge1xuICAgICAgICBkYXRhW19rZXldID0gcmVzdG9yZVtfa2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHNzci5leHRyYWN0RGF0YSA9ICgpID0+IHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgX2tleTIgaW4gZGF0YSkgaWYgKGRhdGFbX2tleTJdICE9IG51bGwpIHJlc3VsdFtfa2V5Ml0gPSBkYXRhW19rZXkyXTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBpZiAocGFyYW1zICYmIHBhcmFtcy5pbml0aWFsU3RhdGUpIHtcbiAgICBzc3IucmVzdG9yZURhdGEocGFyYW1zLmluaXRpYWxTdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHNzcjtcbn07XG5cbi8qKiBBbiBhYnN0cmFjdCBvYnNlcnZlci1saWtlIGludGVyZmFjZS5cbiAqXG4gKiBAcmVtYXJrc1xuICogT2JzZXJ2ZXItbGlrZSBpbnRlcmZhY2VzIGFyZSBwYXNzZWQgdG8ge0BsaW5rIE9ic2VydmFibGVMaWtlLnN1YnNjcmliZX0gdG8gcHJvdmlkZSB0aGVtXG4gKiB3aXRoIGNhbGxiYWNrcyBmb3IgdGhlaXIgZXZlbnRzLlxuICpcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9ic2VydmFibGV9IGZvciB0aGUgZnVsbCBUQzM5IE9ic2VydmFibGUgcHJvcG9zYWwuXG4gKi9cblxuLyoqIEFuIGFic3RyYWN0IG9ic2VydmFibGUtbGlrZSBpbnRlcmZhY2UuXG4gKlxuICogQHJlbWFya3NcbiAqIE9ic2VydmFibGUsIG9yIE9ic2VydmFibGUtbGlrZSBpbnRlcmZhY2VzLCBhcmUgb2Z0ZW4gdXNlZCBieSBHcmFwaFFMIHRyYW5zcG9ydHMgdG8gYWJzdHJhY3RcbiAqIGhvdyB0aGV5IHNlbmQge0BsaW5rIEV4ZWN1dGlvblJlc3VsdCB8IEV4ZWN1dGlvblJlc3VsdHN9IHRvIGNvbnN1bWVycy4gVGhlc2UgZ2VuZXJhbGx5IGNvbnRhaW5cbiAqIGEgYHN1YnNjcmliZWAgbWV0aG9kIGFjY2VwdGluZyBhbiB7QGxpbmsgT2JzZXJ2ZXJMaWtlfSBzdHJ1Y3R1cmUuXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JzZXJ2YWJsZX0gZm9yIHRoZSBmdWxsIFRDMzkgT2JzZXJ2YWJsZSBwcm9wb3NhbC5cbiAqL1xuXG4vKiogQSBtb3JlIGNyb3NzLWNvbXBhdGlibGUgdmVyc2lvbiBvZiB0aGUge0BsaW5rIEdyYXBoUUxSZXF1ZXN0fSBzdHJ1Y3R1cmUuXG4gKiB7QGxpbmsgRmV0Y2hCb2R5fSBmb3IgbW9yZSBkZXRhaWxzXG4gKi9cblxuLyoqIEEgc3Vic2NyaXB0aW9uIGZvcndhcmRpbmcgZnVuY3Rpb24sIHdoaWNoIG11c3QgYWNjZXB0IGEge0BsaW5rIFN1YnNjcmlwdGlvbk9wZXJhdGlvbn0uXG4gKlxuICogQHBhcmFtIG9wZXJhdGlvbiAtIEEge0BsaW5rIFN1YnNjcmlwdGlvbk9wZXJhdGlvbn1cbiAqIEByZXR1cm5zIEFuIHtAbGluayBPYnNlcnZhYmxlTGlrZX0gb2JqZWN0IGlzc3Vpbmcge0BsaW5rIEV4ZWN1dGlvblJlc3VsdCB8IEV4ZWN1dGlvblJlc3VsdHN9LlxuICovXG5cbi8qKiBUaGlzIGlzIGNhbGxlZCB0byBjcmVhdGUgYSBzdWJzY3JpcHRpb24gYW5kIG5lZWRzIHRvIGJlIGhvb2tlZCB1cCB0byBhIHRyYW5zcG9ydCBjbGllbnQuICovXG5cbi8qKiBHZW5lcmljIHN1YnNjcmlwdGlvbiBleGNoYW5nZSBmYWN0b3J5IHVzZWQgdG8gZWl0aGVyIGNyZWF0ZSBhbiBleGNoYW5nZSBoYW5kbGluZyBqdXN0IHN1YnNjcmlwdGlvbnMgb3IgYWxsIG9wZXJhdGlvbiBraW5kcy5cbiAqXG4gKiBAcmVtYXJrc1xuICogYHN1YnNjcmlwdGlvbkV4Y2hhbmdlYCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgYW4ge0BsaW5rIEV4Y2hhbmdlfSB0aGF0IGVpdGhlclxuICogaGFuZGxlcyBqdXN0IEdyYXBoUUwgc3Vic2NyaXB0aW9uIG9wZXJhdGlvbnMsIG9yIG9wdGlvbmFsbHkgYWxsIG9wZXJhdGlvbnMsXG4gKiB3aGVuIHRoZSB7QGxpbmsgU3Vic2NyaXB0aW9uRXhjaGFuZ2VPcHRzLmVuYWJsZUFsbE9wZXJhdGlvbnN9IGZsYWcgaXMgcGFzc2VkLlxuICpcbiAqIFRoZSB7QGxpbmsgU3Vic2NyaXB0aW9uRXhjaGFuZ2VPcHRzLmZvcndhcmRTdWJzY3JpcHRpb259IGZ1bmN0aW9uIG11c3RcbiAqIGJlIHByb3ZpZGVkIGFuZCBwcm92aWRlcyBhIGdlbmVyaWMgaW5wdXQgdGhhdCdzIGJhc2VkIG9uIHtAbGluayBPcGVyYXRpb259XG4gKiBidXQgaXMgY29tcGF0aWJsZSB3aXRoIG1hbnkgbGlicmFyaWVzIGltcGxlbWVudGluZyBHcmFwaFFMIHJlcXVlc3Qgb3JcbiAqIHN1YnNjcmlwdGlvbiBpbnRlcmZhY2VzLlxuICovXG52YXIgc3Vic2NyaXB0aW9uRXhjaGFuZ2UgPSAoe1xuICBmb3J3YXJkU3Vic2NyaXB0aW9uLFxuICBlbmFibGVBbGxPcGVyYXRpb25zLFxuICBpc1N1YnNjcmlwdGlvbk9wZXJhdGlvblxufSkgPT4gKHtcbiAgY2xpZW50LFxuICBmb3J3YXJkXG59KSA9PiB7XG4gIHZhciBjcmVhdGVTdWJzY3JpcHRpb25Tb3VyY2UgPSBvcGVyYXRpb24gPT4ge1xuICAgIHZhciBvYnNlcnZhYmxlaXNoID0gZm9yd2FyZFN1YnNjcmlwdGlvbihmZXRjaFNvdXJjZS5tYWtlRmV0Y2hCb2R5KG9wZXJhdGlvbiksIG9wZXJhdGlvbik7XG4gICAgcmV0dXJuIHdvbmthLm1ha2UoKHtcbiAgICAgIG5leHQsXG4gICAgICBjb21wbGV0ZVxuICAgIH0pID0+IHtcbiAgICAgIHZhciBpc0NvbXBsZXRlID0gZmFsc2U7XG4gICAgICB2YXIgc3ViO1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAoaXNDb21wbGV0ZSkgcmV0dXJuO1xuICAgICAgICBzdWIgPSBvYnNlcnZhYmxlaXNoLnN1YnNjcmliZSh7XG4gICAgICAgICAgbmV4dChuZXh0UmVzdWx0KSB7XG4gICAgICAgICAgICBuZXh0KHJlc3VsdCA9IHJlc3VsdCA/IGZldGNoU291cmNlLm1lcmdlUmVzdWx0UGF0Y2gocmVzdWx0LCBuZXh0UmVzdWx0KSA6IGZldGNoU291cmNlLm1ha2VSZXN1bHQob3BlcmF0aW9uLCBuZXh0UmVzdWx0KSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlcnJvcihlcnJvcikge1xuICAgICAgICAgICAgbmV4dChmZXRjaFNvdXJjZS5tYWtlRXJyb3JSZXN1bHQob3BlcmF0aW9uLCBlcnJvcikpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY29tcGxldGUoKSB7XG4gICAgICAgICAgICBpZiAoIWlzQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgaXNDb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICAgIGlmIChvcGVyYXRpb24ua2luZCA9PT0gJ3N1YnNjcmlwdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjbGllbnQucmVleGVjdXRlT3BlcmF0aW9uKG1ha2VPcGVyYXRpb24oJ3RlYXJkb3duJywgb3BlcmF0aW9uLCBvcGVyYXRpb24uY29udGV4dCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0Lmhhc05leHQpIG5leHQoZmV0Y2hTb3VyY2UubWVyZ2VSZXN1bHRQYXRjaChyZXN1bHQsIHtcbiAgICAgICAgICAgICAgICBoYXNOZXh0OiBmYWxzZVxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaXNDb21wbGV0ZSA9IHRydWU7XG4gICAgICAgIGlmIChzdWIpIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcbiAgdmFyIGlzU3Vic2NyaXB0aW9uT3BlcmF0aW9uRm4gPSBpc1N1YnNjcmlwdGlvbk9wZXJhdGlvbiB8fCAob3BlcmF0aW9uID0+IG9wZXJhdGlvbi5raW5kID09PSAnc3Vic2NyaXB0aW9uJyB8fCAhIWVuYWJsZUFsbE9wZXJhdGlvbnMgJiYgKG9wZXJhdGlvbi5raW5kID09PSAncXVlcnknIHx8IG9wZXJhdGlvbi5raW5kID09PSAnbXV0YXRpb24nKSk7XG4gIHJldHVybiBvcHMkID0+IHtcbiAgICB2YXIgc3Vic2NyaXB0aW9uUmVzdWx0cyQgPSB3b25rYS5tZXJnZU1hcChvcGVyYXRpb24gPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAga2V5XG4gICAgICB9ID0gb3BlcmF0aW9uO1xuICAgICAgdmFyIHRlYXJkb3duJCA9IHdvbmthLmZpbHRlcihvcCA9PiBvcC5raW5kID09PSAndGVhcmRvd24nICYmIG9wLmtleSA9PT0ga2V5KShvcHMkKTtcbiAgICAgIHJldHVybiB3b25rYS50YWtlVW50aWwodGVhcmRvd24kKShjcmVhdGVTdWJzY3JpcHRpb25Tb3VyY2Uob3BlcmF0aW9uKSk7XG4gICAgfSkod29ua2EuZmlsdGVyKG9wZXJhdGlvbiA9PiBvcGVyYXRpb24ua2luZCAhPT0gJ3RlYXJkb3duJyAmJiBpc1N1YnNjcmlwdGlvbk9wZXJhdGlvbkZuKG9wZXJhdGlvbikpKG9wcyQpKTtcbiAgICB2YXIgZm9yd2FyZCQgPSBmb3J3YXJkKHdvbmthLmZpbHRlcihvcGVyYXRpb24gPT4gb3BlcmF0aW9uLmtpbmQgPT09ICd0ZWFyZG93bicgfHwgIWlzU3Vic2NyaXB0aW9uT3BlcmF0aW9uRm4ob3BlcmF0aW9uKSkob3BzJCkpO1xuICAgIHJldHVybiB3b25rYS5tZXJnZShbc3Vic2NyaXB0aW9uUmVzdWx0cyQsIGZvcndhcmQkXSk7XG4gIH07XG59O1xuXG4vKiogU2ltcGxlIGxvZyBkZWJ1Z2dlciBleGNoYW5nZS5cbiAqXG4gKiBAcmVtYXJrc1xuICogQW4gZXhjaGFuZ2UgdGhhdCBsb2dzIGluY29taW5nIHtAbGluayBPcGVyYXRpb24gfCBPcGVyYXRpb25zfSBhbmRcbiAqIHtAbGluayBPcGVyYXRpb25SZXN1bHQgfCBPcGVyYXRpb25SZXN1bHRzfSBpbiBkZXZlbG9wbWVudC5cbiAqXG4gKiBUaGlzIGV4Y2hhbmdlIGlzIGEgbm8tb3AgaW4gcHJvZHVjdGlvbiBhbmQgb2Z0ZW4gdXNlZCBpbiBpc3N1ZSByZXBvcnRpbmdcbiAqIHRvIHVuZGVyc3RhbmQgY2VydGFpbiB1c2FnZSBwYXR0ZXJucyBvZiBgdXJxbGAgd2l0aG91dCBoYXZpbmcgYWNjZXNzIHRvXG4gKiB0aGUgb3JpZ2luYWwgc291cmNlIGNvZGUuXG4gKlxuICogSGludDogV2hlbiB5b3UgcmVwb3J0IGFuIGlzc3VlIHlvdeKAmXJlIGhhdmluZyB3aXRoIGB1cnFsYCwgYWRkaW5nXG4gKiB0aGlzIGFzIHlvdXIgZmlyc3QgZXhjaGFuZ2UgYW5kIHBvc3RpbmcgaXRzIG91dHB1dCBjYW4gc3BlZWQgdXBcbiAqIGlzc3VlIHRyaWFnaW5nIGEgbG90IVxuICovXG52YXIgZGVidWdFeGNoYW5nZSA9ICh7XG4gIGZvcndhcmRcbn0pID0+IHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICByZXR1cm4gb3BzJCA9PiBmb3J3YXJkKG9wcyQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBvcHMkID0+IHdvbmthLnRhcChyZXN1bHQgPT5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUubG9nKCdbRXhjaGFuZ2UgZGVidWddOiBDb21wbGV0ZWQgb3BlcmF0aW9uOiAnLCByZXN1bHQpKShmb3J3YXJkKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgd29ua2EudGFwKG9wID0+IGNvbnNvbGUubG9nKCdbRXhjaGFuZ2UgZGVidWddOiBJbmNvbWluZyBvcGVyYXRpb246ICcsIG9wKSkob3BzJCkpKTtcbiAgfVxufTtcblxuLyoqIERlZmF1bHQgZGVkdXBsaWNhdGlvbiBleGNoYW5nZS5cbiAqIEBkZXByZWNhdGVkXG4gKiBUaGlzIGV4Y2hhbmdlJ3MgZnVuY3Rpb25hbGl0eSBpcyBub3cgYnVpbHQgaW50byB0aGUge0BsaW5rIENsaWVudH0uXG4gKi9cbnZhciBkZWR1cEV4Y2hhbmdlID0gKHtcbiAgZm9yd2FyZFxufSkgPT4gb3BzJCA9PiBmb3J3YXJkKG9wcyQpO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmUgKi9cblxuLyoqIERlZmF1bHQgR3JhcGhRTCBvdmVyIEhUVFAgZmV0Y2ggZXhjaGFuZ2UuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoZSBkZWZhdWx0IGZldGNoIGV4Y2hhbmdlIGluIGB1cnFsYCBzdXBwb3J0cyBzZW5kaW5nIEdyYXBoUUwgb3ZlciBIVFRQXG4gKiByZXF1ZXN0cywgY2FuIG9wdGlvbmFsbHkgc2VuZCBHcmFwaFFMIHF1ZXJpZXMgYXMgR0VUIHJlcXVlc3RzLCBhbmRcbiAqIGhhbmRsZXMgaW5jcmVtZW50YWwgbXVsdGlwYXJ0IHJlc3BvbnNlcy5cbiAqXG4gKiBUaGlzIGV4Y2hhbmdlIGRvZXMgbm90IGhhbmRsZSBwZXJzaXN0ZWQgcXVlcmllcyBvciBtdWx0aXBhcnQgdXBsb2Fkcy5cbiAqIFN1cHBvcnQgZm9yIHRoZSBmb3JtZXIgY2FuIGJlIGFkZGVkIHVzaW5nIGBAdXJxbC9leGNoYW5nZS1wZXJzaXN0ZWQtZmV0Y2hgXG4gKiBhbmQgdGhlIGxhdHRlciB1c2luZyBgQHVycWwvZXhjaGFuZ2UtbXVsdGlwYXJ0LWZldGNoYC5cbiAqXG4gKiBIaW50OiBUaGUgYGZldGNoRXhjaGFuZ2VgIGFuZCB0aGUgdHdvIG90aGVyIGV4Y2hhbmdlcyBhbGwgdXNlIHRoZSBidWlsdC1pbiBmZXRjaFxuICogdXRpbGl0aWVzIGluIGBAdXJxbC9jb3JlL2ludGVybmFsYCwgd2hpY2ggeW91IGNhbiBhbHNvIHVzZSB0byBpbXBsZW1lbnRcbiAqIGEgY3VzdG9taXplZCBmZXRjaCBleGNoYW5nZS5cbiAqXG4gKiBAc2VlIHtAbGluayBtYWtlRmV0Y2hTb3VyY2V9IGZvciB0aGUgc2hhcmVkIHV0aWxpdHkgY2FsbGluZyB0aGUgRmV0Y2ggQVBJLlxuICovXG52YXIgZmV0Y2hFeGNoYW5nZSA9ICh7XG4gIGZvcndhcmQsXG4gIGRpc3BhdGNoRGVidWdcbn0pID0+IHtcbiAgcmV0dXJuIG9wcyQgPT4ge1xuICAgIHZhciBmZXRjaFJlc3VsdHMkID0gd29ua2EubWVyZ2VNYXAob3BlcmF0aW9uID0+IHtcbiAgICAgIHZhciBib2R5ID0gZmV0Y2hTb3VyY2UubWFrZUZldGNoQm9keShvcGVyYXRpb24pO1xuICAgICAgdmFyIHVybCA9IGZldGNoU291cmNlLm1ha2VGZXRjaFVSTChvcGVyYXRpb24sIGJvZHkpO1xuICAgICAgdmFyIGZldGNoT3B0aW9ucyA9IGZldGNoU291cmNlLm1ha2VGZXRjaE9wdGlvbnMob3BlcmF0aW9uLCBib2R5KTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBkaXNwYXRjaERlYnVnKHtcbiAgICAgICAgdHlwZTogJ2ZldGNoUmVxdWVzdCcsXG4gICAgICAgIG1lc3NhZ2U6ICdBIGZldGNoIHJlcXVlc3QgaXMgYmVpbmcgZXhlY3V0ZWQuJyxcbiAgICAgICAgb3BlcmF0aW9uLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIGZldGNoT3B0aW9uc1xuICAgICAgICB9LFxuICAgICAgICBcInNvdXJjZVwiOiBcImZldGNoRXhjaGFuZ2VcIlxuICAgICAgfSkgOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgc291cmNlID0gd29ua2EudGFrZVVudGlsKHdvbmthLmZpbHRlcihvcCA9PiBvcC5raW5kID09PSAndGVhcmRvd24nICYmIG9wLmtleSA9PT0gb3BlcmF0aW9uLmtleSkob3BzJCkpKGZldGNoU291cmNlLm1ha2VGZXRjaFNvdXJjZShvcGVyYXRpb24sIHVybCwgZmV0Y2hPcHRpb25zKSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICByZXR1cm4gd29ua2Eub25QdXNoKHJlc3VsdCA9PiB7XG4gICAgICAgICAgdmFyIGVycm9yID0gIXJlc3VsdC5kYXRhID8gcmVzdWx0LmVycm9yIDogdW5kZWZpbmVkO1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBkaXNwYXRjaERlYnVnKHtcbiAgICAgICAgICAgIHR5cGU6IGVycm9yID8gJ2ZldGNoRXJyb3InIDogJ2ZldGNoU3VjY2VzcycsXG4gICAgICAgICAgICBtZXNzYWdlOiBgQSAke2Vycm9yID8gJ2ZhaWxlZCcgOiAnc3VjY2Vzc2Z1bCd9IGZldGNoIHJlc3BvbnNlIGhhcyBiZWVuIHJldHVybmVkLmAsXG4gICAgICAgICAgICBvcGVyYXRpb24sXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICB2YWx1ZTogZXJyb3IgfHwgcmVzdWx0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJzb3VyY2VcIjogXCJmZXRjaEV4Y2hhbmdlXCJcbiAgICAgICAgICB9KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfSkoc291cmNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfSkod29ua2EuZmlsdGVyKG9wZXJhdGlvbiA9PiB7XG4gICAgICByZXR1cm4gb3BlcmF0aW9uLmtpbmQgIT09ICd0ZWFyZG93bicgJiYgKG9wZXJhdGlvbi5raW5kICE9PSAnc3Vic2NyaXB0aW9uJyB8fCAhIW9wZXJhdGlvbi5jb250ZXh0LmZldGNoU3Vic2NyaXB0aW9ucyk7XG4gICAgfSkob3BzJCkpO1xuICAgIHZhciBmb3J3YXJkJCA9IGZvcndhcmQod29ua2EuZmlsdGVyKG9wZXJhdGlvbiA9PiB7XG4gICAgICByZXR1cm4gb3BlcmF0aW9uLmtpbmQgPT09ICd0ZWFyZG93bicgfHwgb3BlcmF0aW9uLmtpbmQgPT09ICdzdWJzY3JpcHRpb24nICYmICFvcGVyYXRpb24uY29udGV4dC5mZXRjaFN1YnNjcmlwdGlvbnM7XG4gICAgfSkob3BzJCkpO1xuICAgIHJldHVybiB3b25rYS5tZXJnZShbZmV0Y2hSZXN1bHRzJCwgZm9yd2FyZCRdKTtcbiAgfTtcbn07XG5cbi8qKiBDb21wb3NlcyBhbiBhcnJheSBvZiBFeGNoYW5nZXMgaW50byBhIHNpbmdsZSBvbmUuXG4gKlxuICogQHBhcmFtIGV4Y2hhbmdlcyAtIEFuIGFycmF5IG9mIHtAbGluayBFeGNoYW5nZSB8IEV4Y2hhbmdlc30uXG4gKiBAcmV0dXJucyAtIEEgY29tcG9zZWQge0BsaW5rIEV4Y2hhbmdlfS5cbiAqXG4gKiBAcmVtYXJrc1xuICogYGNvbXBvc2VFeGNoYW5nZXNgIHJldHVybnMgYW4ge0BsaW5rIEV4Y2hhbmdlfSB0aGF0IHdoZW4gaW5zdGFudGlhdGVkXG4gKiBjb21wb3NlcyB0aGUgYXJyYXkgb2YgcGFzc2VkIGBFeGNoYW5nZWBzIGludG8gb25lLCBjYWxsaW5nIHRoZW0gZnJvbVxuICogcmlnaHQgdG8gbGVmdCwgd2l0aCB0aGUgcHJpb3IgYEV4Y2hhbmdlYOKAmXMge0BsaW5rIEV4Y2hhbmdlSU99IGZ1bmN0aW9uXG4gKiBhcyB0aGUge0BsaW5rIEV4Y2hhbmdlSW5wdXQuZm9yd2FyZH0gaW5wdXQuXG4gKlxuICogVGhpcyBzaW1wbHkgbWVyZ2VzIGFsbCBleGNoYW5nZXMgaW50byBvbmUgYW5kIGlzIHVzZWQgYnkgdGhlIHtAbGluayBDbGllbnR9XG4gKiB0byBtZXJnZSB0aGUgYGV4Y2hhbmdlc2Agb3B0aW9uIGl0IHJlY2VpdmVzLlxuICpcbiAqIEB0aHJvd3NcbiAqIEluIGRldmVsb3BtZW50LCBpZiB7QGxpbmsgRXhjaGFuZ2VJbnB1dC5mb3J3YXJkfSBpcyBjYWxsZWQgcmVwZWF0ZWRseVxuICogYnkgYW4ge0BsaW5rIEV4Y2hhbmdlfSBhbiBlcnJvciBpcyB0aHJvd24sIHNpbmNlIGBmb3J3YXJkKClgIG11c3Qgb25seVxuICogYmUgY2FsbGVkIG9uY2UgcGVyIGBFeGNoYW5nZWAuXG4gKi9cbnZhciBjb21wb3NlRXhjaGFuZ2VzID0gZXhjaGFuZ2VzID0+ICh7XG4gIGNsaWVudCxcbiAgZm9yd2FyZCxcbiAgZGlzcGF0Y2hEZWJ1Z1xufSkgPT4gZXhjaGFuZ2VzLnJlZHVjZVJpZ2h0KChmb3J3YXJkLCBleGNoYW5nZSkgPT4ge1xuICB2YXIgZm9yd2FyZGVkID0gZmFsc2U7XG4gIHJldHVybiBleGNoYW5nZSh7XG4gICAgY2xpZW50LFxuICAgIGZvcndhcmQob3BlcmF0aW9ucyQpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChmb3J3YXJkZWQpIHRocm93IG5ldyBFcnJvcignZm9yd2FyZCgpIG11c3Qgb25seSBiZSBjYWxsZWQgb25jZSBpbiBlYWNoIEV4Y2hhbmdlLicpO1xuICAgICAgICBmb3J3YXJkZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdvbmthLnNoYXJlKGZvcndhcmQod29ua2Euc2hhcmUob3BlcmF0aW9ucyQpKSk7XG4gICAgfSxcbiAgICBkaXNwYXRjaERlYnVnKGV2ZW50KSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gZGlzcGF0Y2hEZWJ1Zyh7XG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgc291cmNlOiBleGNoYW5nZS5uYW1lLFxuICAgICAgICAuLi5ldmVudFxuICAgICAgfSkgOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9KTtcbn0sIGZvcndhcmQpO1xuXG4vKiogT3B0aW9ucyBmb3IgdGhlIGBtYXBFeGNoYW5nZWAgYWxsb3dpbmcgaXQgdG8gcmVhY3QgdG8gaW5jb21pbmcgb3BlcmF0aW9ucywgcmVzdWx0cywgb3IgZXJyb3JzLiAqL1xuXG4vKiogQ3JlYXRlcyBhbiBgRXhjaGFuZ2VgIG1hcHBpbmcgb3ZlciBpbmNvbWluZyBvcGVyYXRpb25zLCByZXN1bHRzLCBhbmQvb3IgZXJyb3JzLlxuICpcbiAqIEBwYXJhbSBvcHRzIC0gQSB7QGxpbmsgTWFwRXhjaGFuZ2VPcHRzfSBjb25maWd1cmF0aW9uIG9iamVjdCwgY29udGFpbmluZyB0aGUgY2FsbGJhY2tzIHRoZSBgbWFwRXhjaGFuZ2VgIHdpbGwgdXNlLlxuICogQHJldHVybnMgdGhlIGNyZWF0ZWQge0BsaW5rIEV4Y2hhbmdlfVxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGUgYG1hcEV4Y2hhbmdlYCBtYXkgYmUgdXNlZCB0byByZWFjdCB0byBvciBtb2RpZnkgaW5jb21pbmcge0BsaW5rIE9wZXJhdGlvbiB8IE9wZXJhdGlvbnN9XG4gKiBhbmQge0BsaW5rIE9wZXJhdGlvblJlc3VsdCB8IE9wZXJhdGlvblJlc3VsdHN9LiBPcHRpb25hbGx5LCBpdCBjYW4gYWxzbyBtb2RpZnkgdGhlc2VcbiAqIGFzeW5jaHJvbm91c2x5LCB3aGVuIGEgcHJvbWlzZSBpcyByZXR1cm5lZCBmcm9tIHRoZSBjYWxsYmFja3MuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgdG8sIGZvciBpbnN0YW5jZSwgYWRkIGFuIGF1dGhlbnRpY2F0aW9uIHRva2VuIHRvIGEgZ2l2ZW4gcmVxdWVzdCwgd2hlblxuICogdGhlIGBAdXJxbC9leGNoYW5nZS1hdXRoYCBwYWNrYWdlIHdvdWxkIGJlIG92ZXJraWxsLlxuICpcbiAqIEl0IGNhbiBhbHNvIGFjY2VwdCBhbiBgb25FcnJvcmAgY2FsbGJhY2ssIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHJlYWN0IHRvIGluY29taW5nXG4gKiB7QGxpbmsgQ29tYmluZWRFcnJvciB8IENvbWJpbmVkRXJyb3JzfSBvbiByZXN1bHRzLCBhbmQgdHJpZ2dlciBzaWRlLWVmZmVjdHMuXG4gKlxuICovXG52YXIgbWFwRXhjaGFuZ2UgPSAoe1xuICBvbk9wZXJhdGlvbixcbiAgb25SZXN1bHQsXG4gIG9uRXJyb3Jcbn0pID0+IHtcbiAgcmV0dXJuICh7XG4gICAgZm9yd2FyZFxuICB9KSA9PiBvcHMkID0+IHtcbiAgICByZXR1cm4gd29ua2EubWVyZ2VNYXAocmVzdWx0ID0+IHtcbiAgICAgIGlmIChvbkVycm9yICYmIHJlc3VsdC5lcnJvcikgb25FcnJvcihyZXN1bHQuZXJyb3IsIHJlc3VsdC5vcGVyYXRpb24pO1xuICAgICAgdmFyIG5ld1Jlc3VsdCA9IG9uUmVzdWx0ICYmIG9uUmVzdWx0KHJlc3VsdCkgfHwgcmVzdWx0O1xuICAgICAgcmV0dXJuICd0aGVuJyBpbiBuZXdSZXN1bHQgPyB3b25rYS5mcm9tUHJvbWlzZShuZXdSZXN1bHQpIDogd29ua2EuZnJvbVZhbHVlKG5ld1Jlc3VsdCk7XG4gICAgfSkoZm9yd2FyZCh3b25rYS5tZXJnZU1hcChvcGVyYXRpb24gPT4ge1xuICAgICAgdmFyIG5ld09wZXJhdGlvbiA9IG9uT3BlcmF0aW9uICYmIG9uT3BlcmF0aW9uKG9wZXJhdGlvbikgfHwgb3BlcmF0aW9uO1xuICAgICAgcmV0dXJuICd0aGVuJyBpbiBuZXdPcGVyYXRpb24gPyB3b25rYS5mcm9tUHJvbWlzZShuZXdPcGVyYXRpb24pIDogd29ua2EuZnJvbVZhbHVlKG5ld09wZXJhdGlvbik7XG4gICAgfSkob3BzJCkpKTtcbiAgfTtcbn07XG5cbi8qKiBVc2VkIGJ5IHRoZSBgQ2xpZW50YCBhcyB0aGUgbGFzdCBleGNoYW5nZSB0byB3YXJuIGFib3V0IHVuaGFuZGxlZCBvcGVyYXRpb25zLlxuICpcbiAqIEByZW1hcmtzXG4gKiBJbiBhIG5vcm1hbCBzZXR1cCwgc29tZSBvcGVyYXRpb25zIG1heSBnbyB1bmhhbmRsZWQgd2hlbiBhIHtAbGluayBDbGllbnR9IGlzbuKAmXQgc2V0IHVwXG4gKiB3aXRoIHRoZSByaWdodCBleGNoYW5nZXMuXG4gKiBGb3IgaW5zdGFuY2UsIGEgYENsaWVudGAgbWF5IGJlIG1pc3NpbmcgYSBmZXRjaCBleGNoYW5nZSwgb3IgYW4gZXhjaGFuZ2UgaGFuZGxpbmcgc3Vic2NyaXB0aW9ucy5cbiAqIFRoaXMge0BsaW5rIEV4Y2hhbmdlfSBpcyBhZGRlZCBieSB0aGUgYENsaWVudGAgYXV0b21hdGljYWxseSB0byBsb2cgd2FybmluZ3MgYWJvdXQgdW5oYW5kbGVkXG4gKiB7QGxpbmsgT3BlcmFpdG9uIHwgT3BlcmF0aW9uc30gaW4gZGV2ZWxvcG1lbnQuXG4gKi9cbnZhciBmYWxsYmFja0V4Y2hhbmdlID0gKHtcbiAgZGlzcGF0Y2hEZWJ1Z1xufSkgPT4gb3BzJCA9PiB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgb3BzJCA9IHdvbmthLnRhcChvcGVyYXRpb24gPT4ge1xuICAgICAgaWYgKG9wZXJhdGlvbi5raW5kICE9PSAndGVhcmRvd24nICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBgTm8gZXhjaGFuZ2UgaGFzIGhhbmRsZWQgb3BlcmF0aW9ucyBvZiBraW5kIFwiJHtvcGVyYXRpb24ua2luZH1cIi4gQ2hlY2sgd2hldGhlciB5b3UndmUgYWRkZWQgYW4gZXhjaGFuZ2UgcmVzcG9uc2libGUgZm9yIHRoZXNlIG9wZXJhdGlvbnMuYDtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGRpc3BhdGNoRGVidWcoe1xuICAgICAgICAgIHR5cGU6ICdmYWxsYmFja0NhdGNoJyxcbiAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgIG9wZXJhdGlvbixcbiAgICAgICAgICBcInNvdXJjZVwiOiBcImZhbGxiYWNrRXhjaGFuZ2VcIlxuICAgICAgICB9KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0pKG9wcyQpO1xuICB9XG5cbiAgLy8gQWxsIG9wZXJhdGlvbnMgdGhhdCBza2lwcGVkIHRocm91Z2ggdGhlIGVudGlyZSBleGNoYW5nZSBjaGFpbiBzaG91bGQgYmUgZmlsdGVyZWQgZnJvbSB0aGUgb3V0cHV0XG4gIHJldHVybiB3b25rYS5maWx0ZXIoX3ggPT4gZmFsc2UpKG9wcyQpO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lICovXG5cbi8qKiBDb25maWd1cmF0aW9uIG9wdGlvbnMgcGFzc2VkIHdoZW4gY3JlYXRpbmcgYSBuZXcge0BsaW5rIENsaWVudH0uXG4gKlxuICogQHJlbWFya3NcbiAqIFRoZSBgQ2xpZW50T3B0aW9uc2AgYXJlIHBhc3NlZCB3aGVuIGNyZWF0aW5nIGEgbmV3IHtAbGluayBDbGllbnR9LCBhbmRcbiAqIGFyZSB1c2VkIHRvIGluc3RhbnRpYXRlIHRoZSBwaXBlbGluZSBvZiB7QGxpbmsgRXhjaGFuZ2UgfCBFeGNoYW5nZXN9LCBjb25maWd1cmVcbiAqIG9wdGlvbnMgdXNlZCB0byBpbml0aWFsaXplIHtAbGluayBPcGVyYXRpb25Db250ZXh0IHwgT3BlcmF0aW9uQ29udGV4dHN9LCBvciB0b1xuICogY2hhbmdlIHRoZSBnZW5lcmFsIGJlaGF2aW91ciBvZiB0aGUge0BsaW5rIENsaWVudH0uXG4gKi9cblxuLyoqIFRoZSBgQ2xpZW50YCBpcyB0aGUgY2VudHJhbCBodWIgZm9yIHlvdXIgR3JhcGhRTCBvcGVyYXRpb25zIGFuZCBob2xkcyBgdXJxbGAncyBzdGF0ZS5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhlIGBDbGllbnRgIG1hbmFnZXMgeW91ciBhY3RpdmUgR3JhcGhRTCBvcGVyYXRpb25zIGFuZCB0aGVpciBzdGF0ZSwgYW5kIGNvbnRhaW5zIHRoZVxuICoge0BsaW5rIEV4Y2hhbmdlfSBwaXBlbGluZSB0byBleGVjdXRlIHlvdXIgR3JhcGhRTCBvcGVyYXRpb25zLlxuICpcbiAqIEl0IGNvbnRhaW5zIG1ldGhvZHMgdGhhdCBhbGxvdyB5b3UgdG8gZXhlY3V0ZSBHcmFwaFFMIG9wZXJhdGlvbnMgbWFudWFsbHksIGJ1dCB0aGUgYENsaWVudGBcbiAqIGlzIGFsc28gaW50ZXJhY3RlZCB3aXRoIGJ5IGJpbmRpbmdzIChmb3IgUmVhY3QsIFByZWFjdCwgVnVlLCBTdmVsdGUsIGV0YykgdG8gZXhlY3V0ZSBHcmFwaFFMXG4gKiBvcGVyYXRpb25zLlxuICpcbiAqIFdoaWxlIHtAbGluayBFeGNoYW5nZSB8IEV4Y2hhbmdlc30gYXJlIHVsdGltYXRlbHkgcmVzcG9uc2libGUgZm9yIHRoZSBjb250cm9sIGZsb3cgb2Ygb3BlcmF0aW9ucyxcbiAqIHNlbmRpbmcgQVBJIHJlcXVlc3RzLCBhbmQgY2FjaGluZywgdGhlIGBDbGllbnRgIHN0aWxsIGhhcyB0aGUgaW1wb3J0YW50IHJlc3BvbnNpYmlsaXR5IGZvclxuICogY3JlYXRpbmcgb3BlcmF0aW9ucywgbWFuYWdpbmcgY29uc3VtZXJzIG9mIGFjdGl2ZSBvcGVyYXRpb25zLCBzaGFyaW5nIHJlc3VsdHMgZm9yIG9wZXJhdGlvbnMsXG4gKiBhbmQgbW9yZSB0YXNrcyBhcyBhIOKAnGNlbnRyYWwgaHVi4oCdLlxuICpcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdXJxbC5kZXYvZ290by9kb2NzL2FyY2hpdGVjdHVyZS8jcmVxdWVzdHMtYW5kLW9wZXJhdGlvbnMtb24tdGhlLWNsaWVudH0gZm9yIG1vcmUgaW5mb3JtYXRpb25cbiAqIG9uIHdoYXQgdGhlIGBDbGllbnRgIGlzIGFuZCBkb2VzLlxuICovXG5cbnZhciBDbGllbnQgPSBmdW5jdGlvbiBDbGllbnQob3B0cykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhb3B0cy51cmwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBhcmUgY3JlYXRpbmcgYW4gdXJxbC1jbGllbnQgd2l0aG91dCBhIHVybC4nKTtcbiAgfVxuICB2YXIgaWRzID0gMDtcbiAgdmFyIHJlcGxheXMgPSBuZXcgTWFwKCk7XG4gIHZhciBhY3RpdmUgPSBuZXcgTWFwKCk7XG4gIHZhciBkaXNwYXRjaGVkID0gbmV3IFNldCgpO1xuICB2YXIgcXVldWUgPSBbXTtcbiAgdmFyIGJhc2VPcHRzID0ge1xuICAgIHVybDogb3B0cy51cmwsXG4gICAgZmV0Y2hTdWJzY3JpcHRpb25zOiBvcHRzLmZldGNoU3Vic2NyaXB0aW9ucyxcbiAgICBmZXRjaE9wdGlvbnM6IG9wdHMuZmV0Y2hPcHRpb25zLFxuICAgIGZldGNoOiBvcHRzLmZldGNoLFxuICAgIHByZWZlckdldE1ldGhvZDogISFvcHRzLnByZWZlckdldE1ldGhvZCxcbiAgICByZXF1ZXN0UG9saWN5OiBvcHRzLnJlcXVlc3RQb2xpY3kgfHwgJ2NhY2hlLWZpcnN0J1xuICB9O1xuXG4gIC8vIFRoaXMgc3ViamVjdCBmb3JtcyB0aGUgaW5wdXQgb2Ygb3BlcmF0aW9uczsgZXhlY3V0ZU9wZXJhdGlvbiBtYXkgYmVcbiAgLy8gY2FsbGVkIHRvIGRpc3BhdGNoIGEgbmV3IG9wZXJhdGlvbiBvbiB0aGUgc3ViamVjdFxuICB2YXIgb3BlcmF0aW9ucyA9IHdvbmthLm1ha2VTdWJqZWN0KCk7XG4gIGZ1bmN0aW9uIG5leHRPcGVyYXRpb24ob3BlcmF0aW9uKSB7XG4gICAgaWYgKG9wZXJhdGlvbi5raW5kID09PSAnbXV0YXRpb24nIHx8IG9wZXJhdGlvbi5raW5kID09PSAndGVhcmRvd24nIHx8ICFkaXNwYXRjaGVkLmhhcyhvcGVyYXRpb24ua2V5KSkge1xuICAgICAgaWYgKG9wZXJhdGlvbi5raW5kID09PSAndGVhcmRvd24nKSB7XG4gICAgICAgIGRpc3BhdGNoZWQuZGVsZXRlKG9wZXJhdGlvbi5rZXkpO1xuICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24ua2luZCAhPT0gJ211dGF0aW9uJykge1xuICAgICAgICBkaXNwYXRjaGVkLmFkZChvcGVyYXRpb24ua2V5KTtcbiAgICAgIH1cbiAgICAgIG9wZXJhdGlvbnMubmV4dChvcGVyYXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFdlIGRlZmluZSBhIHF1ZXVlZCBkaXNwYXRjaGVyIG9uIHRoZSBzdWJqZWN0LCB3aGljaCBlbXB0aWVzIHRoZSBxdWV1ZSB3aGVuIGl0J3NcbiAgLy8gYWN0aXZhdGVkIHRvIGFsbG93IGByZWV4ZWN1dGVPcGVyYXRpb25gIHRvIGJlIHRyYW1wb2xpbmUtc2NoZWR1bGVkXG4gIHZhciBpc09wZXJhdGlvbkJhdGNoQWN0aXZlID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRpc3BhdGNoT3BlcmF0aW9uKG9wZXJhdGlvbikge1xuICAgIGlmIChvcGVyYXRpb24pIG5leHRPcGVyYXRpb24ob3BlcmF0aW9uKTtcbiAgICBpZiAoIWlzT3BlcmF0aW9uQmF0Y2hBY3RpdmUpIHtcbiAgICAgIGlzT3BlcmF0aW9uQmF0Y2hBY3RpdmUgPSB0cnVlO1xuICAgICAgd2hpbGUgKGlzT3BlcmF0aW9uQmF0Y2hBY3RpdmUgJiYgKG9wZXJhdGlvbiA9IHF1ZXVlLnNoaWZ0KCkpKSBuZXh0T3BlcmF0aW9uKG9wZXJhdGlvbik7XG4gICAgICBpc09wZXJhdGlvbkJhdGNoQWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqIERlZmluZXMgaG93IHJlc3VsdCBzdHJlYW1zIGFyZSBjcmVhdGVkICovXG4gIHZhciBtYWtlUmVzdWx0U291cmNlID0gb3BlcmF0aW9uID0+IHtcbiAgICB2YXIgcmVzdWx0JCA9XG4gICAgLy8gRW5kIHRoZSByZXN1bHRzIHN0cmVhbSB3aGVuIGFuIGFjdGl2ZSB0ZWFyZG93biBldmVudCBpcyBzZW50XG4gICAgd29ua2EudGFrZVVudGlsKHdvbmthLmZpbHRlcihvcCA9PiBvcC5raW5kID09PSAndGVhcmRvd24nICYmIG9wLmtleSA9PT0gb3BlcmF0aW9uLmtleSkob3BlcmF0aW9ucy5zb3VyY2UpKShcbiAgICAvLyBGaWx0ZXIgYnkgbWF0Y2hpbmcga2V5IChvciBfaW5zdGFuY2UgaWYgaXTigJlzIHNldClcbiAgICB3b25rYS5maWx0ZXIocmVzID0+IHJlcy5vcGVyYXRpb24ua2luZCA9PT0gb3BlcmF0aW9uLmtpbmQgJiYgcmVzLm9wZXJhdGlvbi5rZXkgPT09IG9wZXJhdGlvbi5rZXkgJiYgKCFyZXMub3BlcmF0aW9uLmNvbnRleHQuX2luc3RhbmNlIHx8IHJlcy5vcGVyYXRpb24uY29udGV4dC5faW5zdGFuY2UgPT09IG9wZXJhdGlvbi5jb250ZXh0Ll9pbnN0YW5jZSkpKHJlc3VsdHMkKSk7XG4gICAgaWYgKG9wZXJhdGlvbi5raW5kICE9PSAncXVlcnknKSB7XG4gICAgICAvLyBJbnRlcnJ1cHQgc3Vic2NyaXB0aW9ucyBhbmQgbXV0YXRpb25zIHdoZW4gdGhleSBoYXZlIG5vIG1vcmUgcmVzdWx0c1xuICAgICAgcmVzdWx0JCA9IHdvbmthLnRha2VXaGlsZShyZXN1bHQgPT4gISFyZXN1bHQuaGFzTmV4dCwgdHJ1ZSkocmVzdWx0JCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCQgPVxuICAgICAgLy8gQWRkIGBzdGFsZTogdHJ1ZWAgZmxhZyB3aGVuIGEgbmV3IG9wZXJhdGlvbiBpcyBzZW50IGZvciBxdWVyaWVzXG4gICAgICB3b25rYS5zd2l0Y2hNYXAocmVzdWx0ID0+IHtcbiAgICAgICAgdmFyIHZhbHVlJCA9IHdvbmthLmZyb21WYWx1ZShyZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LnN0YWxlIHx8IHJlc3VsdC5oYXNOZXh0ID8gdmFsdWUkIDogd29ua2EubWVyZ2UoW3ZhbHVlJCwgd29ua2EubWFwKCgpID0+IHtcbiAgICAgICAgICByZXN1bHQuc3RhbGUgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pKHdvbmthLnRha2UoMSkod29ua2EuZmlsdGVyKG9wID0+IG9wLmtleSA9PT0gb3BlcmF0aW9uLmtleSkob3BlcmF0aW9ucy5zb3VyY2UpKSldKTtcbiAgICAgIH0pKHJlc3VsdCQpO1xuICAgIH1cbiAgICBpZiAob3BlcmF0aW9uLmtpbmQgIT09ICdtdXRhdGlvbicpIHtcbiAgICAgIHJlc3VsdCQgPVxuICAgICAgLy8gQ2xlYW51cCBhY3RpdmUgc3RhdGVzIG9uIGVuZCBvZiBzb3VyY2VcbiAgICAgIHdvbmthLm9uRW5kKCgpID0+IHtcbiAgICAgICAgLy8gRGVsZXRlIHRoZSBhY3RpdmUgb3BlcmF0aW9uIGhhbmRsZVxuICAgICAgICBkaXNwYXRjaGVkLmRlbGV0ZShvcGVyYXRpb24ua2V5KTtcbiAgICAgICAgcmVwbGF5cy5kZWxldGUob3BlcmF0aW9uLmtleSk7XG4gICAgICAgIGFjdGl2ZS5kZWxldGUob3BlcmF0aW9uLmtleSk7XG4gICAgICAgIC8vIEludGVycnVwdCBhY3RpdmUgcXVldWVcbiAgICAgICAgaXNPcGVyYXRpb25CYXRjaEFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAvLyBEZWxldGUgYWxsIHF1ZXVlZCB1cCBvcGVyYXRpb25zIG9mIHRoZSBzYW1lIGtleSBvbiBlbmRcbiAgICAgICAgZm9yICh2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAocXVldWVbaV0ua2V5ID09PSBvcGVyYXRpb24ua2V5KSBxdWV1ZS5zcGxpY2UoaSwgMSk7XG4gICAgICAgIC8vIERpc3BhdGNoIGEgdGVhcmRvd24gc2lnbmFsIGZvciB0aGUgc3RvcHBlZCBvcGVyYXRpb25cbiAgICAgICAgbmV4dE9wZXJhdGlvbihtYWtlT3BlcmF0aW9uKCd0ZWFyZG93bicsIG9wZXJhdGlvbiwgb3BlcmF0aW9uLmNvbnRleHQpKTtcbiAgICAgIH0pKFxuICAgICAgLy8gU3RvcmUgcmVwbGF5IHJlc3VsdFxuICAgICAgd29ua2Eub25QdXNoKHJlc3VsdCA9PiB7XG4gICAgICAgIGlmIChyZXN1bHQuc3RhbGUpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgY3VycmVudCByZXN1bHQgaGFzIHF1ZXVlZCB1cCBhbiBvcGVyYXRpb24gb2YgdGhlIHNhbWVcbiAgICAgICAgICAvLyBrZXksIHRoZW4gYHN0YWxlYCByZWZlcnMgdG8gaXRcbiAgICAgICAgICBmb3IgKHZhciBfb3BlcmF0aW9uIG9mIHF1ZXVlKSB7XG4gICAgICAgICAgICBpZiAoX29wZXJhdGlvbi5rZXkgPT09IHJlc3VsdC5vcGVyYXRpb24ua2V5KSB7XG4gICAgICAgICAgICAgIGRpc3BhdGNoZWQuZGVsZXRlKF9vcGVyYXRpb24ua2V5KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFyZXN1bHQuaGFzTmV4dCkge1xuICAgICAgICAgIGRpc3BhdGNoZWQuZGVsZXRlKG9wZXJhdGlvbi5rZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJlcGxheXMuc2V0KG9wZXJhdGlvbi5rZXksIHJlc3VsdCk7XG4gICAgICB9KShyZXN1bHQkKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCQgPVxuICAgICAgLy8gU2VuZCBtdXRhdGlvbiBvcGVyYXRpb24gb24gc3RhcnRcbiAgICAgIHdvbmthLm9uU3RhcnQoKCkgPT4ge1xuICAgICAgICBuZXh0T3BlcmF0aW9uKG9wZXJhdGlvbik7XG4gICAgICB9KShyZXN1bHQkKTtcbiAgICB9XG5cbiAgICAvLyBNYXNrIHR5cGVuYW1lIHByb3BlcnRpZXMgaWYgdGhlIG9wdGlvbiBmb3IgaXQgaXMgdHVybmVkIG9uXG4gICAgaWYgKG9wdHMubWFza1R5cGVuYW1lKSB7XG4gICAgICByZXN1bHQkID0gd29ua2EubWFwKHJlcyA9PiAoe1xuICAgICAgICAuLi5yZXMsXG4gICAgICAgIGRhdGE6IG1hc2tUeXBlbmFtZShyZXMuZGF0YSwgdHJ1ZSlcbiAgICAgIH0pKShyZXN1bHQkKTtcbiAgICB9XG4gICAgcmV0dXJuIHdvbmthLnNoYXJlKHJlc3VsdCQpO1xuICB9O1xuICB2YXIgaW5zdGFuY2UgPSB0aGlzIGluc3RhbmNlb2YgQ2xpZW50ID8gdGhpcyA6IE9iamVjdC5jcmVhdGUoQ2xpZW50LnByb3RvdHlwZSk7XG4gIHZhciBjbGllbnQgPSBPYmplY3QuYXNzaWduKGluc3RhbmNlLCB7XG4gICAgc3VzcGVuc2U6ICEhb3B0cy5zdXNwZW5zZSxcbiAgICBvcGVyYXRpb25zJDogb3BlcmF0aW9ucy5zb3VyY2UsXG4gICAgcmVleGVjdXRlT3BlcmF0aW9uKG9wZXJhdGlvbikge1xuICAgICAgLy8gUmVleGVjdXRlIG9wZXJhdGlvbiBvbmx5IGlmIGFueSBzdWJzY3JpYmVycyBhcmUgc3RpbGwgc3Vic2NyaWJlZCB0byB0aGVcbiAgICAgIC8vIG9wZXJhdGlvbidzIGV4Y2hhbmdlIHJlc3VsdHNcbiAgICAgIGlmIChvcGVyYXRpb24ua2luZCA9PT0gJ3RlYXJkb3duJykge1xuICAgICAgICBkaXNwYXRjaE9wZXJhdGlvbihvcGVyYXRpb24pO1xuICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24ua2luZCA9PT0gJ211dGF0aW9uJyB8fCBhY3RpdmUuaGFzKG9wZXJhdGlvbi5rZXkpKSB7XG4gICAgICAgIHF1ZXVlLnB1c2gob3BlcmF0aW9uKTtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihkaXNwYXRjaE9wZXJhdGlvbik7XG4gICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGVSZXF1ZXN0T3BlcmF0aW9uKGtpbmQsIHJlcXVlc3QsIG9wdHMpIHtcbiAgICAgIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICAgICAgdmFyIHJlcXVlc3RPcGVyYXRpb25UeXBlO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYga2luZCAhPT0gJ3RlYXJkb3duJyAmJiAocmVxdWVzdE9wZXJhdGlvblR5cGUgPSBmZXRjaFNvdXJjZS5nZXRPcGVyYXRpb25UeXBlKHJlcXVlc3QucXVlcnkpKSAhPT0ga2luZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIG9wZXJhdGlvbiBvZiB0eXBlIFwiJHtraW5kfVwiIGJ1dCBmb3VuZCBcIiR7cmVxdWVzdE9wZXJhdGlvblR5cGV9XCJgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYWtlT3BlcmF0aW9uKGtpbmQsIHJlcXVlc3QsIHtcbiAgICAgICAgX2luc3RhbmNlOiBraW5kID09PSAnbXV0YXRpb24nID8gaWRzID0gaWRzICsgMSB8IDAgOiB1bmRlZmluZWQsXG4gICAgICAgIC4uLmJhc2VPcHRzLFxuICAgICAgICAuLi5vcHRzLFxuICAgICAgICByZXF1ZXN0UG9saWN5OiBvcHRzLnJlcXVlc3RQb2xpY3kgfHwgYmFzZU9wdHMucmVxdWVzdFBvbGljeSxcbiAgICAgICAgc3VzcGVuc2U6IG9wdHMuc3VzcGVuc2UgfHwgb3B0cy5zdXNwZW5zZSAhPT0gZmFsc2UgJiYgY2xpZW50LnN1c3BlbnNlXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGV4ZWN1dGVSZXF1ZXN0T3BlcmF0aW9uKG9wZXJhdGlvbikge1xuICAgICAgaWYgKG9wZXJhdGlvbi5raW5kID09PSAnbXV0YXRpb24nKSB7XG4gICAgICAgIHJldHVybiB3aXRoUHJvbWlzZShtYWtlUmVzdWx0U291cmNlKG9wZXJhdGlvbikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdpdGhQcm9taXNlKHdvbmthLmxhenkoKCkgPT4ge1xuICAgICAgICB2YXIgc291cmNlID0gYWN0aXZlLmdldChvcGVyYXRpb24ua2V5KTtcbiAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICBhY3RpdmUuc2V0KG9wZXJhdGlvbi5rZXksIHNvdXJjZSA9IG1ha2VSZXN1bHRTb3VyY2Uob3BlcmF0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlID0gd29ua2Eub25TdGFydCgoKSA9PiB7XG4gICAgICAgICAgZGlzcGF0Y2hPcGVyYXRpb24ob3BlcmF0aW9uKTtcbiAgICAgICAgfSkoc291cmNlKTtcbiAgICAgICAgdmFyIHJlcGxheSA9IHJlcGxheXMuZ2V0KG9wZXJhdGlvbi5rZXkpO1xuICAgICAgICBpZiAob3BlcmF0aW9uLmtpbmQgPT09ICdxdWVyeScgJiYgcmVwbGF5ICYmIChyZXBsYXkuc3RhbGUgfHwgcmVwbGF5Lmhhc05leHQpKSB7XG4gICAgICAgICAgcmV0dXJuIHdvbmthLnN3aXRjaE1hcCh3b25rYS5mcm9tVmFsdWUpKHdvbmthLm1lcmdlKFtzb3VyY2UsIHdvbmthLmZpbHRlcihyZXBsYXkgPT4gcmVwbGF5ID09PSByZXBsYXlzLmdldChvcGVyYXRpb24ua2V5KSkod29ua2EuZnJvbVZhbHVlKHJlcGxheSkpXSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9LFxuICAgIGV4ZWN1dGVRdWVyeShxdWVyeSwgb3B0cykge1xuICAgICAgdmFyIG9wZXJhdGlvbiA9IGNsaWVudC5jcmVhdGVSZXF1ZXN0T3BlcmF0aW9uKCdxdWVyeScsIHF1ZXJ5LCBvcHRzKTtcbiAgICAgIHJldHVybiBjbGllbnQuZXhlY3V0ZVJlcXVlc3RPcGVyYXRpb24ob3BlcmF0aW9uKTtcbiAgICB9LFxuICAgIGV4ZWN1dGVTdWJzY3JpcHRpb24ocXVlcnksIG9wdHMpIHtcbiAgICAgIHZhciBvcGVyYXRpb24gPSBjbGllbnQuY3JlYXRlUmVxdWVzdE9wZXJhdGlvbignc3Vic2NyaXB0aW9uJywgcXVlcnksIG9wdHMpO1xuICAgICAgcmV0dXJuIGNsaWVudC5leGVjdXRlUmVxdWVzdE9wZXJhdGlvbihvcGVyYXRpb24pO1xuICAgIH0sXG4gICAgZXhlY3V0ZU11dGF0aW9uKHF1ZXJ5LCBvcHRzKSB7XG4gICAgICB2YXIgb3BlcmF0aW9uID0gY2xpZW50LmNyZWF0ZVJlcXVlc3RPcGVyYXRpb24oJ211dGF0aW9uJywgcXVlcnksIG9wdHMpO1xuICAgICAgcmV0dXJuIGNsaWVudC5leGVjdXRlUmVxdWVzdE9wZXJhdGlvbihvcGVyYXRpb24pO1xuICAgIH0sXG4gICAgcmVhZFF1ZXJ5KHF1ZXJ5LCB2YXJpYWJsZXMsIGNvbnRleHQpIHtcbiAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgd29ua2Euc3Vic2NyaWJlKHJlcyA9PiB7XG4gICAgICAgIHJlc3VsdCA9IHJlcztcbiAgICAgIH0pKGNsaWVudC5xdWVyeShxdWVyeSwgdmFyaWFibGVzLCBjb250ZXh0KSkudW5zdWJzY3JpYmUoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICBxdWVyeShxdWVyeSwgdmFyaWFibGVzLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gY2xpZW50LmV4ZWN1dGVRdWVyeShmZXRjaFNvdXJjZS5jcmVhdGVSZXF1ZXN0KHF1ZXJ5LCB2YXJpYWJsZXMpLCBjb250ZXh0KTtcbiAgICB9LFxuICAgIHN1YnNjcmlwdGlvbihxdWVyeSwgdmFyaWFibGVzLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gY2xpZW50LmV4ZWN1dGVTdWJzY3JpcHRpb24oZmV0Y2hTb3VyY2UuY3JlYXRlUmVxdWVzdChxdWVyeSwgdmFyaWFibGVzKSwgY29udGV4dCk7XG4gICAgfSxcbiAgICBtdXRhdGlvbihxdWVyeSwgdmFyaWFibGVzLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gY2xpZW50LmV4ZWN1dGVNdXRhdGlvbihmZXRjaFNvdXJjZS5jcmVhdGVSZXF1ZXN0KHF1ZXJ5LCB2YXJpYWJsZXMpLCBjb250ZXh0KTtcbiAgICB9XG4gIH0pO1xuICB2YXIgZGlzcGF0Y2hEZWJ1ZyA9IG5vb3A7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIHtcbiAgICAgIG5leHQsXG4gICAgICBzb3VyY2VcbiAgICB9ID0gd29ua2EubWFrZVN1YmplY3QoKTtcbiAgICBjbGllbnQuc3Vic2NyaWJlVG9EZWJ1Z1RhcmdldCA9IG9uRXZlbnQgPT4gd29ua2Euc3Vic2NyaWJlKG9uRXZlbnQpKHNvdXJjZSk7XG4gICAgZGlzcGF0Y2hEZWJ1ZyA9IG5leHQ7XG4gIH1cblxuICAvLyBBbGwgZXhjaGFuZ2UgYXJlIGNvbXBvc2VkIGludG8gYSBzaW5nbGUgb25lIGFuZCBhcmUgY2FsbGVkIHVzaW5nIHRoZSBjb25zdHJ1Y3RlZCBjbGllbnRcbiAgLy8gYW5kIHRoZSBmYWxsYmFjayBleGNoYW5nZSBzdHJlYW1cbiAgdmFyIGNvbXBvc2VkRXhjaGFuZ2UgPSBjb21wb3NlRXhjaGFuZ2VzKG9wdHMuZXhjaGFuZ2VzKTtcblxuICAvLyBBbGwgZXhjaGFuZ2VzIHJlY2VpdmUgaW5wdXRzIHVzaW5nIHdoaWNoIHRoZXkgY2FuIGZvcndhcmQgb3BlcmF0aW9ucyB0byB0aGUgbmV4dCBleGNoYW5nZVxuICAvLyBhbmQgcmVjZWl2ZSBhIHN0cmVhbSBvZiByZXN1bHRzIGluIHJldHVybiwgYWNjZXNzIHRoZSBjbGllbnQsIG9yIGRpc3BhdGNoIGRlYnVnZ2luZyBldmVudHNcbiAgLy8gQWxsIG9wZXJhdGlvbnMgdGhlbiBydW4gdGhyb3VnaCB0aGUgRXhjaGFuZ2UgSU9zIGluIGEgcGlwZWxpbmUtbGlrZSBmYXNoaW9uXG4gIHZhciByZXN1bHRzJCA9IHdvbmthLnNoYXJlKGNvbXBvc2VkRXhjaGFuZ2Uoe1xuICAgIGNsaWVudCxcbiAgICBkaXNwYXRjaERlYnVnLFxuICAgIGZvcndhcmQ6IGZhbGxiYWNrRXhjaGFuZ2Uoe1xuICAgICAgZGlzcGF0Y2hEZWJ1Z1xuICAgIH0pXG4gIH0pKG9wZXJhdGlvbnMuc291cmNlKSk7XG5cbiAgLy8gUHJldmVudCB0aGUgYHJlc3VsdHMkYCBleGNoYW5nZSBwaXBlbGluZSBmcm9tIGJlaW5nIGNsb3NlZCBieSBhY3RpdmVcbiAgLy8gY2FuY2VsbGF0aW9ucyBjYXNjYWRpbmcgdXAgZnJvbSBjb21wb25lbnRzXG4gIHdvbmthLnB1Ymxpc2gocmVzdWx0cyQpO1xuICByZXR1cm4gY2xpZW50O1xufTtcblxuLyoqIEFjY2VwdHMgYENsaWVudE9wdGlvbnNgIGFuZCBjcmVhdGVzIGEgYENsaWVudGAuXG4gKiBAcGFyYW0gb3B0cyAtIEEge0BsaW5rIENsaWVudE9wdGlvbnN9IG9iamVjdHMgd2l0aCBvcHRpb25zIGZvciB0aGUgYENsaWVudGAuXG4gKiBAcmV0dXJucyBBIHtAbGluayBDbGllbnR9IGluc3RhbnRpYXRlZCB3aXRoIGBvcHRzYC5cbiAqL1xudmFyIGNyZWF0ZUNsaWVudCA9IENsaWVudDtcblxuZXhwb3J0cy5Db21iaW5lZEVycm9yID0gZmV0Y2hTb3VyY2UuQ29tYmluZWRFcnJvcjtcbmV4cG9ydHMuY3JlYXRlUmVxdWVzdCA9IGZldGNoU291cmNlLmNyZWF0ZVJlcXVlc3Q7XG5leHBvcnRzLm1ha2VFcnJvclJlc3VsdCA9IGZldGNoU291cmNlLm1ha2VFcnJvclJlc3VsdDtcbmV4cG9ydHMubWFrZVJlc3VsdCA9IGZldGNoU291cmNlLm1ha2VSZXN1bHQ7XG5leHBvcnRzLm1lcmdlUmVzdWx0UGF0Y2ggPSBmZXRjaFNvdXJjZS5tZXJnZVJlc3VsdFBhdGNoO1xuZXhwb3J0cy5zdHJpbmdpZnlEb2N1bWVudCA9IGZldGNoU291cmNlLnN0cmluZ2lmeURvY3VtZW50O1xuZXhwb3J0cy5zdHJpbmdpZnlWYXJpYWJsZXMgPSBmZXRjaFNvdXJjZS5zdHJpbmdpZnlWYXJpYWJsZXM7XG5leHBvcnRzLkNsaWVudCA9IENsaWVudDtcbmV4cG9ydHMuY2FjaGVFeGNoYW5nZSA9IGNhY2hlRXhjaGFuZ2U7XG5leHBvcnRzLmNvbXBvc2VFeGNoYW5nZXMgPSBjb21wb3NlRXhjaGFuZ2VzO1xuZXhwb3J0cy5jcmVhdGVDbGllbnQgPSBjcmVhdGVDbGllbnQ7XG5leHBvcnRzLmRlYnVnRXhjaGFuZ2UgPSBkZWJ1Z0V4Y2hhbmdlO1xuZXhwb3J0cy5kZWR1cEV4Y2hhbmdlID0gZGVkdXBFeGNoYW5nZTtcbmV4cG9ydHMuZXJyb3JFeGNoYW5nZSA9IG1hcEV4Y2hhbmdlO1xuZXhwb3J0cy5mZXRjaEV4Y2hhbmdlID0gZmV0Y2hFeGNoYW5nZTtcbmV4cG9ydHMuZm9ybWF0RG9jdW1lbnQgPSBmb3JtYXREb2N1bWVudDtcbmV4cG9ydHMuZ3FsID0gZ3FsO1xuZXhwb3J0cy5tYWtlT3BlcmF0aW9uID0gbWFrZU9wZXJhdGlvbjtcbmV4cG9ydHMubWFwRXhjaGFuZ2UgPSBtYXBFeGNoYW5nZTtcbmV4cG9ydHMubWFza1R5cGVuYW1lID0gbWFza1R5cGVuYW1lO1xuZXhwb3J0cy5zc3JFeGNoYW5nZSA9IHNzckV4Y2hhbmdlO1xuZXhwb3J0cy5zdWJzY3JpcHRpb25FeGNoYW5nZSA9IHN1YnNjcmlwdGlvbkV4Y2hhbmdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJxbC1jb3JlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/../../node_modules/.pnpm/@urql+core@4.0.10_graphql@16.11.0/node_modules/@urql/core/dist/urql-core.js\n");

/***/ }),

/***/ "(pages-dir-node)/../../node_modules/.pnpm/@urql+core@4.0.10_graphql@16.11.0/node_modules/@urql/core/dist/urql-core.mjs":
/*!*************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@urql+core@4.0.10_graphql@16.11.0/node_modules/@urql/core/dist/urql-core.mjs ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* binding */ C),\n/* harmony export */   CombinedError: () => (/* reexport safe */ _urql_core_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.C),\n/* harmony export */   cacheExchange: () => (/* binding */ cacheExchange),\n/* harmony export */   composeExchanges: () => (/* binding */ composeExchanges),\n/* harmony export */   createClient: () => (/* binding */ j),\n/* harmony export */   createRequest: () => (/* reexport safe */ _urql_core_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   debugExchange: () => (/* binding */ debugExchange),\n/* harmony export */   dedupExchange: () => (/* binding */ dedupExchange),\n/* harmony export */   errorExchange: () => (/* binding */ mapExchange),\n/* harmony export */   fetchExchange: () => (/* binding */ fetchExchange),\n/* harmony export */   formatDocument: () => (/* binding */ formatDocument),\n/* harmony export */   gql: () => (/* binding */ gql),\n/* harmony export */   makeErrorResult: () => (/* reexport safe */ _urql_core_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   makeOperation: () => (/* binding */ makeOperation),\n/* harmony export */   makeResult: () => (/* reexport safe */ _urql_core_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.b),\n/* harmony export */   mapExchange: () => (/* binding */ mapExchange),\n/* harmony export */   maskTypename: () => (/* binding */ maskTypename),\n/* harmony export */   mergeResultPatch: () => (/* reexport safe */ _urql_core_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.a),\n/* harmony export */   ssrExchange: () => (/* binding */ ssrExchange),\n/* harmony export */   stringifyDocument: () => (/* reexport safe */ _urql_core_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.s),\n/* harmony export */   stringifyVariables: () => (/* reexport safe */ _urql_core_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.i),\n/* harmony export */   subscriptionExchange: () => (/* binding */ subscriptionExchange)\n/* harmony export */ });\n/* harmony import */ var _0no_co_graphql_web__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @0no-co/graphql.web */ \"(pages-dir-node)/../../node_modules/.pnpm/@0no-co+graphql.web@1.0.4_graphql@16.11.0/node_modules/@0no-co/graphql.web/dist/graphql.web.mjs\");\n/* harmony import */ var _urql_core_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./urql-core-chunk.mjs */ \"(pages-dir-node)/../../node_modules/.pnpm/@urql+core@4.0.10_graphql@16.11.0/node_modules/@urql/core/dist/urql-core-chunk.mjs\");\n/* harmony import */ var wonka__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! wonka */ \"(pages-dir-node)/../../node_modules/.pnpm/wonka@6.3.2/node_modules/wonka/dist/wonka.mjs\");\n\n\n\n\n\n\n\n\nvar collectTypes = (e, r) => {\n  if (Array.isArray(e)) {\n    for (var t of e) {\n      collectTypes(t, r);\n    }\n  } else if (\"object\" == typeof e && null !== e) {\n    for (var n in e) {\n      if (\"__typename\" === n && \"string\" == typeof e[n]) {\n        r.add(e[n]);\n      } else {\n        collectTypes(e[n], r);\n      }\n    }\n  }\n  return r;\n};\n\nvar formatNode = r => {\n  var t = !1;\n  if (\"definitions\" in r) {\n    var n = [];\n    for (var a of r.definitions) {\n      var o = formatNode(a);\n      t = t || o !== a;\n      n.push(o);\n    }\n    if (t) {\n      return {\n        ...r,\n        definitions: n\n      };\n    }\n  } else if (\"selectionSet\" in r) {\n    var i = [];\n    var s = r.kind === _0no_co_graphql_web__WEBPACK_IMPORTED_MODULE_1__.Kind.OPERATION_DEFINITION;\n    if (r.selectionSet) {\n      for (var c of r.selectionSet.selections || []) {\n        s = s || c.kind === _0no_co_graphql_web__WEBPACK_IMPORTED_MODULE_1__.Kind.FIELD && \"__typename\" === c.name.value && !c.alias;\n        var u = formatNode(c);\n        t = t || u !== c;\n        i.push(u);\n      }\n      if (!s) {\n        t = !0;\n        i.push({\n          kind: _0no_co_graphql_web__WEBPACK_IMPORTED_MODULE_1__.Kind.FIELD,\n          name: {\n            kind: _0no_co_graphql_web__WEBPACK_IMPORTED_MODULE_1__.Kind.NAME,\n            value: \"__typename\"\n          }\n        });\n      }\n      if (t) {\n        return {\n          ...r,\n          selectionSet: {\n            ...r.selectionSet,\n            selections: i\n          }\n        };\n      }\n    }\n  }\n  return r;\n};\n\nvar I = new Map;\n\nvar formatDocument = e => {\n  var t = (0,_urql_core_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(e);\n  var n = I.get(t.__key);\n  if (!n) {\n    I.set(t.__key, n = formatNode(t));\n    Object.defineProperty(n, \"__key\", {\n      value: t.__key,\n      enumerable: !1\n    });\n  }\n  return n;\n};\n\nvar maskTypename = (e, r) => {\n  if (!e || \"object\" != typeof e) {\n    return e;\n  } else if (Array.isArray(e)) {\n    return e.map((e => maskTypename(e)));\n  } else if (e && \"object\" == typeof e && (r || \"__typename\" in e)) {\n    var t = {};\n    for (var n in e) {\n      if (\"__typename\" === n) {\n        Object.defineProperty(t, \"__typename\", {\n          enumerable: !1,\n          value: e.__typename\n        });\n      } else {\n        t[n] = maskTypename(e[n]);\n      }\n    }\n    return t;\n  } else {\n    return e;\n  }\n};\n\nfunction withPromise(e) {\n  var source$ = r => e(r);\n  source$.toPromise = () => (0,wonka__WEBPACK_IMPORTED_MODULE_2__.toPromise)((0,wonka__WEBPACK_IMPORTED_MODULE_2__.take)(1)((0,wonka__WEBPACK_IMPORTED_MODULE_2__.filter)((e => !e.stale && !e.hasNext))(source$)));\n  source$.then = (e, r) => source$.toPromise().then(e, r);\n  source$.subscribe = e => (0,wonka__WEBPACK_IMPORTED_MODULE_2__.subscribe)(e)(source$);\n  return source$;\n}\n\nfunction makeOperation(e, r, t) {\n  return {\n    ...r,\n    kind: e,\n    context: r.context ? {\n      ...r.context,\n      ...t\n    } : t || r.context\n  };\n}\n\nvar addMetadata = (e, r) => makeOperation(e.kind, e, {\n  meta: {\n    ...e.context.meta,\n    ...r\n  }\n});\n\nvar noop = () => {};\n\nfunction gql(n) {\n  var a = new Map;\n  var o = [];\n  var i = [];\n  var s = Array.isArray(n) ? n[0] : n || \"\";\n  for (var c = 1; c < arguments.length; c++) {\n    var u = arguments[c];\n    if (u && u.definitions) {\n      i.push(u);\n    } else {\n      s += u;\n    }\n    s += arguments[0][c];\n  }\n  i.unshift((0,_urql_core_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(s));\n  for (var p of i) {\n    for (var d of p.definitions) {\n      if (d.kind === _0no_co_graphql_web__WEBPACK_IMPORTED_MODULE_1__.Kind.FRAGMENT_DEFINITION) {\n        var f = d.name.value;\n        var v = (0,_urql_core_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.s)(d);\n        if (!a.has(f)) {\n          a.set(f, v);\n          o.push(d);\n        } else if ( true && a.get(f) !== v) {\n          console.warn(\"[WARNING: Duplicate Fragment] A fragment with name `\" + f + \"` already exists in this document.\\nWhile fragment names may not be unique across your source, each name must be unique per document.\");\n        }\n      } else {\n        o.push(d);\n      }\n    }\n  }\n  return (0,_urql_core_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.k)({\n    kind: _0no_co_graphql_web__WEBPACK_IMPORTED_MODULE_1__.Kind.DOCUMENT,\n    definitions: o\n  });\n}\n\nvar shouldSkip = ({kind: e}) => \"mutation\" !== e && \"query\" !== e;\n\nvar cacheExchange = ({forward: e, client: r, dispatchDebug: t}) => {\n  var n = new Map;\n  var a = new Map;\n  var mapTypeNames = e => {\n    var r = makeOperation(e.kind, e);\n    r.query = formatDocument(e.query);\n    return r;\n  };\n  var isOperationCached = e => \"query\" === e.kind && \"network-only\" !== e.context.requestPolicy && (\"cache-only\" === e.context.requestPolicy || n.has(e.key));\n  return o => {\n    var i = (0,wonka__WEBPACK_IMPORTED_MODULE_2__.map)((e => {\n      var a = n.get(e.key);\n       true && t({\n        operation: e,\n        ...a ? {\n          type: \"cacheHit\",\n          message: \"The result was successfully retried from the cache\"\n        } : {\n          type: \"cacheMiss\",\n          message: \"The result could not be retrieved from the cache\"\n        },\n        source: \"cacheExchange\"\n      });\n      var o = a;\n      if (true) {\n        o = {\n          ...o,\n          operation:  true ? addMetadata(e, {\n            cacheOutcome: a ? \"hit\" : \"miss\"\n          }) : 0\n        };\n      }\n      if (\"cache-and-network\" === e.context.requestPolicy) {\n        o.stale = !0;\n        reexecuteOperation(r, e);\n      }\n      return o;\n    }))((0,wonka__WEBPACK_IMPORTED_MODULE_2__.filter)((e => !shouldSkip(e) && isOperationCached(e)))(o));\n    var s = (0,wonka__WEBPACK_IMPORTED_MODULE_2__.tap)((e => {\n      var {operation: o} = e;\n      if (!o) {\n        return;\n      }\n      var i = o.context.additionalTypenames || [];\n      if (\"subscription\" !== e.operation.kind) {\n        i = (e => [ ...collectTypes(e, new Set) ])(e.data).concat(i);\n      }\n      if (\"mutation\" === e.operation.kind || \"subscription\" === e.operation.kind) {\n        var s = new Set;\n         true && t({\n          type: \"cacheInvalidation\",\n          message: `The following typenames have been invalidated: ${i}`,\n          operation: o,\n          data: {\n            typenames: i,\n            response: e\n          },\n          source: \"cacheExchange\"\n        });\n        for (var c = 0; c < i.length; c++) {\n          var u = i[c];\n          var p = a.get(u);\n          if (!p) {\n            a.set(u, p = new Set);\n          }\n          for (var d of p.values()) {\n            s.add(d);\n          }\n          p.clear();\n        }\n        for (var f of s.values()) {\n          if (n.has(f)) {\n            o = n.get(f).operation;\n            n.delete(f);\n            reexecuteOperation(r, o);\n          }\n        }\n      } else if (\"query\" === o.kind && e.data) {\n        n.set(o.key, e);\n        for (var v = 0; v < i.length; v++) {\n          var l = i[v];\n          var h = a.get(l);\n          if (!h) {\n            a.set(l, h = new Set);\n          }\n          h.add(o.key);\n        }\n      }\n    }))(e((0,wonka__WEBPACK_IMPORTED_MODULE_2__.filter)((e => \"query\" !== e.kind || \"cache-only\" !== e.context.requestPolicy))((0,wonka__WEBPACK_IMPORTED_MODULE_2__.map)((e =>  true ? addMetadata(e, {\n      cacheOutcome: \"miss\"\n    }) : 0))((0,wonka__WEBPACK_IMPORTED_MODULE_2__.merge)([ (0,wonka__WEBPACK_IMPORTED_MODULE_2__.map)(mapTypeNames)((0,wonka__WEBPACK_IMPORTED_MODULE_2__.filter)((e => !shouldSkip(e) && !isOperationCached(e)))(o)), (0,wonka__WEBPACK_IMPORTED_MODULE_2__.filter)((e => shouldSkip(e)))(o) ])))));\n    return (0,wonka__WEBPACK_IMPORTED_MODULE_2__.merge)([ i, s ]);\n  };\n};\n\nvar reexecuteOperation = (e, r) => e.reexecuteOperation(makeOperation(r.kind, r, {\n  requestPolicy: \"network-only\"\n}));\n\nvar T = new Set;\n\nvar ssrExchange = (e = {}) => {\n  var r = !!e.staleWhileRevalidate;\n  var t = !!e.includeExtensions;\n  var a = {};\n  var o = [];\n  var invalidate = e => {\n    o.push(e.operation.key);\n    if (1 === o.length) {\n      Promise.resolve().then((() => {\n        var e;\n        while (e = o.shift()) {\n          a[e] = null;\n        }\n      }));\n    }\n  };\n  var ssr = ({client: o, forward: i}) => s => {\n    var c = e && \"boolean\" == typeof e.isClient ? !!e.isClient : !o.suspense;\n    var u = i((0,wonka__WEBPACK_IMPORTED_MODULE_2__.filter)((e => !a[e.key] || !!a[e.key].hasNext || \"network-only\" === e.context.requestPolicy))(s));\n    var p = (0,wonka__WEBPACK_IMPORTED_MODULE_2__.map)((e => {\n      var i = ((e, r, t) => ({\n        operation: e,\n        data: r.data ? JSON.parse(r.data) : void 0,\n        extensions: t && r.extensions ? JSON.parse(r.extensions) : void 0,\n        error: r.error ? new _urql_core_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.C({\n          networkError: r.error.networkError ? new Error(r.error.networkError) : void 0,\n          graphQLErrors: r.error.graphQLErrors\n        }) : void 0,\n        stale: !1,\n        hasNext: !!r.hasNext\n      }))(e, a[e.key], t);\n      if (r && !T.has(e.key)) {\n        i.stale = !0;\n        T.add(e.key);\n        reexecuteOperation(o, e);\n      }\n      return {\n        ...i,\n        operation:  true ? addMetadata(e, {\n          cacheOutcome: \"hit\"\n        }) : 0\n      };\n    }))((0,wonka__WEBPACK_IMPORTED_MODULE_2__.filter)((e => !!a[e.key] && \"network-only\" !== e.context.requestPolicy))(s));\n    if (!c) {\n      u = (0,wonka__WEBPACK_IMPORTED_MODULE_2__.tap)((e => {\n        var {operation: r} = e;\n        if (\"mutation\" !== r.kind) {\n          var n = ((e, r) => {\n            var t = {\n              data: JSON.stringify(e.data),\n              hasNext: e.hasNext\n            };\n            if (void 0 !== e.data) {\n              t.data = JSON.stringify(e.data);\n            }\n            if (r && void 0 !== e.extensions) {\n              t.extensions = JSON.stringify(e.extensions);\n            }\n            if (e.error) {\n              t.error = {\n                graphQLErrors: e.error.graphQLErrors.map((e => {\n                  if (!e.path && !e.extensions) {\n                    return e.message;\n                  }\n                  return {\n                    message: e.message,\n                    path: e.path,\n                    extensions: e.extensions\n                  };\n                }))\n              };\n              if (e.error.networkError) {\n                t.error.networkError = \"\" + e.error.networkError;\n              }\n            }\n            return t;\n          })(e, t);\n          a[r.key] = n;\n        }\n      }))(u);\n    } else {\n      p = (0,wonka__WEBPACK_IMPORTED_MODULE_2__.tap)(invalidate)(p);\n    }\n    return (0,wonka__WEBPACK_IMPORTED_MODULE_2__.merge)([ u, p ]);\n  };\n  ssr.restoreData = e => {\n    for (var r in e) {\n      if (null !== a[r]) {\n        a[r] = e[r];\n      }\n    }\n  };\n  ssr.extractData = () => {\n    var e = {};\n    for (var r in a) {\n      if (null != a[r]) {\n        e[r] = a[r];\n      }\n    }\n    return e;\n  };\n  if (e && e.initialState) {\n    ssr.restoreData(e.initialState);\n  }\n  return ssr;\n};\n\nvar subscriptionExchange = ({forwardSubscription: e, enableAllOperations: r, isSubscriptionOperation: t}) => ({client: n, forward: i}) => {\n  var u = t || (e => \"subscription\" === e.kind || !!r && (\"query\" === e.kind || \"mutation\" === e.kind));\n  return r => {\n    var t = (0,wonka__WEBPACK_IMPORTED_MODULE_2__.mergeMap)((t => {\n      var {key: i} = t;\n      var u = (0,wonka__WEBPACK_IMPORTED_MODULE_2__.filter)((e => \"teardown\" === e.kind && e.key === i))(r);\n      return (0,wonka__WEBPACK_IMPORTED_MODULE_2__.takeUntil)(u)((r => {\n        var t = e((0,_urql_core_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.m)(r), r);\n        return (0,wonka__WEBPACK_IMPORTED_MODULE_2__.make)((({next: e, complete: a}) => {\n          var i = !1;\n          var u;\n          var p;\n          Promise.resolve().then((() => {\n            if (i) {\n              return;\n            }\n            u = t.subscribe({\n              next(t) {\n                e(p = p ? (0,_urql_core_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.a)(p, t) : (0,_urql_core_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(r, t));\n              },\n              error(t) {\n                e((0,_urql_core_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.c)(r, t));\n              },\n              complete() {\n                if (!i) {\n                  i = !0;\n                  if (\"subscription\" === r.kind) {\n                    n.reexecuteOperation(makeOperation(\"teardown\", r, r.context));\n                  }\n                  if (p && p.hasNext) {\n                    e((0,_urql_core_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.a)(p, {\n                      hasNext: !1\n                    }));\n                  }\n                  a();\n                }\n              }\n            });\n          }));\n          return () => {\n            i = !0;\n            if (u) {\n              u.unsubscribe();\n            }\n          };\n        }));\n      })(t));\n    }))((0,wonka__WEBPACK_IMPORTED_MODULE_2__.filter)((e => \"teardown\" !== e.kind && u(e)))(r));\n    var p = i((0,wonka__WEBPACK_IMPORTED_MODULE_2__.filter)((e => \"teardown\" === e.kind || !u(e)))(r));\n    return (0,wonka__WEBPACK_IMPORTED_MODULE_2__.merge)([ t, p ]);\n  };\n};\n\nvar debugExchange = ({forward: e}) => {\n  if (false) {} else {\n    return r => (0,wonka__WEBPACK_IMPORTED_MODULE_2__.tap)((e => console.log(\"[Exchange debug]: Completed operation: \", e)))(e((0,wonka__WEBPACK_IMPORTED_MODULE_2__.tap)((e => console.log(\"[Exchange debug]: Incoming operation: \", e)))(r)));\n  }\n};\n\nvar dedupExchange = ({forward: e}) => r => e(r);\n\nvar fetchExchange = ({forward: e, dispatchDebug: r}) => t => {\n  var n = (0,wonka__WEBPACK_IMPORTED_MODULE_2__.mergeMap)((e => {\n    var n = (0,_urql_core_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.m)(e);\n    var o = (0,_urql_core_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.d)(e, n);\n    var i = (0,_urql_core_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.e)(e, n);\n     true && r({\n      type: \"fetchRequest\",\n      message: \"A fetch request is being executed.\",\n      operation: e,\n      data: {\n        url: o,\n        fetchOptions: i\n      },\n      source: \"fetchExchange\"\n    });\n    var s = (0,wonka__WEBPACK_IMPORTED_MODULE_2__.takeUntil)((0,wonka__WEBPACK_IMPORTED_MODULE_2__.filter)((r => \"teardown\" === r.kind && r.key === e.key))(t))((0,_urql_core_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.f)(e, o, i));\n    if (true) {\n      return (0,wonka__WEBPACK_IMPORTED_MODULE_2__.onPush)((t => {\n        var n = !t.data ? t.error : void 0;\n         true && r({\n          type: n ? \"fetchError\" : \"fetchSuccess\",\n          message: `A ${n ? \"failed\" : \"successful\"} fetch response has been returned.`,\n          operation: e,\n          data: {\n            url: o,\n            fetchOptions: i,\n            value: n || t\n          },\n          source: \"fetchExchange\"\n        });\n      }))(s);\n    }\n    return s;\n  }))((0,wonka__WEBPACK_IMPORTED_MODULE_2__.filter)((e => \"teardown\" !== e.kind && (\"subscription\" !== e.kind || !!e.context.fetchSubscriptions)))(t));\n  var o = e((0,wonka__WEBPACK_IMPORTED_MODULE_2__.filter)((e => \"teardown\" === e.kind || \"subscription\" === e.kind && !e.context.fetchSubscriptions))(t));\n  return (0,wonka__WEBPACK_IMPORTED_MODULE_2__.merge)([ n, o ]);\n};\n\nvar composeExchanges = e => ({client: r, forward: t, dispatchDebug: n}) => e.reduceRight(((e, t) => {\n  var a = !1;\n  return t({\n    client: r,\n    forward(r) {\n      if (true) {\n        if (a) {\n          throw new Error(\"forward() must only be called once in each Exchange.\");\n        }\n        a = !0;\n      }\n      return (0,wonka__WEBPACK_IMPORTED_MODULE_2__.share)(e((0,wonka__WEBPACK_IMPORTED_MODULE_2__.share)(r)));\n    },\n    dispatchDebug(e) {\n       true && n({\n        timestamp: Date.now(),\n        source: t.name,\n        ...e\n      });\n    }\n  });\n}), t);\n\nvar mapExchange = ({onOperation: e, onResult: r, onError: t}) => ({forward: n}) => a => (0,wonka__WEBPACK_IMPORTED_MODULE_2__.mergeMap)((e => {\n  if (t && e.error) {\n    t(e.error, e.operation);\n  }\n  var n = r && r(e) || e;\n  return \"then\" in n ? (0,wonka__WEBPACK_IMPORTED_MODULE_2__.fromPromise)(n) : (0,wonka__WEBPACK_IMPORTED_MODULE_2__.fromValue)(n);\n}))(n((0,wonka__WEBPACK_IMPORTED_MODULE_2__.mergeMap)((r => {\n  var t = e && e(r) || r;\n  return \"then\" in t ? (0,wonka__WEBPACK_IMPORTED_MODULE_2__.fromPromise)(t) : (0,wonka__WEBPACK_IMPORTED_MODULE_2__.fromValue)(t);\n}))(a)));\n\nvar fallbackExchange = ({dispatchDebug: e}) => r => {\n  if (true) {\n    r = (0,wonka__WEBPACK_IMPORTED_MODULE_2__.tap)((r => {\n      if (\"teardown\" !== r.kind && \"production\" !== \"development\") {\n        var t = `No exchange has handled operations of kind \"${r.kind}\". Check whether you've added an exchange responsible for these operations.`;\n         true && e({\n          type: \"fallbackCatch\",\n          message: t,\n          operation: r,\n          source: \"fallbackExchange\"\n        });\n        console.warn(t);\n      }\n    }))(r);\n  }\n  return (0,wonka__WEBPACK_IMPORTED_MODULE_2__.filter)((e => !1))(r);\n};\n\nvar C = function Client(e) {\n  if ( true && !e.url) {\n    throw new Error(\"You are creating an urql-client without a url.\");\n  }\n  var r = 0;\n  var t = new Map;\n  var n = new Map;\n  var a = new Set;\n  var o = [];\n  var i = {\n    url: e.url,\n    fetchSubscriptions: e.fetchSubscriptions,\n    fetchOptions: e.fetchOptions,\n    fetch: e.fetch,\n    preferGetMethod: !!e.preferGetMethod,\n    requestPolicy: e.requestPolicy || \"cache-first\"\n  };\n  var s = (0,wonka__WEBPACK_IMPORTED_MODULE_2__.makeSubject)();\n  function nextOperation(e) {\n    if (\"mutation\" === e.kind || \"teardown\" === e.kind || !a.has(e.key)) {\n      if (\"teardown\" === e.kind) {\n        a.delete(e.key);\n      } else if (\"mutation\" !== e.kind) {\n        a.add(e.key);\n      }\n      s.next(e);\n    }\n  }\n  var c = !1;\n  function dispatchOperation(e) {\n    if (e) {\n      nextOperation(e);\n    }\n    if (!c) {\n      c = !0;\n      while (c && (e = o.shift())) {\n        nextOperation(e);\n      }\n      c = !1;\n    }\n  }\n  var makeResultSource = r => {\n    var i = (0,wonka__WEBPACK_IMPORTED_MODULE_2__.takeUntil)((0,wonka__WEBPACK_IMPORTED_MODULE_2__.filter)((e => \"teardown\" === e.kind && e.key === r.key))(s.source))((0,wonka__WEBPACK_IMPORTED_MODULE_2__.filter)((e => e.operation.kind === r.kind && e.operation.key === r.key && (!e.operation.context._instance || e.operation.context._instance === r.context._instance)))(g));\n    if (\"query\" !== r.kind) {\n      i = (0,wonka__WEBPACK_IMPORTED_MODULE_2__.takeWhile)((e => !!e.hasNext), !0)(i);\n    } else {\n      i = (0,wonka__WEBPACK_IMPORTED_MODULE_2__.switchMap)((e => {\n        var t = (0,wonka__WEBPACK_IMPORTED_MODULE_2__.fromValue)(e);\n        return e.stale || e.hasNext ? t : (0,wonka__WEBPACK_IMPORTED_MODULE_2__.merge)([ t, (0,wonka__WEBPACK_IMPORTED_MODULE_2__.map)((() => {\n          e.stale = !0;\n          return e;\n        }))((0,wonka__WEBPACK_IMPORTED_MODULE_2__.take)(1)((0,wonka__WEBPACK_IMPORTED_MODULE_2__.filter)((e => e.key === r.key))(s.source))) ]);\n      }))(i);\n    }\n    if (\"mutation\" !== r.kind) {\n      i = (0,wonka__WEBPACK_IMPORTED_MODULE_2__.onEnd)((() => {\n        a.delete(r.key);\n        t.delete(r.key);\n        n.delete(r.key);\n        c = !1;\n        for (var e = o.length - 1; e >= 0; e--) {\n          if (o[e].key === r.key) {\n            o.splice(e, 1);\n          }\n        }\n        nextOperation(makeOperation(\"teardown\", r, r.context));\n      }))((0,wonka__WEBPACK_IMPORTED_MODULE_2__.onPush)((e => {\n        if (e.stale) {\n          for (var n of o) {\n            if (n.key === e.operation.key) {\n              a.delete(n.key);\n              break;\n            }\n          }\n        } else if (!e.hasNext) {\n          a.delete(r.key);\n        }\n        t.set(r.key, e);\n      }))(i));\n    } else {\n      i = (0,wonka__WEBPACK_IMPORTED_MODULE_2__.onStart)((() => {\n        nextOperation(r);\n      }))(i);\n    }\n    if (e.maskTypename) {\n      i = (0,wonka__WEBPACK_IMPORTED_MODULE_2__.map)((e => ({\n        ...e,\n        data: maskTypename(e.data, !0)\n      })))(i);\n    }\n    return (0,wonka__WEBPACK_IMPORTED_MODULE_2__.share)(i);\n  };\n  var u = this instanceof Client ? this : Object.create(Client.prototype);\n  var p = Object.assign(u, {\n    suspense: !!e.suspense,\n    operations$: s.source,\n    reexecuteOperation(e) {\n      if (\"teardown\" === e.kind) {\n        dispatchOperation(e);\n      } else if (\"mutation\" === e.kind || n.has(e.key)) {\n        o.push(e);\n        Promise.resolve().then(dispatchOperation);\n      }\n    },\n    createRequestOperation(e, t, n) {\n      if (!n) {\n        n = {};\n      }\n      var a;\n      if ( true && \"teardown\" !== e && (a = (0,_urql_core_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(t.query)) !== e) {\n        throw new Error(`Expected operation of type \"${e}\" but found \"${a}\"`);\n      }\n      return makeOperation(e, t, {\n        _instance: \"mutation\" === e ? r = r + 1 | 0 : void 0,\n        ...i,\n        ...n,\n        requestPolicy: n.requestPolicy || i.requestPolicy,\n        suspense: n.suspense || !1 !== n.suspense && p.suspense\n      });\n    },\n    executeRequestOperation(e) {\n      if (\"mutation\" === e.kind) {\n        return withPromise(makeResultSource(e));\n      }\n      return withPromise((0,wonka__WEBPACK_IMPORTED_MODULE_2__.lazy)((() => {\n        var r = n.get(e.key);\n        if (!r) {\n          n.set(e.key, r = makeResultSource(e));\n        }\n        r = (0,wonka__WEBPACK_IMPORTED_MODULE_2__.onStart)((() => {\n          dispatchOperation(e);\n        }))(r);\n        var a = t.get(e.key);\n        if (\"query\" === e.kind && a && (a.stale || a.hasNext)) {\n          return (0,wonka__WEBPACK_IMPORTED_MODULE_2__.switchMap)(wonka__WEBPACK_IMPORTED_MODULE_2__.fromValue)((0,wonka__WEBPACK_IMPORTED_MODULE_2__.merge)([ r, (0,wonka__WEBPACK_IMPORTED_MODULE_2__.filter)((r => r === t.get(e.key)))((0,wonka__WEBPACK_IMPORTED_MODULE_2__.fromValue)(a)) ]));\n        } else {\n          return r;\n        }\n      })));\n    },\n    executeQuery(e, r) {\n      var t = p.createRequestOperation(\"query\", e, r);\n      return p.executeRequestOperation(t);\n    },\n    executeSubscription(e, r) {\n      var t = p.createRequestOperation(\"subscription\", e, r);\n      return p.executeRequestOperation(t);\n    },\n    executeMutation(e, r) {\n      var t = p.createRequestOperation(\"mutation\", e, r);\n      return p.executeRequestOperation(t);\n    },\n    readQuery(e, r, t) {\n      var n = null;\n      (0,wonka__WEBPACK_IMPORTED_MODULE_2__.subscribe)((e => {\n        n = e;\n      }))(p.query(e, r, t)).unsubscribe();\n      return n;\n    },\n    query: (e, r, t) => p.executeQuery((0,_urql_core_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.h)(e, r), t),\n    subscription: (e, r, t) => p.executeSubscription((0,_urql_core_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.h)(e, r), t),\n    mutation: (e, r, t) => p.executeMutation((0,_urql_core_chunk_mjs__WEBPACK_IMPORTED_MODULE_0__.h)(e, r), t)\n  });\n  var d = noop;\n  if (true) {\n    var {next: l, source: x} = (0,wonka__WEBPACK_IMPORTED_MODULE_2__.makeSubject)();\n    p.subscribeToDebugTarget = e => (0,wonka__WEBPACK_IMPORTED_MODULE_2__.subscribe)(e)(x);\n    d = l;\n  }\n  var w = composeExchanges(e.exchanges);\n  var g = (0,wonka__WEBPACK_IMPORTED_MODULE_2__.share)(w({\n    client: p,\n    dispatchDebug: d,\n    forward: fallbackExchange({\n      dispatchDebug: d\n    })\n  })(s.source));\n  (0,wonka__WEBPACK_IMPORTED_MODULE_2__.publish)(g);\n  return p;\n};\n\nvar j = C;\n\n\n//# sourceMappingURL=urql-core.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHVycWwrY29yZUA0LjAuMTBfZ3JhcGhxbEAxNi4xMS4wL25vZGVfbW9kdWxlcy9AdXJxbC9jb3JlL2Rpc3QvdXJxbC1jb3JlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdEOztBQUVrRjs7QUFFbEU7O0FBRXlQOztBQUV6VDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsdUJBQXVCLHFEQUFDO0FBQ3hCO0FBQ0E7QUFDQSw0QkFBNEIscURBQUM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscURBQUM7QUFDakI7QUFDQSxrQkFBa0IscURBQUM7QUFDbkI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsVUFBVSx1REFBQztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsZ0RBQUMsQ0FBQywyQ0FBQyxJQUFJLDZDQUFDO0FBQ3BDO0FBQ0EsMkJBQTJCLGdEQUFD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O0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlCQUFpQixnREFBQyxDQUFDLDRDQUFDLEVBQUUsNENBQUMsTUFBTSw2Q0FBQyw0QkFBNEIsZ0RBQUM7QUFDM0QsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNLGdEQUFDO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0wsdUNBQXVDLHVEQUFDO0FBQ3hDLHFEQUFxRCx1REFBQztBQUN0RCw2Q0FBNkMsdURBQUM7QUFDOUMsR0FBRztBQUNIO0FBQ0EsTUFBTSxJQUFxQztBQUMzQyxTQUFTLG9CQUFvQixFQUFFLGtEQUFDO0FBQ2hDLG9DQUFvQyxnREFBQztBQUNyQztBQUNBO0FBQ0E7QUFDQSxVQUFVLDRDQUFDO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILEVBQUUsOENBQUM7QUFDSDtBQUNBOztBQUVBOztBQUVzWDtBQUN0WCIsInNvdXJjZXMiOlsiL2hvbWUvbWljaGFlbC9zYWxlb3ItcGxhdGZvcm0vc2FsZW9yLWFwcHMvbm9kZV9tb2R1bGVzLy5wbnBtL0B1cnFsK2NvcmVANC4wLjEwX2dyYXBocWxAMTYuMTEuMC9ub2RlX21vZHVsZXMvQHVycWwvY29yZS9kaXN0L3VycWwtY29yZS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgS2luZCBhcyBlIH0gZnJvbSBcIkAwbm8tY28vZ3JhcGhxbC53ZWJcIjtcblxuaW1wb3J0IHsgayBhcyByLCBzIGFzIHQsIEMgYXMgbiwgbSBhcyBhLCBhIGFzIG8sIGIgYXMgcywgYywgZCBhcyB1LCBlIGFzIHAsIGYgYXMgZCwgZyBhcyBmLCBoIGFzIHYgfSBmcm9tIFwiLi91cnFsLWNvcmUtY2h1bmsubWpzXCI7XG5cbmV4cG9ydCB7IGkgYXMgc3RyaW5naWZ5VmFyaWFibGVzIH0gZnJvbSBcIi4vdXJxbC1jb3JlLWNodW5rLm1qc1wiO1xuXG5pbXBvcnQgeyB0b1Byb21pc2UgYXMgbCwgdGFrZSBhcyBoLCBmaWx0ZXIgYXMgeSwgc3Vic2NyaWJlIGFzIGssIG1hcCBhcyBtLCB0YXAgYXMgeCwgbWVyZ2UgYXMgRSwgbWVyZ2VNYXAgYXMgdywgdGFrZVVudGlsIGFzIE8sIG1ha2UgYXMgZywgb25QdXNoIGFzIE4sIHNoYXJlIGFzIGIsIGZyb21Qcm9taXNlIGFzIF8sIGZyb21WYWx1ZSBhcyBxLCBtYWtlU3ViamVjdCBhcyBELCBsYXp5IGFzIFMsIG9uU3RhcnQgYXMgUCwgc3dpdGNoTWFwIGFzIFYsIHB1Ymxpc2ggYXMgUiwgdGFrZVdoaWxlIGFzIEEsIG9uRW5kIGFzIE0gfSBmcm9tIFwid29ua2FcIjtcblxudmFyIGNvbGxlY3RUeXBlcyA9IChlLCByKSA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgZm9yICh2YXIgdCBvZiBlKSB7XG4gICAgICBjb2xsZWN0VHlwZXModCwgcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKFwib2JqZWN0XCIgPT0gdHlwZW9mIGUgJiYgbnVsbCAhPT0gZSkge1xuICAgIGZvciAodmFyIG4gaW4gZSkge1xuICAgICAgaWYgKFwiX190eXBlbmFtZVwiID09PSBuICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIGVbbl0pIHtcbiAgICAgICAgci5hZGQoZVtuXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2xsZWN0VHlwZXMoZVtuXSwgcik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByO1xufTtcblxudmFyIGZvcm1hdE5vZGUgPSByID0+IHtcbiAgdmFyIHQgPSAhMTtcbiAgaWYgKFwiZGVmaW5pdGlvbnNcIiBpbiByKSB7XG4gICAgdmFyIG4gPSBbXTtcbiAgICBmb3IgKHZhciBhIG9mIHIuZGVmaW5pdGlvbnMpIHtcbiAgICAgIHZhciBvID0gZm9ybWF0Tm9kZShhKTtcbiAgICAgIHQgPSB0IHx8IG8gIT09IGE7XG4gICAgICBuLnB1c2gobyk7XG4gICAgfVxuICAgIGlmICh0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5yLFxuICAgICAgICBkZWZpbml0aW9uczogblxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoXCJzZWxlY3Rpb25TZXRcIiBpbiByKSB7XG4gICAgdmFyIGkgPSBbXTtcbiAgICB2YXIgcyA9IHIua2luZCA9PT0gZS5PUEVSQVRJT05fREVGSU5JVElPTjtcbiAgICBpZiAoci5zZWxlY3Rpb25TZXQpIHtcbiAgICAgIGZvciAodmFyIGMgb2Ygci5zZWxlY3Rpb25TZXQuc2VsZWN0aW9ucyB8fCBbXSkge1xuICAgICAgICBzID0gcyB8fCBjLmtpbmQgPT09IGUuRklFTEQgJiYgXCJfX3R5cGVuYW1lXCIgPT09IGMubmFtZS52YWx1ZSAmJiAhYy5hbGlhcztcbiAgICAgICAgdmFyIHUgPSBmb3JtYXROb2RlKGMpO1xuICAgICAgICB0ID0gdCB8fCB1ICE9PSBjO1xuICAgICAgICBpLnB1c2godSk7XG4gICAgICB9XG4gICAgICBpZiAoIXMpIHtcbiAgICAgICAgdCA9ICEwO1xuICAgICAgICBpLnB1c2goe1xuICAgICAgICAgIGtpbmQ6IGUuRklFTEQsXG4gICAgICAgICAgbmFtZToge1xuICAgICAgICAgICAga2luZDogZS5OQU1FLFxuICAgICAgICAgICAgdmFsdWU6IFwiX190eXBlbmFtZVwiXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4ucixcbiAgICAgICAgICBzZWxlY3Rpb25TZXQ6IHtcbiAgICAgICAgICAgIC4uLnIuc2VsZWN0aW9uU2V0LFxuICAgICAgICAgICAgc2VsZWN0aW9uczogaVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHI7XG59O1xuXG52YXIgSSA9IG5ldyBNYXA7XG5cbnZhciBmb3JtYXREb2N1bWVudCA9IGUgPT4ge1xuICB2YXIgdCA9IHIoZSk7XG4gIHZhciBuID0gSS5nZXQodC5fX2tleSk7XG4gIGlmICghbikge1xuICAgIEkuc2V0KHQuX19rZXksIG4gPSBmb3JtYXROb2RlKHQpKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgXCJfX2tleVwiLCB7XG4gICAgICB2YWx1ZTogdC5fX2tleSxcbiAgICAgIGVudW1lcmFibGU6ICExXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG47XG59O1xuXG52YXIgbWFza1R5cGVuYW1lID0gKGUsIHIpID0+IHtcbiAgaWYgKCFlIHx8IFwib2JqZWN0XCIgIT0gdHlwZW9mIGUpIHtcbiAgICByZXR1cm4gZTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgcmV0dXJuIGUubWFwKChlID0+IG1hc2tUeXBlbmFtZShlKSkpO1xuICB9IGVsc2UgaWYgKGUgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgZSAmJiAociB8fCBcIl9fdHlwZW5hbWVcIiBpbiBlKSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgbiBpbiBlKSB7XG4gICAgICBpZiAoXCJfX3R5cGVuYW1lXCIgPT09IG4pIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX190eXBlbmFtZVwiLCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgdmFsdWU6IGUuX190eXBlbmFtZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRbbl0gPSBtYXNrVHlwZW5hbWUoZVtuXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBlO1xuICB9XG59O1xuXG5mdW5jdGlvbiB3aXRoUHJvbWlzZShlKSB7XG4gIHZhciBzb3VyY2UkID0gciA9PiBlKHIpO1xuICBzb3VyY2UkLnRvUHJvbWlzZSA9ICgpID0+IGwoaCgxKSh5KChlID0+ICFlLnN0YWxlICYmICFlLmhhc05leHQpKShzb3VyY2UkKSkpO1xuICBzb3VyY2UkLnRoZW4gPSAoZSwgcikgPT4gc291cmNlJC50b1Byb21pc2UoKS50aGVuKGUsIHIpO1xuICBzb3VyY2UkLnN1YnNjcmliZSA9IGUgPT4gayhlKShzb3VyY2UkKTtcbiAgcmV0dXJuIHNvdXJjZSQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VPcGVyYXRpb24oZSwgciwgdCkge1xuICByZXR1cm4ge1xuICAgIC4uLnIsXG4gICAga2luZDogZSxcbiAgICBjb250ZXh0OiByLmNvbnRleHQgPyB7XG4gICAgICAuLi5yLmNvbnRleHQsXG4gICAgICAuLi50XG4gICAgfSA6IHQgfHwgci5jb250ZXh0XG4gIH07XG59XG5cbnZhciBhZGRNZXRhZGF0YSA9IChlLCByKSA9PiBtYWtlT3BlcmF0aW9uKGUua2luZCwgZSwge1xuICBtZXRhOiB7XG4gICAgLi4uZS5jb250ZXh0Lm1ldGEsXG4gICAgLi4uclxuICB9XG59KTtcblxudmFyIG5vb3AgPSAoKSA9PiB7fTtcblxuZnVuY3Rpb24gZ3FsKG4pIHtcbiAgdmFyIGEgPSBuZXcgTWFwO1xuICB2YXIgbyA9IFtdO1xuICB2YXIgaSA9IFtdO1xuICB2YXIgcyA9IEFycmF5LmlzQXJyYXkobikgPyBuWzBdIDogbiB8fCBcIlwiO1xuICBmb3IgKHZhciBjID0gMTsgYyA8IGFyZ3VtZW50cy5sZW5ndGg7IGMrKykge1xuICAgIHZhciB1ID0gYXJndW1lbnRzW2NdO1xuICAgIGlmICh1ICYmIHUuZGVmaW5pdGlvbnMpIHtcbiAgICAgIGkucHVzaCh1KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcyArPSB1O1xuICAgIH1cbiAgICBzICs9IGFyZ3VtZW50c1swXVtjXTtcbiAgfVxuICBpLnVuc2hpZnQocihzKSk7XG4gIGZvciAodmFyIHAgb2YgaSkge1xuICAgIGZvciAodmFyIGQgb2YgcC5kZWZpbml0aW9ucykge1xuICAgICAgaWYgKGQua2luZCA9PT0gZS5GUkFHTUVOVF9ERUZJTklUSU9OKSB7XG4gICAgICAgIHZhciBmID0gZC5uYW1lLnZhbHVlO1xuICAgICAgICB2YXIgdiA9IHQoZCk7XG4gICAgICAgIGlmICghYS5oYXMoZikpIHtcbiAgICAgICAgICBhLnNldChmLCB2KTtcbiAgICAgICAgICBvLnB1c2goZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmIGEuZ2V0KGYpICE9PSB2KSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiW1dBUk5JTkc6IER1cGxpY2F0ZSBGcmFnbWVudF0gQSBmcmFnbWVudCB3aXRoIG5hbWUgYFwiICsgZiArIFwiYCBhbHJlYWR5IGV4aXN0cyBpbiB0aGlzIGRvY3VtZW50LlxcbldoaWxlIGZyYWdtZW50IG5hbWVzIG1heSBub3QgYmUgdW5pcXVlIGFjcm9zcyB5b3VyIHNvdXJjZSwgZWFjaCBuYW1lIG11c3QgYmUgdW5pcXVlIHBlciBkb2N1bWVudC5cIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG8ucHVzaChkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHIoe1xuICAgIGtpbmQ6IGUuRE9DVU1FTlQsXG4gICAgZGVmaW5pdGlvbnM6IG9cbiAgfSk7XG59XG5cbnZhciBzaG91bGRTa2lwID0gKHtraW5kOiBlfSkgPT4gXCJtdXRhdGlvblwiICE9PSBlICYmIFwicXVlcnlcIiAhPT0gZTtcblxudmFyIGNhY2hlRXhjaGFuZ2UgPSAoe2ZvcndhcmQ6IGUsIGNsaWVudDogciwgZGlzcGF0Y2hEZWJ1ZzogdH0pID0+IHtcbiAgdmFyIG4gPSBuZXcgTWFwO1xuICB2YXIgYSA9IG5ldyBNYXA7XG4gIHZhciBtYXBUeXBlTmFtZXMgPSBlID0+IHtcbiAgICB2YXIgciA9IG1ha2VPcGVyYXRpb24oZS5raW5kLCBlKTtcbiAgICByLnF1ZXJ5ID0gZm9ybWF0RG9jdW1lbnQoZS5xdWVyeSk7XG4gICAgcmV0dXJuIHI7XG4gIH07XG4gIHZhciBpc09wZXJhdGlvbkNhY2hlZCA9IGUgPT4gXCJxdWVyeVwiID09PSBlLmtpbmQgJiYgXCJuZXR3b3JrLW9ubHlcIiAhPT0gZS5jb250ZXh0LnJlcXVlc3RQb2xpY3kgJiYgKFwiY2FjaGUtb25seVwiID09PSBlLmNvbnRleHQucmVxdWVzdFBvbGljeSB8fCBuLmhhcyhlLmtleSkpO1xuICByZXR1cm4gbyA9PiB7XG4gICAgdmFyIGkgPSBtKChlID0+IHtcbiAgICAgIHZhciBhID0gbi5nZXQoZS5rZXkpO1xuICAgICAgXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmIHQoe1xuICAgICAgICBvcGVyYXRpb246IGUsXG4gICAgICAgIC4uLmEgPyB7XG4gICAgICAgICAgdHlwZTogXCJjYWNoZUhpdFwiLFxuICAgICAgICAgIG1lc3NhZ2U6IFwiVGhlIHJlc3VsdCB3YXMgc3VjY2Vzc2Z1bGx5IHJldHJpZWQgZnJvbSB0aGUgY2FjaGVcIlxuICAgICAgICB9IDoge1xuICAgICAgICAgIHR5cGU6IFwiY2FjaGVNaXNzXCIsXG4gICAgICAgICAgbWVzc2FnZTogXCJUaGUgcmVzdWx0IGNvdWxkIG5vdCBiZSByZXRyaWV2ZWQgZnJvbSB0aGUgY2FjaGVcIlxuICAgICAgICB9LFxuICAgICAgICBzb3VyY2U6IFwiY2FjaGVFeGNoYW5nZVwiXG4gICAgICB9KTtcbiAgICAgIHZhciBvID0gYTtcbiAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgICAgbyA9IHtcbiAgICAgICAgICAuLi5vLFxuICAgICAgICAgIG9wZXJhdGlvbjogXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gYWRkTWV0YWRhdGEoZSwge1xuICAgICAgICAgICAgY2FjaGVPdXRjb21lOiBhID8gXCJoaXRcIiA6IFwibWlzc1wiXG4gICAgICAgICAgfSkgOiBlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoXCJjYWNoZS1hbmQtbmV0d29ya1wiID09PSBlLmNvbnRleHQucmVxdWVzdFBvbGljeSkge1xuICAgICAgICBvLnN0YWxlID0gITA7XG4gICAgICAgIHJlZXhlY3V0ZU9wZXJhdGlvbihyLCBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvO1xuICAgIH0pKSh5KChlID0+ICFzaG91bGRTa2lwKGUpICYmIGlzT3BlcmF0aW9uQ2FjaGVkKGUpKSkobykpO1xuICAgIHZhciBzID0geCgoZSA9PiB7XG4gICAgICB2YXIge29wZXJhdGlvbjogb30gPSBlO1xuICAgICAgaWYgKCFvKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpID0gby5jb250ZXh0LmFkZGl0aW9uYWxUeXBlbmFtZXMgfHwgW107XG4gICAgICBpZiAoXCJzdWJzY3JpcHRpb25cIiAhPT0gZS5vcGVyYXRpb24ua2luZCkge1xuICAgICAgICBpID0gKGUgPT4gWyAuLi5jb2xsZWN0VHlwZXMoZSwgbmV3IFNldCkgXSkoZS5kYXRhKS5jb25jYXQoaSk7XG4gICAgICB9XG4gICAgICBpZiAoXCJtdXRhdGlvblwiID09PSBlLm9wZXJhdGlvbi5raW5kIHx8IFwic3Vic2NyaXB0aW9uXCIgPT09IGUub3BlcmF0aW9uLmtpbmQpIHtcbiAgICAgICAgdmFyIHMgPSBuZXcgU2V0O1xuICAgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiYgdCh7XG4gICAgICAgICAgdHlwZTogXCJjYWNoZUludmFsaWRhdGlvblwiLFxuICAgICAgICAgIG1lc3NhZ2U6IGBUaGUgZm9sbG93aW5nIHR5cGVuYW1lcyBoYXZlIGJlZW4gaW52YWxpZGF0ZWQ6ICR7aX1gLFxuICAgICAgICAgIG9wZXJhdGlvbjogbyxcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICB0eXBlbmFtZXM6IGksXG4gICAgICAgICAgICByZXNwb25zZTogZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc291cmNlOiBcImNhY2hlRXhjaGFuZ2VcIlxuICAgICAgICB9KTtcbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBpLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgdmFyIHUgPSBpW2NdO1xuICAgICAgICAgIHZhciBwID0gYS5nZXQodSk7XG4gICAgICAgICAgaWYgKCFwKSB7XG4gICAgICAgICAgICBhLnNldCh1LCBwID0gbmV3IFNldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGQgb2YgcC52YWx1ZXMoKSkge1xuICAgICAgICAgICAgcy5hZGQoZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHAuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBmIG9mIHMudmFsdWVzKCkpIHtcbiAgICAgICAgICBpZiAobi5oYXMoZikpIHtcbiAgICAgICAgICAgIG8gPSBuLmdldChmKS5vcGVyYXRpb247XG4gICAgICAgICAgICBuLmRlbGV0ZShmKTtcbiAgICAgICAgICAgIHJlZXhlY3V0ZU9wZXJhdGlvbihyLCBvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoXCJxdWVyeVwiID09PSBvLmtpbmQgJiYgZS5kYXRhKSB7XG4gICAgICAgIG4uc2V0KG8ua2V5LCBlKTtcbiAgICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBpLmxlbmd0aDsgdisrKSB7XG4gICAgICAgICAgdmFyIGwgPSBpW3ZdO1xuICAgICAgICAgIHZhciBoID0gYS5nZXQobCk7XG4gICAgICAgICAgaWYgKCFoKSB7XG4gICAgICAgICAgICBhLnNldChsLCBoID0gbmV3IFNldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGguYWRkKG8ua2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKShlKHkoKGUgPT4gXCJxdWVyeVwiICE9PSBlLmtpbmQgfHwgXCJjYWNoZS1vbmx5XCIgIT09IGUuY29udGV4dC5yZXF1ZXN0UG9saWN5KSkobSgoZSA9PiBcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBhZGRNZXRhZGF0YShlLCB7XG4gICAgICBjYWNoZU91dGNvbWU6IFwibWlzc1wiXG4gICAgfSkgOiBlKSkoRShbIG0obWFwVHlwZU5hbWVzKSh5KChlID0+ICFzaG91bGRTa2lwKGUpICYmICFpc09wZXJhdGlvbkNhY2hlZChlKSkpKG8pKSwgeSgoZSA9PiBzaG91bGRTa2lwKGUpKSkobykgXSkpKSkpO1xuICAgIHJldHVybiBFKFsgaSwgcyBdKTtcbiAgfTtcbn07XG5cbnZhciByZWV4ZWN1dGVPcGVyYXRpb24gPSAoZSwgcikgPT4gZS5yZWV4ZWN1dGVPcGVyYXRpb24obWFrZU9wZXJhdGlvbihyLmtpbmQsIHIsIHtcbiAgcmVxdWVzdFBvbGljeTogXCJuZXR3b3JrLW9ubHlcIlxufSkpO1xuXG52YXIgVCA9IG5ldyBTZXQ7XG5cbnZhciBzc3JFeGNoYW5nZSA9IChlID0ge30pID0+IHtcbiAgdmFyIHIgPSAhIWUuc3RhbGVXaGlsZVJldmFsaWRhdGU7XG4gIHZhciB0ID0gISFlLmluY2x1ZGVFeHRlbnNpb25zO1xuICB2YXIgYSA9IHt9O1xuICB2YXIgbyA9IFtdO1xuICB2YXIgaW52YWxpZGF0ZSA9IGUgPT4ge1xuICAgIG8ucHVzaChlLm9wZXJhdGlvbi5rZXkpO1xuICAgIGlmICgxID09PSBvLmxlbmd0aCkge1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKCkgPT4ge1xuICAgICAgICB2YXIgZTtcbiAgICAgICAgd2hpbGUgKGUgPSBvLnNoaWZ0KCkpIHtcbiAgICAgICAgICBhW2VdID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH1cbiAgfTtcbiAgdmFyIHNzciA9ICh7Y2xpZW50OiBvLCBmb3J3YXJkOiBpfSkgPT4gcyA9PiB7XG4gICAgdmFyIGMgPSBlICYmIFwiYm9vbGVhblwiID09IHR5cGVvZiBlLmlzQ2xpZW50ID8gISFlLmlzQ2xpZW50IDogIW8uc3VzcGVuc2U7XG4gICAgdmFyIHUgPSBpKHkoKGUgPT4gIWFbZS5rZXldIHx8ICEhYVtlLmtleV0uaGFzTmV4dCB8fCBcIm5ldHdvcmstb25seVwiID09PSBlLmNvbnRleHQucmVxdWVzdFBvbGljeSkpKHMpKTtcbiAgICB2YXIgcCA9IG0oKGUgPT4ge1xuICAgICAgdmFyIGkgPSAoKGUsIHIsIHQpID0+ICh7XG4gICAgICAgIG9wZXJhdGlvbjogZSxcbiAgICAgICAgZGF0YTogci5kYXRhID8gSlNPTi5wYXJzZShyLmRhdGEpIDogdm9pZCAwLFxuICAgICAgICBleHRlbnNpb25zOiB0ICYmIHIuZXh0ZW5zaW9ucyA/IEpTT04ucGFyc2Uoci5leHRlbnNpb25zKSA6IHZvaWQgMCxcbiAgICAgICAgZXJyb3I6IHIuZXJyb3IgPyBuZXcgbih7XG4gICAgICAgICAgbmV0d29ya0Vycm9yOiByLmVycm9yLm5ldHdvcmtFcnJvciA/IG5ldyBFcnJvcihyLmVycm9yLm5ldHdvcmtFcnJvcikgOiB2b2lkIDAsXG4gICAgICAgICAgZ3JhcGhRTEVycm9yczogci5lcnJvci5ncmFwaFFMRXJyb3JzXG4gICAgICAgIH0pIDogdm9pZCAwLFxuICAgICAgICBzdGFsZTogITEsXG4gICAgICAgIGhhc05leHQ6ICEhci5oYXNOZXh0XG4gICAgICB9KSkoZSwgYVtlLmtleV0sIHQpO1xuICAgICAgaWYgKHIgJiYgIVQuaGFzKGUua2V5KSkge1xuICAgICAgICBpLnN0YWxlID0gITA7XG4gICAgICAgIFQuYWRkKGUua2V5KTtcbiAgICAgICAgcmVleGVjdXRlT3BlcmF0aW9uKG8sIGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uaSxcbiAgICAgICAgb3BlcmF0aW9uOiBcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBhZGRNZXRhZGF0YShlLCB7XG4gICAgICAgICAgY2FjaGVPdXRjb21lOiBcImhpdFwiXG4gICAgICAgIH0pIDogZVxuICAgICAgfTtcbiAgICB9KSkoeSgoZSA9PiAhIWFbZS5rZXldICYmIFwibmV0d29yay1vbmx5XCIgIT09IGUuY29udGV4dC5yZXF1ZXN0UG9saWN5KSkocykpO1xuICAgIGlmICghYykge1xuICAgICAgdSA9IHgoKGUgPT4ge1xuICAgICAgICB2YXIge29wZXJhdGlvbjogcn0gPSBlO1xuICAgICAgICBpZiAoXCJtdXRhdGlvblwiICE9PSByLmtpbmQpIHtcbiAgICAgICAgICB2YXIgbiA9ICgoZSwgcikgPT4ge1xuICAgICAgICAgICAgdmFyIHQgPSB7XG4gICAgICAgICAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KGUuZGF0YSksXG4gICAgICAgICAgICAgIGhhc05leHQ6IGUuaGFzTmV4dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGUuZGF0YSkge1xuICAgICAgICAgICAgICB0LmRhdGEgPSBKU09OLnN0cmluZ2lmeShlLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHIgJiYgdm9pZCAwICE9PSBlLmV4dGVuc2lvbnMpIHtcbiAgICAgICAgICAgICAgdC5leHRlbnNpb25zID0gSlNPTi5zdHJpbmdpZnkoZS5leHRlbnNpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlLmVycm9yKSB7XG4gICAgICAgICAgICAgIHQuZXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgZ3JhcGhRTEVycm9yczogZS5lcnJvci5ncmFwaFFMRXJyb3JzLm1hcCgoZSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWUucGF0aCAmJiAhZS5leHRlbnNpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGUucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uczogZS5leHRlbnNpb25zXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBpZiAoZS5lcnJvci5uZXR3b3JrRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0LmVycm9yLm5ldHdvcmtFcnJvciA9IFwiXCIgKyBlLmVycm9yLm5ldHdvcmtFcnJvcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgfSkoZSwgdCk7XG4gICAgICAgICAgYVtyLmtleV0gPSBuO1xuICAgICAgICB9XG4gICAgICB9KSkodSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHAgPSB4KGludmFsaWRhdGUpKHApO1xuICAgIH1cbiAgICByZXR1cm4gRShbIHUsIHAgXSk7XG4gIH07XG4gIHNzci5yZXN0b3JlRGF0YSA9IGUgPT4ge1xuICAgIGZvciAodmFyIHIgaW4gZSkge1xuICAgICAgaWYgKG51bGwgIT09IGFbcl0pIHtcbiAgICAgICAgYVtyXSA9IGVbcl07XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzc3IuZXh0cmFjdERhdGEgPSAoKSA9PiB7XG4gICAgdmFyIGUgPSB7fTtcbiAgICBmb3IgKHZhciByIGluIGEpIHtcbiAgICAgIGlmIChudWxsICE9IGFbcl0pIHtcbiAgICAgICAgZVtyXSA9IGFbcl07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9O1xuICBpZiAoZSAmJiBlLmluaXRpYWxTdGF0ZSkge1xuICAgIHNzci5yZXN0b3JlRGF0YShlLmluaXRpYWxTdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHNzcjtcbn07XG5cbnZhciBzdWJzY3JpcHRpb25FeGNoYW5nZSA9ICh7Zm9yd2FyZFN1YnNjcmlwdGlvbjogZSwgZW5hYmxlQWxsT3BlcmF0aW9uczogciwgaXNTdWJzY3JpcHRpb25PcGVyYXRpb246IHR9KSA9PiAoe2NsaWVudDogbiwgZm9yd2FyZDogaX0pID0+IHtcbiAgdmFyIHUgPSB0IHx8IChlID0+IFwic3Vic2NyaXB0aW9uXCIgPT09IGUua2luZCB8fCAhIXIgJiYgKFwicXVlcnlcIiA9PT0gZS5raW5kIHx8IFwibXV0YXRpb25cIiA9PT0gZS5raW5kKSk7XG4gIHJldHVybiByID0+IHtcbiAgICB2YXIgdCA9IHcoKHQgPT4ge1xuICAgICAgdmFyIHtrZXk6IGl9ID0gdDtcbiAgICAgIHZhciB1ID0geSgoZSA9PiBcInRlYXJkb3duXCIgPT09IGUua2luZCAmJiBlLmtleSA9PT0gaSkpKHIpO1xuICAgICAgcmV0dXJuIE8odSkoKHIgPT4ge1xuICAgICAgICB2YXIgdCA9IGUoYShyKSwgcik7XG4gICAgICAgIHJldHVybiBnKCgoe25leHQ6IGUsIGNvbXBsZXRlOiBhfSkgPT4ge1xuICAgICAgICAgIHZhciBpID0gITE7XG4gICAgICAgICAgdmFyIHU7XG4gICAgICAgICAgdmFyIHA7XG4gICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdSA9IHQuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgICAgbmV4dCh0KSB7XG4gICAgICAgICAgICAgICAgZShwID0gcCA/IG8ocCwgdCkgOiBzKHIsIHQpKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZXJyb3IodCkge1xuICAgICAgICAgICAgICAgIGUoYyhyLCB0KSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGNvbXBsZXRlKCkge1xuICAgICAgICAgICAgICAgIGlmICghaSkge1xuICAgICAgICAgICAgICAgICAgaSA9ICEwO1xuICAgICAgICAgICAgICAgICAgaWYgKFwic3Vic2NyaXB0aW9uXCIgPT09IHIua2luZCkge1xuICAgICAgICAgICAgICAgICAgICBuLnJlZXhlY3V0ZU9wZXJhdGlvbihtYWtlT3BlcmF0aW9uKFwidGVhcmRvd25cIiwgciwgci5jb250ZXh0KSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAocCAmJiBwLmhhc05leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZShvKHAsIHtcbiAgICAgICAgICAgICAgICAgICAgICBoYXNOZXh0OiAhMVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBhKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGkgPSAhMDtcbiAgICAgICAgICAgIGlmICh1KSB7XG4gICAgICAgICAgICAgIHUudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9KSk7XG4gICAgICB9KSh0KSk7XG4gICAgfSkpKHkoKGUgPT4gXCJ0ZWFyZG93blwiICE9PSBlLmtpbmQgJiYgdShlKSkpKHIpKTtcbiAgICB2YXIgcCA9IGkoeSgoZSA9PiBcInRlYXJkb3duXCIgPT09IGUua2luZCB8fCAhdShlKSkpKHIpKTtcbiAgICByZXR1cm4gRShbIHQsIHAgXSk7XG4gIH07XG59O1xuXG52YXIgZGVidWdFeGNoYW5nZSA9ICh7Zm9yd2FyZDogZX0pID0+IHtcbiAgaWYgKFwicHJvZHVjdGlvblwiID09PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIHJldHVybiByID0+IGUocik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHIgPT4geCgoZSA9PiBjb25zb2xlLmxvZyhcIltFeGNoYW5nZSBkZWJ1Z106IENvbXBsZXRlZCBvcGVyYXRpb246IFwiLCBlKSkpKGUoeCgoZSA9PiBjb25zb2xlLmxvZyhcIltFeGNoYW5nZSBkZWJ1Z106IEluY29taW5nIG9wZXJhdGlvbjogXCIsIGUpKSkocikpKTtcbiAgfVxufTtcblxudmFyIGRlZHVwRXhjaGFuZ2UgPSAoe2ZvcndhcmQ6IGV9KSA9PiByID0+IGUocik7XG5cbnZhciBmZXRjaEV4Y2hhbmdlID0gKHtmb3J3YXJkOiBlLCBkaXNwYXRjaERlYnVnOiByfSkgPT4gdCA9PiB7XG4gIHZhciBuID0gdygoZSA9PiB7XG4gICAgdmFyIG4gPSBhKGUpO1xuICAgIHZhciBvID0gdShlLCBuKTtcbiAgICB2YXIgaSA9IHAoZSwgbik7XG4gICAgXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmIHIoe1xuICAgICAgdHlwZTogXCJmZXRjaFJlcXVlc3RcIixcbiAgICAgIG1lc3NhZ2U6IFwiQSBmZXRjaCByZXF1ZXN0IGlzIGJlaW5nIGV4ZWN1dGVkLlwiLFxuICAgICAgb3BlcmF0aW9uOiBlLFxuICAgICAgZGF0YToge1xuICAgICAgICB1cmw6IG8sXG4gICAgICAgIGZldGNoT3B0aW9uczogaVxuICAgICAgfSxcbiAgICAgIHNvdXJjZTogXCJmZXRjaEV4Y2hhbmdlXCJcbiAgICB9KTtcbiAgICB2YXIgcyA9IE8oeSgociA9PiBcInRlYXJkb3duXCIgPT09IHIua2luZCAmJiByLmtleSA9PT0gZS5rZXkpKSh0KSkoZChlLCBvLCBpKSk7XG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgcmV0dXJuIE4oKHQgPT4ge1xuICAgICAgICB2YXIgbiA9ICF0LmRhdGEgPyB0LmVycm9yIDogdm9pZCAwO1xuICAgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiYgcih7XG4gICAgICAgICAgdHlwZTogbiA/IFwiZmV0Y2hFcnJvclwiIDogXCJmZXRjaFN1Y2Nlc3NcIixcbiAgICAgICAgICBtZXNzYWdlOiBgQSAke24gPyBcImZhaWxlZFwiIDogXCJzdWNjZXNzZnVsXCJ9IGZldGNoIHJlc3BvbnNlIGhhcyBiZWVuIHJldHVybmVkLmAsXG4gICAgICAgICAgb3BlcmF0aW9uOiBlLFxuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHVybDogbyxcbiAgICAgICAgICAgIGZldGNoT3B0aW9uczogaSxcbiAgICAgICAgICAgIHZhbHVlOiBuIHx8IHRcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNvdXJjZTogXCJmZXRjaEV4Y2hhbmdlXCJcbiAgICAgICAgfSk7XG4gICAgICB9KSkocyk7XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9KSkoeSgoZSA9PiBcInRlYXJkb3duXCIgIT09IGUua2luZCAmJiAoXCJzdWJzY3JpcHRpb25cIiAhPT0gZS5raW5kIHx8ICEhZS5jb250ZXh0LmZldGNoU3Vic2NyaXB0aW9ucykpKSh0KSk7XG4gIHZhciBvID0gZSh5KChlID0+IFwidGVhcmRvd25cIiA9PT0gZS5raW5kIHx8IFwic3Vic2NyaXB0aW9uXCIgPT09IGUua2luZCAmJiAhZS5jb250ZXh0LmZldGNoU3Vic2NyaXB0aW9ucykpKHQpKTtcbiAgcmV0dXJuIEUoWyBuLCBvIF0pO1xufTtcblxudmFyIGNvbXBvc2VFeGNoYW5nZXMgPSBlID0+ICh7Y2xpZW50OiByLCBmb3J3YXJkOiB0LCBkaXNwYXRjaERlYnVnOiBufSkgPT4gZS5yZWR1Y2VSaWdodCgoKGUsIHQpID0+IHtcbiAgdmFyIGEgPSAhMTtcbiAgcmV0dXJuIHQoe1xuICAgIGNsaWVudDogcixcbiAgICBmb3J3YXJkKHIpIHtcbiAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgICAgaWYgKGEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmb3J3YXJkKCkgbXVzdCBvbmx5IGJlIGNhbGxlZCBvbmNlIGluIGVhY2ggRXhjaGFuZ2UuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGEgPSAhMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiKGUoYihyKSkpO1xuICAgIH0sXG4gICAgZGlzcGF0Y2hEZWJ1ZyhlKSB7XG4gICAgICBcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiYgbih7XG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgc291cmNlOiB0Lm5hbWUsXG4gICAgICAgIC4uLmVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59KSwgdCk7XG5cbnZhciBtYXBFeGNoYW5nZSA9ICh7b25PcGVyYXRpb246IGUsIG9uUmVzdWx0OiByLCBvbkVycm9yOiB0fSkgPT4gKHtmb3J3YXJkOiBufSkgPT4gYSA9PiB3KChlID0+IHtcbiAgaWYgKHQgJiYgZS5lcnJvcikge1xuICAgIHQoZS5lcnJvciwgZS5vcGVyYXRpb24pO1xuICB9XG4gIHZhciBuID0gciAmJiByKGUpIHx8IGU7XG4gIHJldHVybiBcInRoZW5cIiBpbiBuID8gXyhuKSA6IHEobik7XG59KSkobih3KChyID0+IHtcbiAgdmFyIHQgPSBlICYmIGUocikgfHwgcjtcbiAgcmV0dXJuIFwidGhlblwiIGluIHQgPyBfKHQpIDogcSh0KTtcbn0pKShhKSkpO1xuXG52YXIgZmFsbGJhY2tFeGNoYW5nZSA9ICh7ZGlzcGF0Y2hEZWJ1ZzogZX0pID0+IHIgPT4ge1xuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgciA9IHgoKHIgPT4ge1xuICAgICAgaWYgKFwidGVhcmRvd25cIiAhPT0gci5raW5kICYmIFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICB2YXIgdCA9IGBObyBleGNoYW5nZSBoYXMgaGFuZGxlZCBvcGVyYXRpb25zIG9mIGtpbmQgXCIke3Iua2luZH1cIi4gQ2hlY2sgd2hldGhlciB5b3UndmUgYWRkZWQgYW4gZXhjaGFuZ2UgcmVzcG9uc2libGUgZm9yIHRoZXNlIG9wZXJhdGlvbnMuYDtcbiAgICAgICAgXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmIGUoe1xuICAgICAgICAgIHR5cGU6IFwiZmFsbGJhY2tDYXRjaFwiLFxuICAgICAgICAgIG1lc3NhZ2U6IHQsXG4gICAgICAgICAgb3BlcmF0aW9uOiByLFxuICAgICAgICAgIHNvdXJjZTogXCJmYWxsYmFja0V4Y2hhbmdlXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnNvbGUud2Fybih0KTtcbiAgICAgIH1cbiAgICB9KSkocik7XG4gIH1cbiAgcmV0dXJuIHkoKGUgPT4gITEpKShyKTtcbn07XG5cbnZhciBDID0gZnVuY3Rpb24gQ2xpZW50KGUpIHtcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJiAhZS51cmwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgYXJlIGNyZWF0aW5nIGFuIHVycWwtY2xpZW50IHdpdGhvdXQgYSB1cmwuXCIpO1xuICB9XG4gIHZhciByID0gMDtcbiAgdmFyIHQgPSBuZXcgTWFwO1xuICB2YXIgbiA9IG5ldyBNYXA7XG4gIHZhciBhID0gbmV3IFNldDtcbiAgdmFyIG8gPSBbXTtcbiAgdmFyIGkgPSB7XG4gICAgdXJsOiBlLnVybCxcbiAgICBmZXRjaFN1YnNjcmlwdGlvbnM6IGUuZmV0Y2hTdWJzY3JpcHRpb25zLFxuICAgIGZldGNoT3B0aW9uczogZS5mZXRjaE9wdGlvbnMsXG4gICAgZmV0Y2g6IGUuZmV0Y2gsXG4gICAgcHJlZmVyR2V0TWV0aG9kOiAhIWUucHJlZmVyR2V0TWV0aG9kLFxuICAgIHJlcXVlc3RQb2xpY3k6IGUucmVxdWVzdFBvbGljeSB8fCBcImNhY2hlLWZpcnN0XCJcbiAgfTtcbiAgdmFyIHMgPSBEKCk7XG4gIGZ1bmN0aW9uIG5leHRPcGVyYXRpb24oZSkge1xuICAgIGlmIChcIm11dGF0aW9uXCIgPT09IGUua2luZCB8fCBcInRlYXJkb3duXCIgPT09IGUua2luZCB8fCAhYS5oYXMoZS5rZXkpKSB7XG4gICAgICBpZiAoXCJ0ZWFyZG93blwiID09PSBlLmtpbmQpIHtcbiAgICAgICAgYS5kZWxldGUoZS5rZXkpO1xuICAgICAgfSBlbHNlIGlmIChcIm11dGF0aW9uXCIgIT09IGUua2luZCkge1xuICAgICAgICBhLmFkZChlLmtleSk7XG4gICAgICB9XG4gICAgICBzLm5leHQoZSk7XG4gICAgfVxuICB9XG4gIHZhciBjID0gITE7XG4gIGZ1bmN0aW9uIGRpc3BhdGNoT3BlcmF0aW9uKGUpIHtcbiAgICBpZiAoZSkge1xuICAgICAgbmV4dE9wZXJhdGlvbihlKTtcbiAgICB9XG4gICAgaWYgKCFjKSB7XG4gICAgICBjID0gITA7XG4gICAgICB3aGlsZSAoYyAmJiAoZSA9IG8uc2hpZnQoKSkpIHtcbiAgICAgICAgbmV4dE9wZXJhdGlvbihlKTtcbiAgICAgIH1cbiAgICAgIGMgPSAhMTtcbiAgICB9XG4gIH1cbiAgdmFyIG1ha2VSZXN1bHRTb3VyY2UgPSByID0+IHtcbiAgICB2YXIgaSA9IE8oeSgoZSA9PiBcInRlYXJkb3duXCIgPT09IGUua2luZCAmJiBlLmtleSA9PT0gci5rZXkpKShzLnNvdXJjZSkpKHkoKGUgPT4gZS5vcGVyYXRpb24ua2luZCA9PT0gci5raW5kICYmIGUub3BlcmF0aW9uLmtleSA9PT0gci5rZXkgJiYgKCFlLm9wZXJhdGlvbi5jb250ZXh0Ll9pbnN0YW5jZSB8fCBlLm9wZXJhdGlvbi5jb250ZXh0Ll9pbnN0YW5jZSA9PT0gci5jb250ZXh0Ll9pbnN0YW5jZSkpKShnKSk7XG4gICAgaWYgKFwicXVlcnlcIiAhPT0gci5raW5kKSB7XG4gICAgICBpID0gQSgoZSA9PiAhIWUuaGFzTmV4dCksICEwKShpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaSA9IFYoKGUgPT4ge1xuICAgICAgICB2YXIgdCA9IHEoZSk7XG4gICAgICAgIHJldHVybiBlLnN0YWxlIHx8IGUuaGFzTmV4dCA/IHQgOiBFKFsgdCwgbSgoKCkgPT4ge1xuICAgICAgICAgIGUuc3RhbGUgPSAhMDtcbiAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfSkpKGgoMSkoeSgoZSA9PiBlLmtleSA9PT0gci5rZXkpKShzLnNvdXJjZSkpKSBdKTtcbiAgICAgIH0pKShpKTtcbiAgICB9XG4gICAgaWYgKFwibXV0YXRpb25cIiAhPT0gci5raW5kKSB7XG4gICAgICBpID0gTSgoKCkgPT4ge1xuICAgICAgICBhLmRlbGV0ZShyLmtleSk7XG4gICAgICAgIHQuZGVsZXRlKHIua2V5KTtcbiAgICAgICAgbi5kZWxldGUoci5rZXkpO1xuICAgICAgICBjID0gITE7XG4gICAgICAgIGZvciAodmFyIGUgPSBvLmxlbmd0aCAtIDE7IGUgPj0gMDsgZS0tKSB7XG4gICAgICAgICAgaWYgKG9bZV0ua2V5ID09PSByLmtleSkge1xuICAgICAgICAgICAgby5zcGxpY2UoZSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5leHRPcGVyYXRpb24obWFrZU9wZXJhdGlvbihcInRlYXJkb3duXCIsIHIsIHIuY29udGV4dCkpO1xuICAgICAgfSkpKE4oKGUgPT4ge1xuICAgICAgICBpZiAoZS5zdGFsZSkge1xuICAgICAgICAgIGZvciAodmFyIG4gb2Ygbykge1xuICAgICAgICAgICAgaWYgKG4ua2V5ID09PSBlLm9wZXJhdGlvbi5rZXkpIHtcbiAgICAgICAgICAgICAgYS5kZWxldGUobi5rZXkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWUuaGFzTmV4dCkge1xuICAgICAgICAgIGEuZGVsZXRlKHIua2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0LnNldChyLmtleSwgZSk7XG4gICAgICB9KSkoaSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpID0gUCgoKCkgPT4ge1xuICAgICAgICBuZXh0T3BlcmF0aW9uKHIpO1xuICAgICAgfSkpKGkpO1xuICAgIH1cbiAgICBpZiAoZS5tYXNrVHlwZW5hbWUpIHtcbiAgICAgIGkgPSBtKChlID0+ICh7XG4gICAgICAgIC4uLmUsXG4gICAgICAgIGRhdGE6IG1hc2tUeXBlbmFtZShlLmRhdGEsICEwKVxuICAgICAgfSkpKShpKTtcbiAgICB9XG4gICAgcmV0dXJuIGIoaSk7XG4gIH07XG4gIHZhciB1ID0gdGhpcyBpbnN0YW5jZW9mIENsaWVudCA/IHRoaXMgOiBPYmplY3QuY3JlYXRlKENsaWVudC5wcm90b3R5cGUpO1xuICB2YXIgcCA9IE9iamVjdC5hc3NpZ24odSwge1xuICAgIHN1c3BlbnNlOiAhIWUuc3VzcGVuc2UsXG4gICAgb3BlcmF0aW9ucyQ6IHMuc291cmNlLFxuICAgIHJlZXhlY3V0ZU9wZXJhdGlvbihlKSB7XG4gICAgICBpZiAoXCJ0ZWFyZG93blwiID09PSBlLmtpbmQpIHtcbiAgICAgICAgZGlzcGF0Y2hPcGVyYXRpb24oZSk7XG4gICAgICB9IGVsc2UgaWYgKFwibXV0YXRpb25cIiA9PT0gZS5raW5kIHx8IG4uaGFzKGUua2V5KSkge1xuICAgICAgICBvLnB1c2goZSk7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZGlzcGF0Y2hPcGVyYXRpb24pO1xuICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlUmVxdWVzdE9wZXJhdGlvbihlLCB0LCBuKSB7XG4gICAgICBpZiAoIW4pIHtcbiAgICAgICAgbiA9IHt9O1xuICAgICAgfVxuICAgICAgdmFyIGE7XG4gICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmIFwidGVhcmRvd25cIiAhPT0gZSAmJiAoYSA9IGYodC5xdWVyeSkpICE9PSBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgb3BlcmF0aW9uIG9mIHR5cGUgXCIke2V9XCIgYnV0IGZvdW5kIFwiJHthfVwiYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFrZU9wZXJhdGlvbihlLCB0LCB7XG4gICAgICAgIF9pbnN0YW5jZTogXCJtdXRhdGlvblwiID09PSBlID8gciA9IHIgKyAxIHwgMCA6IHZvaWQgMCxcbiAgICAgICAgLi4uaSxcbiAgICAgICAgLi4ubixcbiAgICAgICAgcmVxdWVzdFBvbGljeTogbi5yZXF1ZXN0UG9saWN5IHx8IGkucmVxdWVzdFBvbGljeSxcbiAgICAgICAgc3VzcGVuc2U6IG4uc3VzcGVuc2UgfHwgITEgIT09IG4uc3VzcGVuc2UgJiYgcC5zdXNwZW5zZVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBleGVjdXRlUmVxdWVzdE9wZXJhdGlvbihlKSB7XG4gICAgICBpZiAoXCJtdXRhdGlvblwiID09PSBlLmtpbmQpIHtcbiAgICAgICAgcmV0dXJuIHdpdGhQcm9taXNlKG1ha2VSZXN1bHRTb3VyY2UoZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdpdGhQcm9taXNlKFMoKCgpID0+IHtcbiAgICAgICAgdmFyIHIgPSBuLmdldChlLmtleSk7XG4gICAgICAgIGlmICghcikge1xuICAgICAgICAgIG4uc2V0KGUua2V5LCByID0gbWFrZVJlc3VsdFNvdXJjZShlKSk7XG4gICAgICAgIH1cbiAgICAgICAgciA9IFAoKCgpID0+IHtcbiAgICAgICAgICBkaXNwYXRjaE9wZXJhdGlvbihlKTtcbiAgICAgICAgfSkpKHIpO1xuICAgICAgICB2YXIgYSA9IHQuZ2V0KGUua2V5KTtcbiAgICAgICAgaWYgKFwicXVlcnlcIiA9PT0gZS5raW5kICYmIGEgJiYgKGEuc3RhbGUgfHwgYS5oYXNOZXh0KSkge1xuICAgICAgICAgIHJldHVybiBWKHEpKEUoWyByLCB5KChyID0+IHIgPT09IHQuZ2V0KGUua2V5KSkpKHEoYSkpIF0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfVxuICAgICAgfSkpKTtcbiAgICB9LFxuICAgIGV4ZWN1dGVRdWVyeShlLCByKSB7XG4gICAgICB2YXIgdCA9IHAuY3JlYXRlUmVxdWVzdE9wZXJhdGlvbihcInF1ZXJ5XCIsIGUsIHIpO1xuICAgICAgcmV0dXJuIHAuZXhlY3V0ZVJlcXVlc3RPcGVyYXRpb24odCk7XG4gICAgfSxcbiAgICBleGVjdXRlU3Vic2NyaXB0aW9uKGUsIHIpIHtcbiAgICAgIHZhciB0ID0gcC5jcmVhdGVSZXF1ZXN0T3BlcmF0aW9uKFwic3Vic2NyaXB0aW9uXCIsIGUsIHIpO1xuICAgICAgcmV0dXJuIHAuZXhlY3V0ZVJlcXVlc3RPcGVyYXRpb24odCk7XG4gICAgfSxcbiAgICBleGVjdXRlTXV0YXRpb24oZSwgcikge1xuICAgICAgdmFyIHQgPSBwLmNyZWF0ZVJlcXVlc3RPcGVyYXRpb24oXCJtdXRhdGlvblwiLCBlLCByKTtcbiAgICAgIHJldHVybiBwLmV4ZWN1dGVSZXF1ZXN0T3BlcmF0aW9uKHQpO1xuICAgIH0sXG4gICAgcmVhZFF1ZXJ5KGUsIHIsIHQpIHtcbiAgICAgIHZhciBuID0gbnVsbDtcbiAgICAgIGsoKGUgPT4ge1xuICAgICAgICBuID0gZTtcbiAgICAgIH0pKShwLnF1ZXJ5KGUsIHIsIHQpKS51bnN1YnNjcmliZSgpO1xuICAgICAgcmV0dXJuIG47XG4gICAgfSxcbiAgICBxdWVyeTogKGUsIHIsIHQpID0+IHAuZXhlY3V0ZVF1ZXJ5KHYoZSwgciksIHQpLFxuICAgIHN1YnNjcmlwdGlvbjogKGUsIHIsIHQpID0+IHAuZXhlY3V0ZVN1YnNjcmlwdGlvbih2KGUsIHIpLCB0KSxcbiAgICBtdXRhdGlvbjogKGUsIHIsIHQpID0+IHAuZXhlY3V0ZU11dGF0aW9uKHYoZSwgciksIHQpXG4gIH0pO1xuICB2YXIgZCA9IG5vb3A7XG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICB2YXIge25leHQ6IGwsIHNvdXJjZTogeH0gPSBEKCk7XG4gICAgcC5zdWJzY3JpYmVUb0RlYnVnVGFyZ2V0ID0gZSA9PiBrKGUpKHgpO1xuICAgIGQgPSBsO1xuICB9XG4gIHZhciB3ID0gY29tcG9zZUV4Y2hhbmdlcyhlLmV4Y2hhbmdlcyk7XG4gIHZhciBnID0gYih3KHtcbiAgICBjbGllbnQ6IHAsXG4gICAgZGlzcGF0Y2hEZWJ1ZzogZCxcbiAgICBmb3J3YXJkOiBmYWxsYmFja0V4Y2hhbmdlKHtcbiAgICAgIGRpc3BhdGNoRGVidWc6IGRcbiAgICB9KVxuICB9KShzLnNvdXJjZSkpO1xuICBSKGcpO1xuICByZXR1cm4gcDtcbn07XG5cbnZhciBqID0gQztcblxuZXhwb3J0IHsgQyBhcyBDbGllbnQsIG4gYXMgQ29tYmluZWRFcnJvciwgY2FjaGVFeGNoYW5nZSwgY29tcG9zZUV4Y2hhbmdlcywgaiBhcyBjcmVhdGVDbGllbnQsIHYgYXMgY3JlYXRlUmVxdWVzdCwgZGVidWdFeGNoYW5nZSwgZGVkdXBFeGNoYW5nZSwgbWFwRXhjaGFuZ2UgYXMgZXJyb3JFeGNoYW5nZSwgZmV0Y2hFeGNoYW5nZSwgZm9ybWF0RG9jdW1lbnQsIGdxbCwgYyBhcyBtYWtlRXJyb3JSZXN1bHQsIG1ha2VPcGVyYXRpb24sIHMgYXMgbWFrZVJlc3VsdCwgbWFwRXhjaGFuZ2UsIG1hc2tUeXBlbmFtZSwgbyBhcyBtZXJnZVJlc3VsdFBhdGNoLCBzc3JFeGNoYW5nZSwgdCBhcyBzdHJpbmdpZnlEb2N1bWVudCwgc3Vic2NyaXB0aW9uRXhjaGFuZ2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVycWwtY29yZS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/../../node_modules/.pnpm/@urql+core@4.0.10_graphql@16.11.0/node_modules/@urql/core/dist/urql-core.mjs\n");

/***/ })

};
;